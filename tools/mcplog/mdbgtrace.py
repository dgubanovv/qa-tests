#!/usr/local/bin/python2.7
#
#                    Copyright 2008-2013 Aquantia Corporation
#                    Confidential and Proprietary
#
# This file was auto-generated by ../utils/atldbggen.py using this command:
#      ../utils/atldbggen.py -i ../include/dbgMsgs.h -o ../include/dbgMsgArgs.h -p ../../tools/scripts/common/atldbgtrace.py
#

#################################################
#
# Debug Trace Class: Provides method to create debug trace in human readable format.
#                    Input raw data can be read directly from the uP memory or it can
#                    be provided as an input text file.
# Anil Dec13: Contents of dbgatlhelper.py are pasted below instead of importing
# dbgatlhelper.py. This makes it easier for the release process, so that we
# do not have to release dbgatlhelper.py separately i.e. only dbgtrace.py
# in the release package should suffice.
#

######### START of contents from dbgatlhelper.py ###############

"""
dbgatlhelper.py
Note: Contents of this file are pasted into dbgatltrace.py during auto-generation.
This file should be kept in sync with firmware/include/dbgMsgs.h
"""

import math
import os
import struct
import sys
import time
from array import *
from argparse import ArgumentParser
from functools import partial

if __package__ is None:
    sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "Eur"))

from eurdbgtrace import printTrace as phyPrintTrace, CPhyControlStub

PHY_CTRL = CPhyControlStub()
START_PHY_LOGS = False

# Dictionary of parsing format specification in case debug trace structure is dumped as a raw data.
# This dictionary will be used in 'd' input format option.
#
#
# Dictionary keys function will return keys in arbitrary order
# therefore keys need to be sorted to get the right order.
# Requirement of dictionary keys are to be alphabetically ordered
# by adding corresponding prefix

"""

typedef struct
{
unsigned short length;   // Length of the circular buffer. PHY dumps data to
// this buffer and sends data from here in chunks to
                         // mailbox buffer upon request from host.
unsigned short hostBuffLength; // Length of the mailbox buffer. Host reads from this buffer.
dbgBufferMode_t mode;     // 0 = overflow mode, 1 = skip mode;
unsigned bytesSkipped;   // Number of skipped bytes due to overflow
unsigned char writeEnable; // 0 = Write into the circular buffer is not enabled
                           // 1 = Write to circular buffer is enabled
unsigned char overflow;  // Overflow flag
unsigned char * readStartOfMsg; // Pointer to the start of message

unsigned char * write;      // Write index to the first available location
unsigned char * read;       // Read index
short depth;                // Current number of elements in the buffer
short len;                  // Buffer length
char overflow;              // Overflow status bit
char underflow;             // Underflow status bit
unsigned char * storage;    // Pointer to the storage

unsigned char buff[DBG_BUFFER_SIZE]; // Circular buffer storage
unsigned char hostBuff[DBG_HOST_BUFFER_SIZE]; // Host buffer storage. Host
                                         // reads from here. FW reads from circular
                                         // buffer and writes here
} dbgBuff_t;


"""

faults = {
    0x8001: 'AQ_EXIT_WRONG_ARCHITECTURE',
    0xDEAD: 'AQ_FAULT_IRAM_UNCORRECTABLE_PARITY_ERROR',
    0xDEAE: 'AQ_FAULT_DRAM_PARITY_ERROR',
    0xDEAF: 'AQ_FAULT_IRAM_CORRECTABLE_PARITY_ERROR',
    0xDD00: 'AQ_FAULT_IRAM_CRC16_ERROR'
}

UsxMsgType = [
    'Aneg: Started',
    'Aneg: Done',
    'Aneg: Pending',
]

anegRates = [
    '10M',
    '100M',
    '1G',
    '10G',
    '2.5G',
    '5G',
    "Invalid"
]

provVars = [
    'Reset Id',
    'Autoneg status',
    'USX autoneg status',
    'Last time for Rx Eq Cal',
    'USX autonegotiation restarts count',
    'Serdes Calibration SMC state',
    'Serdes Claibrations count',
    'Link status',
    'SIF Reconfigs count',
]


def list2str(stream):
    """
    Convert list of shorts into string
    """

    out = ''
    for c in stream:
        lbyte = c & 0xFF
        if (lbyte == 0):
            break
        out = out + chr(lbyte)
        # print lbyte
        mbyte = ((c & 0xFF00) >> 8) & 0xFF
        if (mbyte == 0):
            break
        # print mbyte
        out = out + chr(mbyte)

    # print out

    # Get Rid of double new lines
    out = out.replace('\r', '')

    # Get Rid of empty lines
    result = out
    """
    result = ''
    for s in out.split('\n'):
        line = s.strip()
        if len(line) > 1:
            result += s.strip() + '\n'
    # leave a trailing \n only if there was one
    if out[-1] != '\n':
        result = result[:-1]
    """

    return result


#################################################################
#
# RPC serialization and deserialization
#
##

atlRpcGlobalSeq = 0
atlMessageList = list()


class rpcBaseProcessor(object):
    def __init__(self):
        self.rpcQueue = list()

    def addTask(self, rpc, request, msgObject):
        self.rpcQueue.append((rpc, request, msgObject))

    def doTask(self):
        if self.rpcQueue:
            self.rpcQueue.pop(0)

    def getresponseattr(self, seq, attr, wait):
        # do nothing
        return


# multithreading not supported
def generateSeq():
    global atlRpcGlobalSeq
    atlRpcGlobalSeq += 1
    return atlRpcGlobalSeq


def deserializeVal(buf, type):
    if type == "uint16_t":
        return (buf[0], 1)
    elif type == "int16_t":
        return ((0x7FFF & buf[0]) * (-1 if (0x8000 & buf[0]) != 0 else 1), 1)
    elif type == "uint32_t":
        return (buf[0] + (buf[1] << 16), 2)
    elif type == "int32_t":
        return ((buf[0] + ((0x7FFF & buf[1]) << 16)) * (-1 if (0x8000 & buf[1]) != 0 else 1), 2)
    elif ((type[-1] == "]") and (type[-2] == "[")):
        r = array('I')
        i = 0
        k = 0
        # first word is array count
        ar_len = buf[0]
        for b in buf[1:]:
            k += 1
            if type == "uint16_t[]":
                r.append(b)
            elif type == "int16_t[]":
                r.append((0x7FFF & b) * (-1 if (0x8000 & b) != 0 else 1))
            elif type == "uint32_t[]" or type == "int32_t[]":
                if i == 0:
                    r.append(b)
                    i = 1
                else:
                    if type == "uint32_t[]":
                        r[-1] += b << 16
                    else:
                        r[-1] += (b & 0x7FFF) << 16
                        r[-1] *= -1
                    i = 0
            elif type == "uint8_t[]":
                r.append(b & 0xFF)
                r.append((b & 0xFF00) >> 8)
            else:
                print 'Unknown attribute type: %s' % (type)
                sys.exit(1)
        if ar_len % 2 == 1:
            del r[-1]
        return (r, k)
    else:
        print 'Unknown attribute type: %s' % (type)
        sys.exit(1)


def serializeVal(val, type):
    r = array('I')
    # uint*-t is supported only as array element, needed for recursive call from below
    if type == "uint16_t" or type == "uint8_t":
        r.append(val)
    elif type == "int16_t":
        r.append(abs(val) + (0x8000 if val < 0 else 0))
    elif type == "uint32_t":
        r.append(val & 0xFFFF)
        r.append((val & 0xFFFF0000) >> 16)
    elif type == "int32_t":
        r.append(val & 0xFFFF)
        r.append(((abs(val) & 0xFFFF0000) >> 16) + (0x8000 if val < 0 else 0))
    elif type[-1] == "]" and type[-2] == "[":
        # add one word as array count
        r.append(len(val))
        t = type[0:-2]
        i = 0
        v2 = 0
        for v in val:
            if i == 0 and t == "uint8_t":
                v2 = v
                i = 1
                continue
            elif t == "uint8_t":
                v2 += v << 8
                i = 0
            else:
                v2 = v
            r += serializeVal(v2, t)
        if t == "uint8_t" and i == 1:
            r += serializeVal(v2, t)
    else:
        print 'Unknown attribute type: %s' % (type)
        sys.exit(1)
    return r


def msgPush(buf):
    atlMessageList.append(buf)


def msgPop():
    if not atlMessageList:
        return None
    return atlMessageList.pop(0)


def msgGet():
    if not atlMessageList:
        return None
    return atlMessageList[-1]


#################################################################
#
# Message Parsing Functions
#
##

def formatMsgIndent():
    return '%10s' % ('')


def formatTimeStamp(time):
    return str(time) + ' ms:'


def getTime(lsw, msw):
    """
    Create 32 bit time stamp from 16 bit lsw and 16 bit msw inputs
    """

    if (lsw < 0):
        lsw = lsw + (1 << 16)

    if (msw < 0):
        msw = msw + (1 << 16)

    timeStamp = lsw + (msw << 16)
    return timeStamp


def formatUSXMsg(timeLsw, timeMsw, type, rate):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    msg = "%s USX " % (formatTimeStamp(currentTimeStamp))
    msg += UsxMsgType[type]
    msg += " Rate:%s" % anegRates[rate]
    return msg


def shortToEnableStatus(endis, isAlreadyDone):
    if (endis != 0):
        result = "Enable"
    else:
        result = "Disable"

    if (isAlreadyDone > 0):
        result += "d"

    return result


def shortToFlashModeStr(isFlashless):
    if (isFlashless != 0):
        result = "FLASHLESS"
    else:
        result = "FLASH"

    return result


def getLowerByteFromShort(value):
    byte = value & 0x00FF
    return byte


def getUpperByteFromShort(value):
    byte = (value >> 8) & 0x00FF
    return byte


def provVarLogger(id, value):
    msg = provVars[id]
    msg += ": %d" % (value)
    return msg


def sumArguments(arg1, arg2):
    """
    Demo function to illustrate formating of debug message
    """
    return arg1 + arg2


def makeDword(loword, hiword):
    """
    make dword from loword and high word
    """
    return loword + (hiword << 16)


def getSupportedStrFromShort(flag):
    return "supported" if flag else "not supported"


def getMsgId(data):
    """
    Get message id from the header of Atlantic debug message
    """
    return (data & 0x7F00) >> 8


def getMsgId2x(data):
    """
    Get message id from the header of Atlantic debug message
    """
    return (data & 0x7FFF)


def getNeedTimestampFlag2x(data):
    """
    Get if timestamp is needed from the header of Atlantic debug message
    """
    return ((data >> 15) & 1)


def getMsgLen(data):
    """
    Get message len from the header of Atlantic debug message
    """
    return data & 0xFF


def getMsg(data):
    """
    Get message string and number of arguments
    """
    return [mdbgconstants.msgIds[data][0], mdbgconstants.msgIds[data][1]]


def parsePhyPart(phyLogData):
    outPhyString = ""

    if len(phyLogData) > 0:
        try:
            outPhyString, _, _ = phyPrintTrace(PHY_CTRL, phyLogData)
        except Exception:
            pass
        outPhyString = "\n".join("PHY: {}".format(line) for line in outPhyString.splitlines())
        phyLogData = []

    return outPhyString, phyLogData


def printTrace(buff, fwVer, rpcProcessor=None):
    """
    Desc:
    Params: buff = List containing messages. List may contain fractional
                   number of messages.
    Return  [msgString rem status]
                msgString = Message string in human readable form containing integer whole number of messages.
                rem = List with the remainder fractional message that couldn't be decoded.
                status = 0 - success
                         1 - parse error
                         2 - callback function error
    """

    #
    # Print out the data from the buffer in human readable form
    #
    outString = ""
    rem = []
    status = 0

    global START_PHY_LOGS, PHY_CTRL
    phyLogData = []

    index = 0
    while index < len(buff):
        data = buff[index]

        if (data & 0xC000) == 0xC000:  # RPC
            rpc = (data & 0x3F00) >> 8
            nArgs = data & 0x7F
            rpc_request = (data & 0x80) >> 7

            args = buff[index + 1:index + 1 + nArgs]

            if rpcProcessor is not None:
                outString += "Processing RPC %s: %d\n" % (("request" if rpc_request else "response"), rpc)
                rpcProcess(rpcProcessor, rpc, rpc_request, args)
            else:
                outString += "Skipping RPC %s: %d\n" % (("request" if rpc_request else "response"), rpc)
        else:  # Atlantic message
            if fwVer == 2:
                msgId = getMsgId2x(data)
                isPhyPart = msgId & 0x0200
            else:
                msgId = getMsgId(data)
                isPhyPart = (msgId == 0x0F)

            if isPhyPart:  # PHY part
                nArgs = getMsgLen(data)

                if nArgs == 0:
                    if not START_PHY_LOGS:
                        START_PHY_LOGS = True
                    else:
                        START_PHY_LOGS = False

                        outPhyString, phyLogData = parsePhyPart(phyLogData)
                        outString += outPhyString
                elif nArgs > 0:
                    phyAddLogData = buff[index + 1:index + nArgs + 1]
                    phyLogData.extend(phyAddLogData)

                    if len(phyAddLogData) != nArgs:
                        outPhyString, phyLogData = parsePhyPart(phyLogData)
                        outString += outPhyString
                        break

                    index += nArgs
            else:  # MAC part
                if fwVer == 2:  # FW 2.x
                    if index + 1 < len(buff):
                        msgLen = buff[index + 1]
                    else:
                        break

                    try:
                        nArgs, msgCall = getMsg(msgId)
                        if msgId == 0x00:  # DBG_ID_PRINTF
                            nArgs = msgLen
                        elif msgId == 0x01:  # DBG_ID_STRING
                            nArgs = msgLen
                    except IndexError:
                        errStr = "ERROR: Parsing Debug Trace Error: " \
                                "Bad message in trace %04X. Buffer index:%d len:%d" % (data, index, len(buff))
                        outString += errStr + "\n"
                        status = 1
                        index += 1
                        continue

                    isTimestampNeeded = getNeedTimestampFlag2x(data)

                    if isTimestampNeeded:
                        # Two words for timestamp
                        args = buff[index + 4:index + 4 + nArgs]
                    else:
                        args = buff[index + 2:index + 2 + nArgs]

                    if len(args) < nArgs:
                        break

                    # Check arguments number is correct
                    if (isTimestampNeeded and (msgLen != nArgs + 2)) or ((not isTimestampNeeded) and (msgLen != nArgs)):
                        errStr = "ERROR: Parsing Debug Trace Error: " \
                                "Bad arguments number %d for message ID %04X at index %d. Expected %d." % (
                                    (msgLen - 2) if isTimestampNeeded else msgLen, data, index, nArgs)
                        outString += errStr + "\n"
                        index += 1
                        continue
                    if ((msgId not in [0x00, 0x01]) and nArgs > 31) or ((msgId in [0x00, 0x01]) and nArgs > 0xFF):
                        errStr = "ERROR: Parsing debug Trace Error: " \
                                "Too many arguments %d for message ID %04X at index %d." % (
                                    nArgs, msgId, index)
                        outString += errStr + "\n"
                        index += 1
                        continue

                    try:
                        decodedMessage = getattr(mdbgconstants, msgCall)(args)
                        if isTimestampNeeded:
                            timestamp = makeDword(buff[index + 2], buff[index + 3])
                            decodedMessage = ("%d " % (timestamp)) + decodedMessage
                        outString += decodedMessage
                    except IndexError:
                        errStr = "ERROR: Index %d is out of range while parsing trace with callback function %s and ID %d. Buffer len: %d" % (
                            index, msgCall, msgId, len(buff))
                        status = 2
                        outString += errStr + "\n"
                    except Exception:
                        errStr = "ERROR: Parsing Debug Trace: Bad callback function %s with ID %d. Buffer index:%d len:%d" % (
                            msgCall, msgId, index, len(buff))
                        status = 2
                        outString += errStr + "\n"

                    index += msgLen + 1
                else:  # FW 1.x and 3.x
                    try:
                        nArgs, msgCall = getMsg(msgId)
                        if msgId == 0x00:  # DBG_ATL_PRINTF
                            nArgs = getMsgLen(data)
                    except:
                        errStr = "ERROR: Parsing Debug Trace Error: " \
                                "Bad message in trace %8X. Buffer index:%d len:%d" % (data, index, len(buff))
                        # print errStr
                        outString += errStr + "\n"
                        status = 1
                        index += 1
                        continue

                    if nArgs == 0:
                        index += 1
                        continue

                    args = buff[index + 1:index + 1 + nArgs]

                    if len(args) < nArgs:
                        break

                    try:
                        decodedMessage = getattr(mdbgconstants, msgCall)(args)
                        outString += decodedMessage
                    except:
                        errStr = "ERROR: Parsing Debug Trace: Bad callback function %s. Buffer index:%d len:%d" % (
                            msgCall, index, len(buff))
                        status = 2
                        # print errStr
                        outString += errStr + "\n"
                        break

                    index += nArgs

        index += 1

    # Get the fractional message.
    if index < len(buff):
        rem = buff[index:len(buff)]

    return outString, rem, status


######### END of contents from dbgatlhelper.py ###############

RPC_ATL_REGWRITE = 0
RPC_ATL_REGREAD = 1
RPC_ATL_EXEC = 2
RPC_ATL_GETSTAT = 3
RPC_ATL_LINK = 4
RPC_ATL_GETTEMP = 5
RPC_ATL_MEMREAD = 6
RPC_ATL_WRITESERDES = 7
RPC_ATL_READSERDES = 8
RPC_ATL_PROVISIONSET = 9
RPC_ATL_PROVISIONGET = 10
RPC_ATL_MDIOREAD = 11
RPC_ATL_MDIOWRITE = 12
RPC_ATL_GPIOGET = 13
RPC_ATL_GPIOSET = 14
RPC_ATL_READNVR = 15


class RPC_ATL_REGWRITE_IN:
    def __init__(self, seq, address, data):
        self.seq = seq
        self.address = address
        self.data = data

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (address, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, address, data)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.address, "uint32_t"))
        buf.extend(serializeVal(self.data, "uint32_t"))
        return buf


class RPC_ATL_REGWRITE_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_REGWRITE_REQ(
        address,  # uint32_t
        data):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_REGWRITE_IN(seq, address, data)
    buf = array('I', [(0xC000 | (RPC_ATL_REGWRITE << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_REGWRITE_RESP(seq,
                          result):  # uint16_t
    req = RPC_ATL_REGWRITE_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_REGWRITE << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_REGREAD_IN:
    def __init__(self, seq, address):
        self.seq = seq
        self.address = address

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (address, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, address)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.address, "uint32_t"))
        return buf


class RPC_ATL_REGREAD_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_REGREAD_REQ(
        address):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_REGREAD_IN(seq, address)
    buf = array('I', [(0xC000 | (RPC_ATL_REGREAD << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_REGREAD_RESP(seq,
                         data,  # uint32_t
                         result):  # uint16_t
    req = RPC_ATL_REGREAD_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_REGREAD << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_EXEC_IN:
    def __init__(self, seq, cmd):
        self.seq = seq
        self.cmd = cmd

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (cmd, sz) = deserializeVal(buf[i:len(buf)], "uint8_t[]")
        i += sz
        return cls(seq, cmd)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.cmd, "uint8_t[]"))
        return buf


class RPC_ATL_EXEC_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_EXEC_REQ(
        cmd):  # uint8_t[]
    seq = generateSeq()
    req = RPC_ATL_EXEC_IN(seq, cmd)
    buf = array('I', [(0xC000 | (RPC_ATL_EXEC << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_EXEC_RESP(seq,
                      result):  # uint16_t
    req = RPC_ATL_EXEC_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_EXEC << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_GETSTAT_IN:
    def __init__(self, seq, object, index):
        self.seq = seq
        self.object = object
        self.index = index

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (object, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (index, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, object, index)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.object, "uint32_t"))
        buf.extend(serializeVal(self.index, "uint32_t"))
        return buf


class RPC_ATL_GETSTAT_OUT:
    def __init__(self, seq, count, truncation, lost, parity, checksum, mac):
        self.seq = seq
        self.count = count
        self.truncation = truncation
        self.lost = lost
        self.parity = parity
        self.checksum = checksum
        self.mac = mac

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (count, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (truncation, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (lost, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (parity, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (checksum, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (mac, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, count, truncation, lost, parity, checksum, mac)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.count, "uint32_t"))
        buf.extend(serializeVal(self.truncation, "uint32_t"))
        buf.extend(serializeVal(self.lost, "uint32_t"))
        buf.extend(serializeVal(self.parity, "uint32_t"))
        buf.extend(serializeVal(self.checksum, "uint32_t"))
        buf.extend(serializeVal(self.mac, "uint32_t"))
        return buf


def RPC_ATL_GETSTAT_REQ(
        object,  # uint32_t
        index):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_GETSTAT_IN(seq, object, index)
    buf = array('I', [(0xC000 | (RPC_ATL_GETSTAT << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_GETSTAT_RESP(seq,
                         count,  # uint32_t
                         truncation,  # uint32_t
                         lost,  # uint32_t
                         parity,  # uint32_t
                         checksum,  # uint32_t
                         mac):  # uint32_t
    req = RPC_ATL_GETSTAT_OUT(seq, count, truncation, lost, parity, checksum, mac)
    buf = array('I', [(0xC000 | (RPC_ATL_GETSTAT << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_LINK_IN:
    def __init__(self, seq, index, sysLink, netLink):
        self.seq = seq
        self.index = index
        self.sysLink = sysLink
        self.netLink = netLink

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (index, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        (sysLink, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        (netLink, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, index, sysLink, netLink)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.index, "uint16_t"))
        buf.extend(serializeVal(self.sysLink, "uint16_t"))
        buf.extend(serializeVal(self.netLink, "uint16_t"))
        return buf


class RPC_ATL_LINK_OUT:
    def __init__(self, seq, sysLink, netLink):
        self.seq = seq
        self.sysLink = sysLink
        self.netLink = netLink

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (sysLink, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        (netLink, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, sysLink, netLink)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.sysLink, "uint16_t"))
        buf.extend(serializeVal(self.netLink, "uint16_t"))
        return buf


def RPC_ATL_LINK_REQ(
        index,  # uint16_t
        sysLink,  # uint16_t
        netLink):  # uint16_t
    seq = generateSeq()
    req = RPC_ATL_LINK_IN(seq, index, sysLink, netLink)
    buf = array('I', [(0xC000 | (RPC_ATL_LINK << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_LINK_RESP(seq,
                      sysLink,  # uint16_t
                      netLink):  # uint16_t
    req = RPC_ATL_LINK_OUT(seq, sysLink, netLink)
    buf = array('I', [(0xC000 | (RPC_ATL_LINK << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_GETTEMP_IN:
    def __init__(self, seq, index):
        self.seq = seq
        self.index = index

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (index, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, index)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.index, "uint32_t"))
        return buf


class RPC_ATL_GETTEMP_OUT:
    def __init__(self, seq, hi, lo, result):
        self.seq = seq
        self.hi = hi
        self.lo = lo
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (hi, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        (lo, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, hi, lo, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.hi, "uint16_t"))
        buf.extend(serializeVal(self.lo, "uint16_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_GETTEMP_REQ(
        index):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_GETTEMP_IN(seq, index)
    buf = array('I', [(0xC000 | (RPC_ATL_GETTEMP << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_GETTEMP_RESP(seq,
                         hi,  # uint16_t
                         lo,  # uint16_t
                         result):  # uint16_t
    req = RPC_ATL_GETTEMP_OUT(seq, hi, lo, result)
    buf = array('I', [(0xC000 | (RPC_ATL_GETTEMP << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_MEMREAD_IN:
    def __init__(self, seq, address):
        self.seq = seq
        self.address = address

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (address, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, address)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.address, "uint32_t"))
        return buf


class RPC_ATL_MEMREAD_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_MEMREAD_REQ(
        address):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_MEMREAD_IN(seq, address)
    buf = array('I', [(0xC000 | (RPC_ATL_MEMREAD << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_MEMREAD_RESP(seq,
                         data,  # uint32_t
                         result):  # uint16_t
    req = RPC_ATL_MEMREAD_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_MEMREAD << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_WRITESERDES_IN:
    def __init__(self, seq, serdes, addr, data):
        self.seq = seq
        self.serdes = serdes
        self.addr = addr
        self.data = data

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (serdes, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (addr, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, serdes, addr, data)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.serdes, "uint32_t"))
        buf.extend(serializeVal(self.addr, "uint32_t"))
        buf.extend(serializeVal(self.data, "uint32_t"))
        return buf


class RPC_ATL_WRITESERDES_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_WRITESERDES_REQ(
        serdes,  # uint32_t
        addr,  # uint32_t
        data):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_WRITESERDES_IN(seq, serdes, addr, data)
    buf = array('I', [(0xC000 | (RPC_ATL_WRITESERDES << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_WRITESERDES_RESP(seq,
                             result):  # uint16_t
    req = RPC_ATL_WRITESERDES_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_WRITESERDES << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_READSERDES_IN:
    def __init__(self, seq, serdes, addr):
        self.seq = seq
        self.serdes = serdes
        self.addr = addr

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (serdes, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (addr, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, serdes, addr)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.serdes, "uint32_t"))
        buf.extend(serializeVal(self.addr, "uint32_t"))
        return buf


class RPC_ATL_READSERDES_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_READSERDES_REQ(
        serdes,  # uint32_t
        addr):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_READSERDES_IN(seq, serdes, addr)
    buf = array('I', [(0xC000 | (RPC_ATL_READSERDES << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_READSERDES_RESP(seq,
                            data,  # uint32_t
                            result):  # uint16_t
    req = RPC_ATL_READSERDES_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_READSERDES << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_PROVISIONSET_IN:
    def __init__(self, seq, id, val):
        self.seq = seq
        self.id = id
        self.val = val

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (id, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (val, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, id, val)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.id, "uint32_t"))
        buf.extend(serializeVal(self.val, "uint32_t"))
        return buf


class RPC_ATL_PROVISIONSET_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_PROVISIONSET_REQ(
        id,  # uint32_t
        val):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_PROVISIONSET_IN(seq, id, val)
    buf = array('I', [(0xC000 | (RPC_ATL_PROVISIONSET << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_PROVISIONSET_RESP(seq,
                              result):  # uint16_t
    req = RPC_ATL_PROVISIONSET_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_PROVISIONSET << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_PROVISIONGET_IN:
    def __init__(self, seq, id):
        self.seq = seq
        self.id = id

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (id, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, id)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.id, "uint32_t"))
        return buf


class RPC_ATL_PROVISIONGET_OUT:
    def __init__(self, seq, val, result):
        self.seq = seq
        self.val = val
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (val, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, val, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.val, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_PROVISIONGET_REQ(
        id):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_PROVISIONGET_IN(seq, id)
    buf = array('I', [(0xC000 | (RPC_ATL_PROVISIONGET << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_PROVISIONGET_RESP(seq,
                              val,  # uint32_t
                              result):  # uint16_t
    req = RPC_ATL_PROVISIONGET_OUT(seq, val, result)
    buf = array('I', [(0xC000 | (RPC_ATL_PROVISIONGET << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_MDIOREAD_IN:
    def __init__(self, seq, mmd, addr):
        self.seq = seq
        self.mmd = mmd
        self.addr = addr

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (mmd, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (addr, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, mmd, addr)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.mmd, "uint32_t"))
        buf.extend(serializeVal(self.addr, "uint32_t"))
        return buf


class RPC_ATL_MDIOREAD_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_MDIOREAD_REQ(
        mmd,  # uint32_t
        addr):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_MDIOREAD_IN(seq, mmd, addr)
    buf = array('I', [(0xC000 | (RPC_ATL_MDIOREAD << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_MDIOREAD_RESP(seq,
                          data,  # uint32_t
                          result):  # uint16_t
    req = RPC_ATL_MDIOREAD_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_MDIOREAD << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_MDIOWRITE_IN:
    def __init__(self, seq, mmd, addr, data):
        self.seq = seq
        self.mmd = mmd
        self.addr = addr
        self.data = data

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (mmd, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (addr, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, mmd, addr, data)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.mmd, "uint32_t"))
        buf.extend(serializeVal(self.addr, "uint32_t"))
        buf.extend(serializeVal(self.data, "uint32_t"))
        return buf


class RPC_ATL_MDIOWRITE_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_MDIOWRITE_REQ(
        mmd,  # uint32_t
        addr,  # uint32_t
        data):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_MDIOWRITE_IN(seq, mmd, addr, data)
    buf = array('I', [(0xC000 | (RPC_ATL_MDIOWRITE << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_MDIOWRITE_RESP(seq,
                           result):  # uint16_t
    req = RPC_ATL_MDIOWRITE_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_MDIOWRITE << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_GPIOGET_IN:
    def __init__(self, seq, bit):
        self.seq = seq
        self.bit = bit

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (bit, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, bit)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.bit, "uint32_t"))
        return buf


class RPC_ATL_GPIOGET_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_GPIOGET_REQ(
        bit):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_GPIOGET_IN(seq, bit)
    buf = array('I', [(0xC000 | (RPC_ATL_GPIOGET << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_GPIOGET_RESP(seq,
                         data,  # uint32_t
                         result):  # uint16_t
    req = RPC_ATL_GPIOGET_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_GPIOGET << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_GPIOSET_IN:
    def __init__(self, seq, bit, data):
        self.seq = seq
        self.bit = bit
        self.data = data

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (bit, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, bit, data)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.bit, "uint32_t"))
        buf.extend(serializeVal(self.data, "uint32_t"))
        return buf


class RPC_ATL_GPIOSET_OUT:
    def __init__(self, seq, result):
        self.seq = seq
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_GPIOSET_REQ(
        bit,  # uint32_t
        data):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_GPIOSET_IN(seq, bit, data)
    buf = array('I', [(0xC000 | (RPC_ATL_GPIOSET << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_GPIOSET_RESP(seq,
                         result):  # uint16_t
    req = RPC_ATL_GPIOSET_OUT(seq, result)
    buf = array('I', [(0xC000 | (RPC_ATL_GPIOSET << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


class RPC_ATL_READNVR_IN:
    def __init__(self, seq, address):
        self.seq = seq
        self.address = address

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (address, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        return cls(seq, address)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.address, "uint32_t"))
        return buf


class RPC_ATL_READNVR_OUT:
    def __init__(self, seq, data, result):
        self.seq = seq
        self.data = data
        self.result = result

    @classmethod
    def fromBuffer(cls, seq, buf):
        i = 0
        (data, sz) = deserializeVal(buf[i:len(buf)], "uint32_t")
        i += sz
        (result, sz) = deserializeVal(buf[i:len(buf)], "uint16_t")
        i += sz
        return cls(seq, data, result)

    def serialize(self):
        buf = array('I')
        buf.extend(serializeVal(self.data, "uint32_t"))
        buf.extend(serializeVal(self.result, "uint16_t"))
        return buf


def RPC_ATL_READNVR_REQ(
        address):  # uint32_t
    seq = generateSeq()
    req = RPC_ATL_READNVR_IN(seq, address)
    buf = array('I', [(0xC000 | (RPC_ATL_READNVR << 8) | 0x80), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)
    return seq


def RPC_ATL_READNVR_RESP(seq,
                         data,  # uint32_t
                         result):  # uint16_t
    req = RPC_ATL_READNVR_OUT(seq, data, result)
    buf = array('I', [(0xC000 | (RPC_ATL_READNVR << 8)), seq])
    serializedReq = req.serialize()
    buf.extend(serializedReq)
    buf[0] |= len(serializedReq) + 1
    msgPush(buf)


def rpcProcess(processor, rpc, request, args):
    if RPC_ATL_REGWRITE == rpc and request:
        msgObject = RPC_ATL_REGWRITE_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_REGWRITE == rpc and not request:
        msgObject = RPC_ATL_REGWRITE_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_REGREAD == rpc and request:
        msgObject = RPC_ATL_REGREAD_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_REGREAD == rpc and not request:
        msgObject = RPC_ATL_REGREAD_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_EXEC == rpc and request:
        msgObject = RPC_ATL_EXEC_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_EXEC == rpc and not request:
        msgObject = RPC_ATL_EXEC_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GETSTAT == rpc and request:
        msgObject = RPC_ATL_GETSTAT_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GETSTAT == rpc and not request:
        msgObject = RPC_ATL_GETSTAT_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_LINK == rpc and request:
        msgObject = RPC_ATL_LINK_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_LINK == rpc and not request:
        msgObject = RPC_ATL_LINK_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GETTEMP == rpc and request:
        msgObject = RPC_ATL_GETTEMP_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GETTEMP == rpc and not request:
        msgObject = RPC_ATL_GETTEMP_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MEMREAD == rpc and request:
        msgObject = RPC_ATL_MEMREAD_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MEMREAD == rpc and not request:
        msgObject = RPC_ATL_MEMREAD_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_WRITESERDES == rpc and request:
        msgObject = RPC_ATL_WRITESERDES_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_WRITESERDES == rpc and not request:
        msgObject = RPC_ATL_WRITESERDES_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_READSERDES == rpc and request:
        msgObject = RPC_ATL_READSERDES_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_READSERDES == rpc and not request:
        msgObject = RPC_ATL_READSERDES_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_PROVISIONSET == rpc and request:
        msgObject = RPC_ATL_PROVISIONSET_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_PROVISIONSET == rpc and not request:
        msgObject = RPC_ATL_PROVISIONSET_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_PROVISIONGET == rpc and request:
        msgObject = RPC_ATL_PROVISIONGET_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_PROVISIONGET == rpc and not request:
        msgObject = RPC_ATL_PROVISIONGET_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MDIOREAD == rpc and request:
        msgObject = RPC_ATL_MDIOREAD_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MDIOREAD == rpc and not request:
        msgObject = RPC_ATL_MDIOREAD_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MDIOWRITE == rpc and request:
        msgObject = RPC_ATL_MDIOWRITE_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_MDIOWRITE == rpc and not request:
        msgObject = RPC_ATL_MDIOWRITE_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GPIOGET == rpc and request:
        msgObject = RPC_ATL_GPIOGET_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GPIOGET == rpc and not request:
        msgObject = RPC_ATL_GPIOGET_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GPIOSET == rpc and request:
        msgObject = RPC_ATL_GPIOSET_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_GPIOSET == rpc and not request:
        msgObject = RPC_ATL_GPIOSET_OUT.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_READNVR == rpc and request:
        msgObject = RPC_ATL_READNVR_IN.fromBuffer(args[0], args[1:len(args)])
    elif RPC_ATL_READNVR == rpc and not request:
        msgObject = RPC_ATL_READNVR_OUT.fromBuffer(args[0], args[1:len(args)])
    processor.addTask(rpc, request, msgObject)


def decrypt(words):
    res = []

    for word in words:
        data = ((word & 0x0F00) << 4) | ((word & 0xF000) >> 4) | ((word & 0x000F) << 4) | ((word & 0x00F0) >> 4)
        data = data ^ 0x7EC2
        res.append(int(data))

    return res


class DebugTrace(object):
    """
    Class for parsing debug trace
    """

    def __init__(self, maccontrol=None, phycontrol=None, fw_v=None):
        """
        Class initialization
        """
        if maccontrol is not None:
            version = maccontrol.macRegReadData(0x18)
            self.fw_v = (version >> 24) & 0x000000FF
        elif fw_v is not None:
            self.fw_v = fw_v

        if phycontrol is not None:
            global PHY_CTRL
            PHY_CTRL = phycontrol

        if self.fw_v == 1:
            from fw_v1 import mdbgconstants
        elif self.fw_v == 2:
            from fw_v2 import mdbgconstants
        elif self.fw_v == 3:
            from fw_v3 import mdbgconstants
        else:
            raise Exception("Unknown MAC firmware revision: {}".format(self.fw_v))

        # XXX: HACK to allow imported module dbghelper to see symbols

        import __builtin__

        # These globals are from dbgatlhelper
        __builtin__.mdbgconstants = mdbgconstants
        self.mdbgconstants = mdbgconstants
        __builtin__.ArrayType = ArrayType
        self.ArrayType = ArrayType
        __builtin__.UsxMsgType = UsxMsgType
        self.UsxMsgType = UsxMsgType
        __builtin__.anegRates = anegRates
        self.anegRates = anegRates
        __builtin__.atlMessageList = atlMessageList
        self.atlMessageList = atlMessageList
        __builtin__.atlRpcGlobalSeq = atlRpcGlobalSeq
        self.atlRpcGlobalSeq = atlRpcGlobalSeq
        __builtin__.deserializeVal = deserializeVal
        self.deserializeVal = deserializeVal
        __builtin__.faults = faults
        self.faults = faults
        __builtin__.formatMsgIndent = formatMsgIndent
        self.formatMsgIndent = formatMsgIndent
        __builtin__.formatTimeStamp = formatTimeStamp
        self.formatTimeStamp = formatTimeStamp
        __builtin__.formatUSXMsg = formatUSXMsg
        self.formatUSXMsg = formatUSXMsg
        __builtin__.shortToEnableStatus = shortToEnableStatus
        self.shortToEnableStatus = shortToEnableStatus
        __builtin__.shortToFlashModeStr = shortToFlashModeStr
        self.shortToFlashModeStr = shortToFlashModeStr
        __builtin__.getLowerByteFromShort = getLowerByteFromShort
        self.getLowerByteFromShort = getLowerByteFromShort
        __builtin__.getUpperByteFromShort = getUpperByteFromShort
        self.getUpperByteFromShort = getUpperByteFromShort
        __builtin__.generateSeq = generateSeq
        self.generateSeq = generateSeq
        __builtin__.getMsg = getMsg
        self.getMsg = getMsg
        __builtin__.getMsgId = getMsgId
        self.getMsgId = getMsgId
        __builtin__.getNeedTimestampFlag2x = getNeedTimestampFlag2x
        self.getNeedTimestampFlag2x = getNeedTimestampFlag2x
        __builtin__.getMsgLen = getMsgLen
        self.getMsgLen = getMsgLen
        __builtin__.getTime = getTime
        self.getTime = getTime
        __builtin__.list2str = list2str
        self.list2str = list2str
        __builtin__.makeDword = makeDword
        self.makeDword = makeDword
        __builtin__.msgGet = msgGet
        self.msgGet = msgGet
        __builtin__.msgPop = msgPop
        self.msgPop = msgPop
        __builtin__.msgPush = msgPush
        self.msgPush = msgPush
        __builtin__.printTrace = partial(printTrace, fwVer=self.fw_v)
        self.printTrace = partial(printTrace, fwVer=self.fw_v)
        __builtin__.provVarLogger = provVarLogger
        self.provVarLogger = provVarLogger
        __builtin__.getSupportedStrFromShort = getSupportedStrFromShort
        self.getSupportedStrFromShort = getSupportedStrFromShort
        __builtin__.provVars = provVars
        self.provVars = provVars
        __builtin__.rpcBaseProcessor = rpcBaseProcessor
        self.rpcBaseProcessor = rpcBaseProcessor
        __builtin__.serializeVal = serializeVal
        self.serializeVal = serializeVal
        __builtin__.sumArguments = sumArguments
        self.sumArguments = sumArguments

        # XXX: END OF HACK


############
#
# Main
#

if __name__ == '__main__':
    # Initialize parser
    parser = ArgumentParser()
    parser.add_argument('-f', '--inputFile', help='Specify input file name', required=True)
    parser.add_argument('-o', '--outputFile', help='Specify output file name')
    parser.add_argument('-v', '--fwVersion', help='Specify MAC firmware revision (1, 2, 3)',
                        type=int, choices=[1, 2, 3])
    parser.add_argument("-e", "--encrypted", action="store_true", default=False)
    parser.add_argument("--follow", action="store_true", default=False)

    # Get command line arguments
    args = parser.parse_args()

    if args.fwVersion is None:
        print("Warning: Choosing FW 3.x parser by default")
        args.fwVersion = 3

    # Instatiate debug trace class
    dbg = DebugTrace(fw_v=args.fwVersion)

    # Read file content
    with open(args.inputFile, "rb") as f_in:
        data = []

        if args.follow:
            rem = []

            while True:
                try:
                    data = rem

                    buff = f_in.read()
                    add_data = []
                    for i in range(len(buff) / 2):
                        add_data.append(struct.unpack("H", buff[i * 2:i * 2 + 2])[0])
                    if args.encrypted:
                        add_data = decrypt(add_data)
                    data.extend(add_data)

                    outString, rem, status = dbg.printTrace(data)
                    if outString:
                        print(outString)
                except KeyboardInterrupt:
                    break
        else:
            buff = f_in.read()
            for i in range(len(buff) // 2):
                data.append(struct.unpack("H", buff[i * 2:i * 2 + 2])[0])

            if args.encrypted:
                data = decrypt(data)

            outString, rem, status = dbg.printTrace(data)

            if args.outputFile:
                with open(args.outputFile, "w") as f_out:
                    f_out.write(outString)
            else:
                print(outString)
