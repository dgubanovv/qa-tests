#!/usr/local/bin/python2.5
#
#                    Copyright 2008-2013 Aquantia Corporation
#                    Confidential and Proprietary
#
# This file was auto-generated by ./../utils/autodbggen.py using this command:
#      ./../utils/autodbggen.py -i ./../include/dbgMsgs.h -o ./../include/dbgMsgArgs.h -p ./../../scripts/common/dbgtrace.py
#

#################################################
#
# Debug Trace Class: Provides method to create debug trace in human readable format.
#                    Input raw data can be read directly from the uP memory or it can
#                    be provided as an input text file.
# Anil Dec13: Contents of dbghelper.py are pasted below instead of importing
# dbghelper.py. This makes it easier for the release process, so that we
# do not have to release dbghelper.py separately i.e. only dbgtrace.py
# in the release package should suffice.
#

global phyControl

######### START of contents from dbghelper.py ###############

"""
dbghelper.py
Note: Contents of this file are pasted into dbgtrace.py during auto-generation.
"""

#--------------------------------------------------------------------
import sys
import time
import math
import traceback

########################################################
#Debug section 

#Specify debug print verbosity level 0 - none; 1 - warning; 2 - info; 3-x - verbose
gDebugVerbosityLevels = {"none": 0, "error": 1, "warning": 2, "info": 3, "verbose01": 4, "verbose02" : 5, "verbose03" : 6} 
gDebugVerbosityLevel = gDebugVerbosityLevels["warning"]
#gDebugVerbosityLevel = gDebugVerbosityLevels["info"]
#gDebugVerbosityLevel = gDebugVerbosityLevels["verbose01"]
#gDebugVerbosityLevel = gDebugVerbosityLevels["verbose02"]

#Debug - when enabled will not (ever) processed the last message in the host buffer
#    the intent is to to test dbgtrace ability to handle unprocessed remainder when partial messages are received
#gDebugTestModeDoNotProcessLastMessage = 1
#Debug - when enabled will pretend that the first message is corrupted and cannot be decoded
#    the intent is to to test dbgtrace ability to handle stream corruption
#gDebugTestModeCorruptFirstMessage = 1

#--------------------------------------------------------------------
filters = ['AEC',
           'DEC',
           'FFE',
           'DFE',
           'NEC',
           'NEC0',
           'NEC1',
           'NEC2',
           'FEC',
           'FEC0',
           'FEC1',
           'FEC2',
           'DFF',
           'DFFDEC',
           'DFFNEC0',
           'DFFNEC1',
           'DFFNEC2',
           ]

rates = ['RATE_10G',
         'RATE_5G',
         'RATE_5GSR',
         'RATE_2G5',
         'RATE_1G',
         'RATE_100M',
         'RATE_INVALID']

# Dictionary of parsing format specification in case debug trace structure is dumped as a raw data.
# This dictionary will be used in 'd' input format option.
#
#
# Dictionary keys function will return keys in arbitrary order
# therefore keys need to be sorted to get the right order.
# Requirement of dictionary keys are to be alphabetically ordered
# by adding corresponding prefix

"""

typedef struct
{
unsigned short length;   // Length of the circular buffer. PHY dumps data to
// this buffer and sends data from here in chunks to
                         // mailbox buffer upon request from host.
unsigned short hostBuffLength; // Length of the mailbox buffer. Host reads from this buffer.
dbgBufferMode_t mode;     // 0 = overflow mode, 1 = skip mode;
unsigned bytesSkipped;   // Number of skipped bytes due to overflow
unsigned char writeEnable; // 0 = Write into the circular buffer is not enabled
                           // 1 = Write to circular buffer is enabled
unsigned char overflow;  // Overflow flag
unsigned char * readStartOfMsg; // Pointer to the start of message

unsigned char * write;      // Write index to the first available location
unsigned char * read;       // Read index
short depth;                // Current number of elements in the buffer
short len;                  // Buffer length
char overflow;              // Overflow status bit
char underflow;             // Underflow status bit
unsigned char * storage;    // Pointer to the storage

unsigned char buff[DBG_BUFFER_SIZE]; // Circular buffer storage
unsigned char hostBuff[DBG_HOST_BUFFER_SIZE]; // Host buffer storage. Host
                                         // reads from here. FW reads from circular
                                         // buffer and writes here
} dbgBuff_t;


"""


########################################################
BUFF_LENGTH_BYTES = 1024
BUFF_LENGTH_SHORTS = BUFF_LENGTH_BYTES/2
MAX_NUM_ARGS_IN_DBG_MSG = (32 - 1) #buffer size (in shorts) - ID
MAX_NUM_ARGS_IN_PRINTF_MSG = (256/2 - 1) #buffer size (in shorts) - ID

formatSpec = {'D01_length':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D02_hostBuffLength':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D03_mode':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D04_bytesSkipped':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D05_writeEnable':{'nBytesPerEle':1, 'nEle':1, 'val':0},
              'D06_overflow':{'nBytesPerEle':1, 'nEle':1, 'val':0},
              'D07_pad1':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D08_readStartOfMsg':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D09_bufferWrite':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D10_bufferRead':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D11_bufferDepth':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D12_bufferLen':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D13_bufferOverflow':{'nBytesPerEle':1, 'nEle':1, 'val':0},
              'D14_bufferUnderflow':{'nBytesPerEle':1, 'nEle':1, 'val':0},
              'D15_pad2':{'nBytesPerEle':2, 'nEle':1, 'val':0},
              'D16_bufferStorage':{'nBytesPerEle':4, 'nEle':1, 'val':0},
              'D17_buff':{'nBytesPerEle':2, 'nEle':BUFF_LENGTH_SHORTS, 'val':[0]*BUFF_LENGTH_SHORTS},
              }

failureCodes = ['NoFailure',
                'FailCoefficientExchange',
                'FailWaitPam2ThpTransition',
                'FailWaitPam16ThpTransition',
                'FailWaitPboExchange',
                'FailWaitPboRequest',
                'FailWaitReceivedEnergy',
                'FailWaitReceiverStatus',
                'FailWaitSlaveTransmit',
                'FailWaitTranCountPbo',
                'FailWaitTranCountCoeffExchange',
                'FailWaitTranCountFineAdjust',
                'FailWaitPboTransition',
                'FailReserved1',
                'FailReserved2',
                'FailReserved3',
                'FailHighLdpc',
                'FailBadDecSaturation',
                'FailBadDecNyquist',
                'FailBadDecDc',
                'FailBlockLockHighBer',
                'FailLinkDrop',
                'FailLdpcEvent',
                'FailMaxBackToBackRfiTraining',
                'FailMaxBackToBackFastRetrain',
                'FailRateTransition',
                'FailReserved5',
                'FailReserved6',
                'FailReserved7',
                'FailReserved8',
                'FailReserved9',
                'FailForced']

mdioEvents = ['handleReset',
              'handleLowPower',
              'handleRenegotiate',
              'handlePacketGeneration',
              'handleAnalogLoopback',
              'handleSgmii1gSystemLoopback',
              'handleSgmii100mSystemLoopback',
              'handlePcsDsqLoopback',
              'handleSgmii1g100mNetworkLoopback',
              'handlePhyXsNetworkLoopback',
              'handleGeneralLoopback',
              'handleTestModes' ,
              'handle1gTestModes' ,
              'handleCableDiagnostics',
              'handleXenpakControl',
              'handleTxDisable',
              'handleExternalLoopback',
              'handleXfiPrbsTest',
              'generateTone',
              'detectTone',
              'wolProxy']

faults = {0x8001:'AQ_EXIT_WRONG_ARCHITECTURE',
          0x8002: 'AQ_EXIT_VCO_INIT_FAILURE',
          0x8003: 'AQ_EXIT_XAUI_INIT_FAILURE',
          0x8004: 'AQ_EXIT_I2C_SUPPLY_FAILURE',
          0x8005: 'AQ_EXIT_PHY1_SINGLE_FAILURE',
          0x8006: 'AQ_EXIT_PART_NOT_EFUSED',
          0x8007: 'AQ_EXIT_TEMPERATURE_SHUTDOWN',
          0x8008: 'AQ_FAULT_SFP_FLASHLOAD_ERROR',
          0x8009: 'AQ_FAULT_SFP_BADSLAVEADDR',
          0x800A: 'AQ_FAULT_TGE_USM_MAILBOX_TIMEOUT',
          0x800B: 'AQ_EXIT_PART_RESTRICTED_OP',
          0xC001: 'AQ_FAULT_ILLEGAL_INSTR',
          0xC002: 'AQ_FAULT_INSTR_ERROR',
          0xC003: 'AQ_FAULT_LOAD_STORE_ERROR',
          0xC004: 'AQ_FAULT_PRIVILEGED',
          0xC005: 'AQ_FAULT_UNALIGNED',
          0xC006: 'AQ_FAULT_PROHIBITED_IFETCH',
          0xC007: 'AQ_FAULT_PROHIBITED_LOAD',
          0xC008: 'AQ_FAULT_PROHIBITED_STORE',
          0xDEAD: 'AQ_FAULT_IRAM_UNCORRECTABLE_PARITY_ERROR',
          0xDEAE: 'AQ_FAULT_DRAM_PARITY_ERROR',
          0xDEAF: 'AQ_FAULT_IRAM_CORRECTABLE_PARITY_ERROR',
          0xDD00: 'AQ_FAULT_IRAM_CRC16_ERROR',
          0x9001: 'AQ_FAULT_PROVISIONING_ERROR',
          0xA001: 'AQ_FAULT_XFI_IF_DLPF_ERROR'}

phyState = ['Idle',
            'AutonegotiationActive',
            'DataActive',
            'Data1GActive',
            'CableDiagsActive',
            'IeeeTestMode',
            'Ieee1GTestMode',
            'LowPowerMode',
            'LoopbackMode',
            'UpdateVoltage',
            'Data100MActive',
            'MacPhyReset',
            'MacPhyClearReset',
            'MacPhyDisable',
            'MacPhyLowPower',
            'Training']
            
sysState = ['HW_INITIALIZATION',
            'SERDES_CALIBRATION',
            'SERDES_ANEG_TRAINING',
            'RATE_ADAPTATION',
            'MDI_COUPLING',
            'ENABLE_MACSEC_TX_AND_RX',
            'TARGET_MODE_ENTERING',
            'DATA_MODE_LINK_MONITORING',
            'PACKET_GENERATION',
            'LOOPBACK_MODE',
            'TESTMODE',
            'IDLE',
            'SYS_INVALID',
            'SYS_WOL_LOW_POWER']

sdAnegTrngState = [ 'INIT', 'DISABLE', 'ENABLE', 'ANEG', 'TRNG', 'DONE' ]

sysAnegStatus = ['N/A', "Incomplete", "Complete"]

sysRateAdaptAnegState = [ 'INIT', 'DISABLE', 'HOST_ENABLE', 'ANEG', 'DONE' ]


""" Auto-Neg Arbiter SMC States """
arbitState = ['XMIT_DISABLE',
              'BREAK_LINK',
              'INITIATE_MDI_MDIX',
              'SET_MDI_MODE',
              'SET_MDIX_MODE',
              'MDI_MDIX_SAMPLE',
              'CHOOSE_MDI_MDIX',
              'ABILITY_DETECT',
              'ABILITY_DETECT_WAIT',
              'ACKNOWLEDGE_DETECT',
              'ACKNOWLEDGE_DETECT_WAIT',
              'COMPLETE_ACKNOWLEDGE_RX',
              'COMPLETE_ACKNOWLEDGE_TX',
              'NEXT_PAGE_WAIT',
              'NEXT_PAGE_WAIT_WAIT',
              'FLP_LINK_GOOD_CHECK',
              'LINK_STATUS_CHECK',
              'LINK_STATUS_CHECK_WAIT',
              'PARALLEL_DETECTION_FAULT',
              'HANDLE_FLP_IDLE']

""" Auto-Neg TX SMC States """
anegTxState = ['TRANSMIT_IDLE',
               'TRANSMIT_IDLE_WAIT',
               'TRANSMIT_REMAINING_ACKNOWLEDGE',
               'TRANSMIT_CODEWORD',
               'TRANSMIT_WAIT',
               'TRANSMIT_COUNT_ACK']

""" Auto-Neg TX SMC States """
anegRxState = ['RECEIVE_INIT',
               'RECEIVE_CHECK_ABILITY',
               'RECEIVE_ABILITY_MATCH',
               'RECEIVE_AM_COMPLETE',
               'RECEIVE_CHECK_NP',
               'RECEIVE_NP_MATCH',
               'RECEIVE_NP_COMPLETE']

anegDbgInfo = ['Invalid Code',
               'Link Pulse Err Intr',
               'Abort Tasks',
               'Intr w/o Source',
               'Detect mask',
               'Arbiter SQ Mask',
               'Arbiter MDI/-X Complete',
               'Arbiter Complete Ack',
               'Arbiter Toggle Bit',
               'Arbiter Toggle Error',
               'Arbiter M/S Res Failed',
               'Arbiter State',
               'Rx into idle state',
               'Tx extra acks',
               'Tx remaining acks',
               'Tx ack complete',
               'Rx page',
               'Rx bogus page',
               'Rx init',
               'Rx restart ack cnt',
               'Rx restart pg match',
               'Rx ACK count',
               'Rx state info',
               'Rx page mismatch',
               'Rx next codeword',
               'Main Return Status',
               'Arb Utils codeword',
               'Arb Utils next page',
               'OUI Build AQ Page',
               'AQRate: Ratecode',
               'AQRate: Set local Ability',
               'AQRate: local Ability Status',
               'AQRate: Local Advertised Ability',
               'AQRate: Local AQRate Enabled',
               'AQRate: local Ability After D/Shift',
               'AQRate: LKP Status',
               'AQRate: Match',
               'AQRate: Process Codeword',
               'AQRate: Build Codeword', 
               'AQRate Downshift Avbl Rates',
               'AQRate Downshift index',
               'AQRate Downshift Next Rate',
               'Aneg Flags Arb@Ack TX',
               ]

anegConnectionStates = [
                'Inactive',
                'Cable Diag',
                'Autonegotiation',
                'Training',
                'Connected',
                'Fail',
                'Test Mode',
                'Loopback Mode',
                'Low Power Mode',
                'Connected Wake-On-LAN Mode'
                'System Calibrating',
                'Cable Disconnected',
                'Reserved',
                'Reserved',
                'Reserved',
                'Invalid'
               ]

anegRates = [
             '10M',
             '100M',
             '1G',
             '10G',
             '2.5G',
             '5G',
             "Invalid"
            ]


linkStatus = ['No Link', '100M Link Connected', '1G Link Connected', '10G Link Connected', '2.5G Link Connected', '5G Link Connected']

LnktrainingType = ['Regular Training ', 'FastRetrain Aquantia', 'RFI ', 'Test Mode 3 Training', 'Loopback Training', 'AqTraining', 'CncTraining', 'FastRetrain Cisco', 'FastRetrain Ieee']

trainingType = ['No Link', 'No Link',
                '100M Training', '100M Training',
                '1G Slave Training', '1G Master Training',
                '10G Slave Training', '10G Master Training',
                '2.5G Slave Training', '2.5G Master Training',
                '5G Slave Training', '5G Master Training']


""" Different types of message types """
txPageType = ['OuiMessage',
              'PHY_ID_Message',
              'RemoteFault',
              'UserProvidedAutoneg',
              '_1000BaseT_Technology',
              '_10GBaseT_Message',
              'EeeMessage',
              'NullMessage']


autoNegFlags = [
                   'FLP_LINK_GOOD',
                   'FLP_LINK_FAILURE',
                   'MDI_MDIX_COMPLETE',
                   'MDIO_ABORT',
                   'LP_100M_CAPABLE',
                   'ABILITY_MATCH',
                   'ACK_FINISHED',
                   'ACKNOWLEDGE_MATCH',
                   'ACKNOWLEDGE_RCVD',
                   'BASE_PAGE',
                   'COMPLETE_ACK',
                   'CONSISTENCY_MATCH',
                   'DESIRE_NP',
                   'EXCHANGE_ENPS',
                   'EXCHANGE_NPS',
                   'LP_ACK2',
                   'MR_ENP_ABLE',
                   'MR_LP_AUTONEG_ABLE',
                   'MR_LP_ENP_ABLE',
                   'MR_LP_NP_ABLE',
                   'MR_NP_ABLE',
                   'MR_PARALLEL_DETECTION_FAULT',
                   'NP_RX',
                   'NP_TX',
                   'TOGGLE_RX',
                   'TOGGLE_TX',
                   'TRANSMIT_ABILITY',
                   'TRANSMIT_ACK',
                   'TRANSMIT_ACK2',
                   'UPDATE_TEMPERATURE',
                   'TYPE_8_ABILTIIES_PAGE',
                   'TYPE_9_ABILTIIES_PAGE',
                ]


anegExitStatus = [
    'AN_Link_Is_Good',
    'AN_Renegotiate',
    'AN_Transition_To_Idle',
    'AN_Transition_To_Loopback',
    'AN_Transition_To_Test',
    'AN_Transition_To_GigE_Test',
    'AN_Transition_To_Xmit_Disable',
    'AN_Transition_To_Cable_Diags',
    'AN_Master_Slave_Fault',
    'AN_No_Link_Partner',
    'AN_Parallel_Detection_Fault',
    'AN_Resolution_Failure',
    'AN_Schedule_Overrun',
    'AN_Unsupported_Rate',
    'AN_Disabled']

""" USX Message Types """
UsxMsgType = [
                'Aneg: Started',
                'Aneg: Done',
                'Aneg: Pending',
             ]

""" SIF State Machine Messages """
SysSmcMsgType = [
                'INVALID',
                'POWERUP',
            
                'MDIO_GENERAL_LOOPBACK',
                'MDIO_PACKET_GENERATION',
                'MDIO_TEST_MODE',
                'MDIO_LOW_POWER',
                'MDIO_RESET',
                'MDIO_WOL_PROXY_MODE',
                
                'LINE_TO_SYSTEM_AUTONEG_STARTED',
                'LINE_TO_SYSTEM_10G_CONNECTED',
                'LINE_TO_SYSTEM_5G_CONNECTED',
                'LINE_TO_SYSTEM_2G5_CONNECTED',
                'LINE_TO_SYSTEM_1G_CONNECTED',
                'LINE_TO_SYSTEM_100M_CONNECTED',
            
                'LINE_TO_SYSTEM_LINK_DOWN',
            ]

""" SIF USX Aneg State Machine States """
UsxAnegHwSmcStates = [  'AN_ENABLE',    
                        'AN_RESTART',
                        'AN_DISABLE_LINK_OK',
                        'AN_ABILITY_DETECT',
                        'AN_ACK_DETECT',
                        'AN_COMPLETE_ACK',
                        'AN_IDLE_DETECT',
                        'AN_LINK_OK'
                     ]

SdSmcStates = ["Silence", "LaneReady", "SigDetect", "RxCal", "Monitor" ]

xgsClockModes =  [ "DISABLE" , "10G" , "SGMII-1G", "SGMII-100M", "XFI-1G", "XFI-100M", "OCSGMII" ]

""" SIF USX Aneg Rx Unidata Indication """
UsxAnegRudi = [ 'None', 'Invalid', 'Idle', 'Config' ]


""" SYS Modes """
sysModes = ['SGMII_100M',
            'SGMII_1G',
            'XFI0',
            'XAUI',
            'AQRATE_XAUI',
            'RXAUI',
            'AQRATE_RXAUI',
            'XFI1',
            'AQRATE_XFI1',
            'USX',
            'XFI_LOOKASIDE',
            'MAC',
            'LOWPOWER',
            'OCSGMII',
            'INVALID'
            ]
    
""" SYS Modes """
sdModes = ['XFI', 'XAUI', 'RXAUI', 'SGMII', 'OCSGMII', 'LOW_POWER']

""" Rate adaptation schemes """
rateAdaptationModes = ['NO_RATE_ADAPTATION', 'USX_RATE_ADAPTATION', 'PAUSE_RATE_ADAPTATION']


""" SYS Modes """
sifOpModes = [
            'KR',
            'KX',
            'XFI',
            'USXGMII',
            'XAUI',
            'XAUI_PAUSE_BASED',
            'SGMII',
            'RXAUI',
            'MAC',
            'ALL_OFF',
            'UNKNOWN'
            ]

""" SYS init Reset type """
SysInitResetType = [ "Reset", "Normal"]

""" SD Reset type """
SdResetType = [ "Reset", "Normal"]


""" XSGMII Aneg Rate """
xsgmiiAnegRates = [
                     'Ability',
                     '100M',
                     '1G',
                     'Ability',
                     'Ability',
                     'Ability',
                     "Ability"
                 ]

""" SYS Loopbacks """
sysLoopbacks = [
                'None',
                'System Interface - System Loopback',
                'System Interface - System Loopback with Passthrough',
                'System Interface - Network Loopback',
                'System Interface - Network Loopback with Passthrough',        
                'System Interface - Network Loopback with Passthrough and Merge',
                'System Interface - Peer-to-peer loopback',
                'Unknown',
                'Unknown',
                'Network Interface - System Loopback',
                'Network Interface - System Loopback with Passthrough',
                'Network Interface - Network Loopback',
                'Network Interface - Network Loopback with Passthrough',
                'Network Interface - Peer-to-peer loopback',
                'Unknown', 'Unknown',
                'Cross-connect System Loopback',
                'Cross-connect Network Loopback',
                'Unknown', 'Unknown', 'Unknown', 'Unknown',
                'Unknown', 'Unknown', 'Unknown', 'Unknown', 'Unknown',
                'Unknown', 'Unknown', 'Unknown', 'Unknown', 'Unknown',
               ]
               
""" SYS test modes """
systemInterfaceTestModes = ["NONE", "XFI-PRBS"]     


eSIF_PACKET_GEN_SYSTEM    = 1  # packet generation towards system side
eSIF_PACKET_GEN_LOOKASIDE = 2  # packet generation towards look aside
eSIF_PACKET_GEN_MDI       = 4  # packet generation towards line side
eSIF_PACKET_GEN_OFF       = 0  # packet generation not going any side and need to turn off
          

""" XGS modes for XgsModeSet() """
xgsModes = ["XAUI", "MAC", "XFI1", "XFI2", "SPLIT_XFI1", "SPLIT_XFI2"] 

xgsXfi1Port = ["Idle", "XFI0", "XAUI", "MDI", "MAC", "SEC-SIF", "SEC-NET", "DISABLED", "OFF" ]
xgsXauiPort = ["Idle", "XFI0", "XFI1", "MDI", "MAC", "SEC-SIF", "SEC-NET", "DISABLED", "OFF" ]
xgsMdi1Port = ["Idle", "XFI0", "XFI1", "XAUI", "MAC", "MDI", "SEC-SIF", "SEC-NET", "OFF"]

""" KR Training """
krTrainingSmcStates =   ["INITIALIZE",
                        "SEND_TRAINING",
                        "TRAIN_LOCAL",
                        "TRAIN_REMOTE",
                        "LINK_READY",
                        "SEND_DATA",
                        "TRAINING_FAILURE"]
krRemoteCoeffStatus = ["NOT_UPDATED",
                       "UPDATED",
                       "MINIMUM",
                       "MAXIMUM"]
krRemoteCoeffUpdateState = ["NOT_UPDATED",
                            "UPDATE_COEFF",
                            "MAXIMUM",
                            "UPDATED",
                            "MINIMUM",
                            "PRESET",
                            "INITIALIZE"]
krLocalCoeffUpdateState = ["SEND_INITIALIZE",
                            "DEC_MAIN_INC_PRE",
                            "INC_MAIN_DEC_PRE",
                            "DEC_MAIN_INC_POST",
                            "INC_MAIN_DEC_POST",
                            "WAIT_PRESET_CONFIRM",
                            "RX_CAL_1",
                            "WAIT_CONFIRM",
                            "RX_CAL_2",
                            "WAIT_REMOTE_READY",
                            "DONE"]
krLocalPhase    = [     "LocalInit", 
                        "SendInit",
                        "InitHold",  
                        #"TxSwing",
                        "LocalRx", 
                        "LocalRxFom",
                        "LocalTx",
                        "LocalTxPreTap",    
                        "LocalTxPreTapHold",
                        "LocalTxMainTap",
                        "LocalTxMainTapHold",
                        "LocalTxCheck",
                        "Phase-Done"]

krCoeffStatus = ["!UPD", "UPD ", "MIN ", "MAX "]
krCoeffUpdate = ["HOLD", "INCR", "DECR", "RESV"]

krSmcState = [  "IDLE",
                "INIT",
                "TRAINING_INIT",
                "SIG_DETECT_1",
                "RX_CAL_1",
                "PMD_INIT",
                "PMD_TRAINING",
                "SIG_DETECT_2",
                "RX_CAL_2",
                "RX_EYE_WIDTH",
                "RX_EYE_HEIGHT",
                "MONITOR_LINK",
                "FAIL"]
    
krFrameLockState = [
                "OUT_OF_FRAME",
                "RESET_COUNT",
                "GET_NEW_MARKER",
                "TEST_MARKER",
                "VALID_MARKER",
                "INVALID_MARKER",
                "IN_FRAME",
                "SLIP",
              ]

krAnSmcState = [
                    "TRANSMIT_DISABLE",
                    "ABILITY_DETECT",
                    "ACK_DETECT",
                    "COMPLETE_ACK",
                    "NEXT_PAGE_WAIT",
                    "GOOD_CHECK",
                    "DONE"
                ]


krTap = ["PRE ", "MAIN", "POST", "INVALID"]

krAnPageType = ["Invalid", "BASE", "NEXT" , "UNF"]

constellation = [
    "NULL",
    "PAM16",
    "DSQ128",
    "RESERVED",
    "SQ64",
    "1000BASE_T",
    "100BASE_TX",
    "DSQ32",
    "DSQ8",
    "SQ256",
    "SQ16",
    "PAM4"]   


#--------------------------------------------------------------------
def dbgPrint(level, *args) :
    
    logStr = ""
    for i in args :
        logStr += str(i)
    if (level <= gDebugVerbosityLevel) :
        print logStr
        sys.stdout.flush()

#--------------------------------------------------------------------
""" Aneg Flags """
def anegFlagsDecode(msw, lsw):
    flags = ((msw & 0x0000ffff) << 16) | (lsw & 0x0000ffff)
    msg = hex(flags) + "\n"
    j = 0
    for i in range(len(autoNegFlags)):
        if flags & (1 << i):
            msg += autoNegFlags[i] + ", "
            j += 1
            if (j % 4) == 0:
                msg += "\n"
    return msg

""" Base Page decoding """
def decipherBasePage(page):
    msg = "Base:"
    if(page & 0x8000):
        msg += "NP"
    if(page & 0x4000):
        msg += ",Ack"
    if(page & 0x2000):
        msg += ",RF"
    if(page & 0x1000):
        msg += ",ENP"
    if(page & 0x0020):
        msg += ",10B-T"
    if(page & 0x0040):
        msg += ",10B-T FD"
    if(page & 0x0080):
        msg += ",100B-TX"
    if(page & 0x0100):
        msg += ",100B-TX FD"
    if(page & 0x0200):
        msg += ",100B-T4"
    if(page & 0x0400):
        msg += ",PAUSE"
    if(page & 0x0800):
        msg += ",Async PAUSE"
    if((page & 0x001f) == 0x01):
        msg += ",802.3"
    return msg

""" Next Page Message Code Field """
def decipherNextPageMessageCodeField(word0, word1, word2):
    msg = "\n\t  ->"
    msgCode = word0 & 0x07ff
    if(msgCode == 1):
        msg += "Null Msg"
    elif((msgCode == 2) or (msgCode == 3)):
        msg += "Extension Msg"
    elif(msgCode == 4):
        msg += "Remote Fault Msg"
    elif(msgCode == 5):
        msg += "OUI Msg: "
        if(((word2 & 0x7ff) << 2) == (0x17B6 & 0xfffc)):
            msg += "AQ"
        elif(((word2 & 0x7ff) << 2) == (0x0428 & 0xfffc)):
            msg += "Cisco"
        else:
            msg += "Unknown Vendor"
    elif(msgCode == 6):
        msg += "PHY ID Msg"
    elif(msgCode == 7):
        msg += "100BASE-T2 Msg"
    elif(msgCode == 8):
        msg += "1000BASE-T Msg"
    elif(msgCode == 9):
        msg += "10GBASE-T Msg: "
        page32 = ((word2 << 16) | word1) 
        if(page32 & 0x80000000):
            msg += "AQRate Downshift,"
        if(page32 & 0x40000000):
            msg += "5G,"
        if(page32 & 0x20000000):
            msg += "2.5G,"
        if(page32 & 0x01000000):
            msg += "10G EEE,"
        if(page32 & 0x00800000):
            msg += "1000 EEE,"
        if(page32 & 0x00400000):
            msg += "100 EEE,"
        if(page32 & 0x00100000):
            msg += "PMA reset,"
        if(page32 & 0x00080000):
            msg += "Fast Retrain,"
        if(page32 & 0x00040000):
            msg += "Short Reach,"
        if(page32 & 0x00020000):
            msg += "Loop Timing,"
        if(page32 & 0x00010000):
            msg += "10GBASE-T,"
        if(page32 & 0x00008000):
            msg += "1000BASE-T,"
        if(page32 & 0x00004000):
            msg += "100BASE-T,"
        if(page32 & 0x00002000):
            msg += "Multiport,"
        if(page32 & 0x00001000):
            msg += "Master,"
        if(page32 & 0x00000800):
            msg += "MS manual,"
        msg += "Seed 0x%3x" % (page32 & 0x7ff)
    else: # 0 or >= 10
        msg += "OUI rem words or Reserved Msg Code"
    return msg
    
    
""" Next Page Decoding """
def decipherNextPage(word0, word1, word2):
    msg = "->"
    if(word0 & 0x8000):
        msg += "NP"
    else:
        msg += "Last Page"
    if(word0 & 0x4000):
        msg += ",Ack"
    if(word0 & 0x2000):
        msg += ",MP"
    else:
        msg += ",Unformatted"
    if(word0 & 0x1000):
        msg += ",Ack2"
    if(word0 & 0x08000):
        msg += ",Toggle"
    msg += decipherNextPageMessageCodeField(word0, word1, word2)
    return msg


""" Auto-neg Page (Codeword decoding) """
def anegDecipherPage(tx_not_rx, size, word0, word1, word2):
    msg = "\t"
    if(size <= 16):
        msg += decipherBasePage(word0)
    else:
        msg += decipherNextPage(word0, word1, word2)
    return msg


""" AQRate bit decoding """
def decipherAQRateBits(word):
    msg = " "
    if(word & 0x0001):
        msg += "10G"
    else:
        msg += "!10G"
    if(word & 0x8000):
        msg += ",AQRate Downshift"
    else:
        msg += ",!AQRate Downshift"
    if(word & 0x4000):
        msg += ",5G"
    else:
        msg += ",!5G"
    if(word & 0x2000):
        msg += ",2.5G"
    else:
        msg += ",!2.5G"
    return msg

""" Auto-neg Tx/Rx Page Header and Page Decoding """
def anegPage(arg0, arg1, arg2, arg3):
    msg = ""
    if(arg0 & 0x8000):
        tx_not_rx = 1
    else:
        tx_not_rx = 0
    if(tx_not_rx):    
        msg += "Tx"
    else:
        msg += "Rx"
    msg += " #%03d" % ((arg0 & 0x7f00) >> 8)
    msg += " Ch:" + str((arg0 & 0x00f0) >> 4)
    if(arg0 & 0xF):
        size = 48
    else:
        size = 16
    msg += " Bits:%d " % size
    if(size >= 16):
        msg += "%04x" % (arg1)
    if(size == 48):
        msg += " %04x %04x" % (arg2, arg3) 
    msg += "\n"
    msg += anegDecipherPage(tx_not_rx, size, arg1, arg2, arg3)
    return msg


""" Auto-neg Debug Message Formatting (with 3 args) """
def formatAnegInfoMsg_3(type, arg1, arg2, arg3):
    msgType = anegDbgInfo[type]
    msgData = ''
    if(type   == 0): # 'Invalid')
        msgData = hex(arg3) + ":" + hex(arg3) + ":" + hex(arg3)
    elif(type == 1): # 'Link Pulse Err Intr')
        msgData = '';
    elif(type == 2): # 'Abort Tasks')
        msgData = '';
    elif(type == 3): # 'Intr w/o Source')
        msgData = "States:" + hex(arg1)
    elif(type == 4): # 'Detect mask')
        msgData = "Interrupt Pulse Detect. Sq Mask:" + hex(arg1 & 0xf)
        msgData += " Current Channels: Tx=%d" % ((arg1 & 0xff00) >> 8)  
        msgData += " Rx=%d" % ((arg1 & 0x00f0) >> 4)
    elif(type == 5): # 'Arb SQ Mask')
        msgData = "Pulse Check; Sq Mask:" + hex((arg1 & 0xff00) >> 8) + " MDI/MDI-X mask:" + hex(arg1 & 0xff)
    elif(type == 6): # 'Arb MDI/-X Complete')
        msgData = "Determined MDI/MDI-X: Tx:" + hex((arg1 & 0xff00) >> 8) + " Rx:" + hex(arg1 & 0xff)
    elif(type == 7): # 'Arb Complete Ack')
        msgData = "Arbit task wants to exchange "
        if(arg1 == 0):
            msgData += "NPs"
        else:
            msgData += "ENPs"
        msgData += " based Rx page:" + hex(arg2) 
    elif(type == 8): # 'Arb Toggle Bit')
        msgData = "Compute toggle: " + str(arg1 & 0x1) +  " for Page:" + hex(arg2)
    elif(type == 9): # 'Arb Toggle Error')
        msgData = "State confusion on code word:" + hex(arg1)
    elif(type == 10): # 'Arb M/S Res Failed')
        msgData = "Arbiter Resolution Failure; first time (matching seeds?):" + hex(arg1)
    elif(type == 11): # 'Arb State')
        msgData = ":" + arbitState[arg2] + " for " + str(arg1) + " ticks"
    elif(type == 12): # 'Rx into idle state')
        msgData = "Tx detects FLP idle:"
        msgData += " Arb:" + arbitState[((arg1  & 0xff00) >> 8)]
        msgData += " TX:"  + anegTxState[((arg1  & 0x00f0) >> 4)]
        msgData += " RX:"  + anegRxState[(arg1  & 0xf)]
    elif(type == 13): # 'Tx extra acks')
        msgData =  hex(arg1)
    elif(type == 14): # 'Tx remaining acks')
        msgData = "Tx ACK count = " + str(arg1 & 0xf) + " at " + str((arg1 & 0xfff0) >> 4)
    elif(type == 15): # 'Tx ack complete')
        msgData = "Tx activates Arbit."
        msgData += " Tx:" + anegTxState[((arg1 & 0xff00) >> 8)]
        msgData += " Rx:" + arbitState[(arg1 & 0x00ff)]
    elif(type == 16): # 'Rx page')
        msgData = " State" + anegRxState[(arg1 & 0xf)] + " "
        msgData += str((arg1 & 0xfff0) >> 4) + " msec"
    elif(type == 17): # 'Rx bogus page')
        msgData = "RUNT in Rx state:" + anegRxState[(arg1 & 0xf)]
        msgData += " ACK cnt#" + str((arg1 & 0xfff0) >> 4)
    elif(type == 18): # 'Rx init')
        msgData = "Rx ACK count" + str(arg1 & 0xf) + " at " + str((arg1 & 0xfff0) >> 4)
    elif(type == 19): # 'Rx restart ack cnt')
        msgData = "Reset Rx ACK count:" + str((arg1 & 0xfff0) >> 4)
        msgData += " in State:" + anegRxState[(arg1 & 0xf)]
    elif(type == 20): # 'Rx restart pg match')
        msgData = "New Rx Code Word:" + hex(arg1) + " Word:" + hex(arg2)
    elif(type == 21): # 'Rx ACK count')
        msgData = "Rx State: " + anegRxState[(arg1 & 0xf)]
        msgData += " ACK count " + str(arg2 & 0xf) + " at " + str((arg2 & 0xfff0) >> 4)
    elif(type == 22): # 'Rx state info')
        msgData = "Rx activates Arbit Rx:" + anegRxState[((arg1 & 0x0f00) >> 8)]
        msgData = " Arb:" +  arbitState[(arg1 & 0xff)]
    elif(type == 23): # 'Rx page mismatch')
        msgData = "New Rx Code Word:" + hex(arg2) + " Ack Cnt:" + hex(arg2)
    elif(type == 24): # 'Rx next codeword')
        msgData = "New Rx Code Word:" + hex(arg2) + " Ack Cnt:" + hex(arg2)
    elif(type == 25): # 'Main Return Status')
        msgData = hex(arg1)
    elif(type == 26): # 'Arb Utils codeword')
        msgData = "Process page:"
        if(arg1 == 0):
            msgData += "Base"
        elif(arg1 == 1):
            msgData += "Message"
        elif(arg1 == 2):
            msgData += "Unformatted"
        else:
            msgData += "Invalid"
        msgData += ":" + hex(arg2)        
    elif(type == 27): # 'Arb Utils next page')
        pgType = txPageType[((arg2 & 0xff00) >> 8)]
        unfPgCount = hex((arg2 & 0x00f0) >> 4)
        currPgId = hex(arg2 & 0x000f)
        msgData = ""
        if(arg1 == 0):
            msgData += "Load Next Page Type:"
        elif(arg1 == 1):
            msgData += "Next Page To Load:"
        else:
            msgData += "Invalid page:"
        msgData += pgType + " Unf Count#" + unfPgCount + " Next ID:" + currPgId
        msgData += " Next Type:" + txPageType[arg3]
    elif(type == 28): # 'OUI Build AQ Page'
        msgData = hex(arg1) + ":" + hex(arg2) + ":" + hex(arg3) 
    elif(type == 29): # 'AQRate: Ratecode',
        msgData = ""
        if(arg2 == 5):
            msgData = "5G,"
        elif(arg2 == 4):
            msgData = "2.5G,"
        else:
            if(arg1 == 1):
                msgData += "100BASE-TX"
            elif(arg1 == 2):
                msgData += "1000BASE-T"
            elif(arg1 == 3):
                msgData += "1GBASE-T"
            else:
                msgData += "Invalid"
        msgData += " " + hex(arg1) + ":" + hex(arg2) 
    elif(type == 30): # 'AQRate: Set local Ability',
        msgData = decipherAQRateBits(arg2)
        msgData += " W1:" + hex(arg2) + " 0:" + hex(arg1)
    elif(type == 31): # 'AQRate: local Ability Status',
        msgData = "Tech Ability:" + decipherAQRateBits(arg1)
        msgData += " W1:" + hex(arg1) + " Status:" + hex(arg2)
    elif(type == 32): # 'AQRate: Local Advertised Ability',
        msgData = decipherAQRateBits(arg2)
        msgData += " W1:" + hex(arg2) + " 0:" + hex(arg1) 
    elif(type == 33): # 'AQRate: Local AQRate Enabled',
        msgData = "Enabled"
        if(arg1 == 5):
            msgData += ",5G"
        if(arg1 == 2):
            msgData += ",2.5G"
    elif(type == 34): # 'AQRate: local Ability After D/Shift',
        msgData = decipherAQRateBits(arg2)
        msgData += " W1:" + hex(arg2) + " 0:" + hex(arg1) 
    elif(type == 35): # 'AQRate: LKP Status',
        msgData = ""
        if(arg1 & 0x1000):
            msgData += "AQRate Downshift"
        else:
            msgData += "!AQRate Downshift"
        if(arg1 & 0x0800):
            msgData += ",5G"
        else:
            msgData += ",!5G"
        if(arg1 & 0x0400):
            msgData += ",2.5G"
        else:
            msgData += ",!2.5G"
        msgData += " W1:" + hex(arg1) 
    elif(type == 36): # 'AQRate: Match',
        if(arg1 == 5):
            msgData += "5G"
        if(arg1 == 2):
            msgData += "2.5G"
    elif(type == 37): # 'AQRate: Process Codeword',
        msgData = "LKP:" + decipherAQRateBits(arg2)
        msgData += " W1:" + hex(arg2) + " 0:" + hex(arg1) 
    elif(type == 38): # 'AQRate: Build Codeword', 
        msgData = decipherAQRateBits(arg2)
        msgData += " W1:" + hex(arg2) + " 2:" + hex(arg1)
    elif(type == 39): # 'AQRate Downshift Avbl Rates'
        msgData = "#" + str(arg1) + " Attempts:" + str(arg2 & 0xf)
        msgData += " Total Attempts:" + str(arg3)
    elif(type == 40): # 'AQRate Downshift index'
        msgData = str(arg1) + " Avbl Rates#" + str(arg2) 
        msgData += 'Attempts:' + str(arg3)
    elif(type == 41): # 'AQRate Downshift Next Rate'
        msgData = str(arg1) + " index:" + str(arg2) 
    elif(type == 42): # 'Aneg Flags Arb@Ack TX'
        msgData = anegFlagsDecode(arg1, arg2)
    else:
        msgData = hex(arg1) + ":" + hex(arg2) + ":" + hex(arg3)
    return msgType + ":" + msgData

""" Auto-neg Debug Message Formatting (with 2 args) """
def formatAnegInfoMsg_2(type, arg1, arg2):
    return formatAnegInfoMsg_3(type, arg1, arg2, 0)

""" Auto-neg Debug Message Formatting (with 1 arg) """
def formatAnegInfoMsg(type, arg):
    return formatAnegInfoMsg_3(type, arg, 0, 0)

def dbgConvertBitStateToStr(aVal, aBitMask, aStrBitIsSet, aStrBitIsNotSet = None ):

    #print "dbgConvertBitStateToStr: In"
    if (aStrBitIsNotSet == None):
        aStrBitIsNotSet = "!" + aStrBitIsSet
    else:
        aStrBitIsNotSet = " " + aStrBitIsSet
    #print "dbgConvertBitStateToStr: aStrBitIsNotSet=%s" % aStrBitIsNotSet

    vReturnStr = ""
    vState=(aVal & aBitMask)
    if (vState):
        vReturnStr += " " + aStrBitIsSet
    else:
        vReturnStr += aStrBitIsNotSet
    #print "dbgConvertBitStateToStr: Almost out "

    #print "dbgConvertBitStateToStr: Out vReturnStr=%s" % vReturnStr
    return vReturnStr

anegBreakLinkTimestamp = 0
currentPhyControl = None
def formatAutonegMsg(arg0, arg1, arg2):
    global anegBreakLinkTimestamp
    global currentPhyControl
    currentTimeStamp = getTime(arg0,  arg1)
    if arbitState[arg2] == 'BREAK_LINK':
        anegBreakLinkTimestamp = currentTimeStamp
    msg = "%s:%d ms\n%sAutoneg Arbiter State = %s" % \
         (formatTimeStamp(currentTimeStamp),
         (currentTimeStamp - anegBreakLinkTimestamp),
         formatMsgIndent(), arbitState[arg2])
          
    if arbitState[arg2] == 'FLP_LINK_GOOD_CHECK':
        
        resVenStat = currentPhyControl.pifReadData(0x07C810)
        venStat    = currentPhyControl.pifReadData(0x07C800)
        
        connState = anegConnectionStates[((resVenStat & 0x3e00) >> 9)]
        rate = anegRates[((venStat & 0x000e) >> 1)]
        if resVenStat & 0x0100:
            mdiMdix = 'MDI-X'
        else:
            mdiMdix = 'MDI'
        
        #--------------------------------
        msg += "\n%sConnection State: %s, Rate:%s, %s" % \
                (formatMsgIndent(), connState, rate, mdiMdix)
                 
        #--------------------------------
        fwEfuseAqRate = currentPhyControl.pifReadData(0x0A00B6)
        
        engineeringFwID = currentPhyControl.pifReadData(0x0A0006)
        
        aneg10GCtrl  = currentPhyControl.pifReadData(0x070020)
        anegVenProv1 = currentPhyControl.pifReadData(0x07C400)
        rfiCtrl1     = currentPhyControl.pifReadData(0x0A0010)
        trngCtrl1    = currentPhyControl.pifReadData(0x0A0019)
        anegAdvertisement = currentPhyControl.pifReadData(0x070010)
        anegEeeAdvertisement = currentPhyControl.pifReadData(0x07003C)
        #anegEeeAdvertisement2 = currentPhyControl.pifReadData(0x07003E)
        #aneg10GBaseTControl2 = currentPhyControl.pifReadData(0x070040)
        pmaReceiveReservedVendorProvisioning0     = currentPhyControl.pifReadData(0x1E400)
        globalReservedProvisioning2     = currentPhyControl.pifReadData(0x1EC472)
        globalReservedProvisioning5     = currentPhyControl.pifReadData(0x1EC475)
        fwEfuseReplicaAquantiaPartID = currentPhyControl.pifReadData(0x0A00CE)
        fwEfuseReplicaAquantiaPartRevision = currentPhyControl.pifReadData(0x0A00CF)

        #--------------------------------
        msg += "\n%sLocal Info:" % formatMsgIndent()

        #--------------------------------
        msg += "\n%s    [DUT] Chip 0x%04x" % (formatMsgIndent(), fwEfuseReplicaAquantiaPartID)
        
        if ( ( fwEfuseReplicaAquantiaPartRevision & 0xF00) == 0): 
            revType = (fwEfuseReplicaAquantiaPartRevision << 4)
        else:
            revType = fwEfuseReplicaAquantiaPartRevision

        msg += " rev 0x%04x" % (revType & 0xFF0)

        #--------------------------------
        msg += "\n%s    [DUT] FW: %02x.%02x" % (formatMsgIndent(),
                                     ((engineeringFwID >> 8) & 0xff), 
                                     (engineeringFwID & 0xff))
        
        #--------------------------------
        msg += "\n%s    [DUT] Rates:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(aneg10GCtrl,0x1000,"10G")
        msg += "," + dbgConvertBitStateToStr(aneg10GCtrl,0x0100,"5G")
        msg += "," + dbgConvertBitStateToStr(aneg10GCtrl,0x0080,"2.5G")
        msg += "," + dbgConvertBitStateToStr(anegVenProv1,0x0800,"AQ_5G")
        msg += "," + dbgConvertBitStateToStr(anegVenProv1,0x0400,"AQ_2.5G")
        msg += "," + dbgConvertBitStateToStr(anegVenProv1,0x8000,"1G-FD")
        msg += "," + dbgConvertBitStateToStr(anegVenProv1,0x4000,"1G-HD")
        msg += "," + dbgConvertBitStateToStr(anegAdvertisement,0x0100,"100M-FD")
        msg += "," + dbgConvertBitStateToStr(anegAdvertisement,0x0080,"100M-HD")
        msg += "," + dbgConvertBitStateToStr(anegAdvertisement,0x0040,"10M-FD")
        msg += "," + dbgConvertBitStateToStr(anegAdvertisement,0x0020,"10M-HD")

        #--------------------------------
        msg += "\n%s    [DUT] AqRate:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(fwEfuseAqRate,0x4000,"10G")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x2000,"5G")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0xf000,"2.5G")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x1000,"5G_2p")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x0800,"2.5G_2p")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x0400,"1G_2p")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x0200,"2.5G_1p")
        msg += "," + dbgConvertBitStateToStr(fwEfuseAqRate,0x0100,"1G_1p")
        
        #--------------------------------
        msg += "\n%s    [DUT] Abilities:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(anegVenProv1,0x2000,"Short-Reach")
        msg += "," + dbgConvertBitStateToStr(anegVenProv1,0x1000,"AQRate Downshift")
        msg += "," + dbgConvertBitStateToStr(trngCtrl1,0x0001,"THP_24Tap")

        #--------------------------------
        msg += "\n%s    [DUT] EEE:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(anegEeeAdvertisement,0x0008,"10G-EEE")
        #Traced in post-training formatAnegInfo_PostTraining()
        #msg += "," + dbgConvertBitStateToStr(anegEeeAdvertisement2,0x0002,"5G-EEE")
        #msg += "," + dbgConvertBitStateToStr(anegEeeAdvertisement2,0x0001,"2.5G-EEE")
        msg += "," + dbgConvertBitStateToStr(anegEeeAdvertisement,0x0004,"1G-EEE")
        msg += "," + dbgConvertBitStateToStr(anegEeeAdvertisement,0x0002,"100M-EEE")
        
        #--------------------------------
        msg += "\n%s    [DUT] IEEE FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(aneg10GCtrl,0x0002,"10G-FR")
        #Traced in post-training formatAnegInfo_PostTraining()
        #msg += "," + dbgConvertBitStateToStr(aneg10GCtrl,0x0040,"5G-FR")
        #msg += "," + dbgConvertBitStateToStr(aneg10GCtrl,0x0020,"2.5G-FR")

        #--------------------------------
        #Traced in post-training formatAnegInfo_PostTraining()
        #msg += "\n%s  Capabilities THP bypass:" % formatMsgIndent()
        #msg += " " + dbgConvertBitStateToStr(aneg10GBaseTControl2,0x0004,"5G-THP-Bypass")
        #msg += "," + dbgConvertBitStateToStr(aneg10GBaseTControl2,0x0008,"2.5G-THP-Bypass")

        #--------------------------------
        msg += "\n%s    [DUT] Aq-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(pmaReceiveReservedVendorProvisioning0,0x0004,"Enable")

        #--------------------------------
        msg += "\n%s    [DUT] Cisco-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0010,"Enable")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0020,"THP")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0040,"ExtendedMaxWait")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0080,"DisableTimer")

        #--------------------------------
        msg += "\n%s    [DUT] CNC-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(rfiCtrl1,0x0800,"Enable")

        #--------------------------------
        msg += "\n%s    [DUT] RFI-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(globalReservedProvisioning2,0x0001,"Enable")
        msg += "," + dbgConvertBitStateToStr(rfiCtrl1,0x0004,"Support")
        msg += "," + dbgConvertBitStateToStr(rfiCtrl1,0x0008,"ExtendedMaxWait")

        #--------------------------------
        msg += "\n%s    [DUT] M/S:" % formatMsgIndent()
        if aneg10GCtrl & 0x8000:
            msg += " " + dbgConvertBitStateToStr(aneg10GCtrl,0x4000,"Master","Slave")
        else:
            msg += " " + "Auto"

        #--------------------------------
        anegLkpStat1  = currentPhyControl.pifReadData(0x07E820)
        anegLkpStat3  = currentPhyControl.pifReadData(0x07E822)
        anegLkpStat4  = currentPhyControl.pifReadData(0x07E823)
        aneg10GStatus = currentPhyControl.pifReadData(0x070021)
        anegLkpAdvertisement = currentPhyControl.pifReadData(0x070013)
        anegEeeLinkParnerAbility = currentPhyControl.pifReadData(0x07003D)
        #anegEeeLinkParnerAbility2 = currentPhyControl.pifReadData(0x07003F)
        #aneg10GBaseTStatus2 = currentPhyControl.pifReadData(0x070041)
        autonegotiationReceiveReservedVendorStatus2 = currentPhyControl.pifReadData(0x07E832)

        #--------------------------------
        msg += "\n%sLKP Info:" % formatMsgIndent()
        
        #--------------------------------
        if(anegLkpStat1 & 0x0004):
            msg += "\n%s    [LKP] Chip Rev:0x%04x" % ( formatMsgIndent(), anegLkpStat3)

        #--------------------------------
        msg += "\n%s    [LKP] FW: %02x.%02x" % (formatMsgIndent(),
                                     ((anegLkpStat4 >> 8) & 0xff), 
                                     (anegLkpStat4 & 0xff))

        #--------------------------------
        msg += "\n%s    [LKP] Rates:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(aneg10GStatus,0x0800,"10G")
        msg += "," + dbgConvertBitStateToStr(aneg10GStatus,0x0040,"5G")
        msg += "," + dbgConvertBitStateToStr(aneg10GStatus,0x0020,"2.5G")
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x0800,"AQ_5G")
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x0800,"AQ_2.5G")
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x8000,"1G-FD")
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x4000,"1G-HD")
        msg += "," + dbgConvertBitStateToStr(anegLkpAdvertisement,0x0100,"100M-FD")
        msg += "," + dbgConvertBitStateToStr(anegLkpAdvertisement,0x0080,"100M-HD")
        msg += "," + dbgConvertBitStateToStr(anegLkpAdvertisement,0x0040,"10M-FD")
        msg += "," + dbgConvertBitStateToStr(anegLkpAdvertisement,0x0020,"10M-HD")

        #--------------------------------
        msg += "\n%s    [LKP] Abilities:" % formatMsgIndent()
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x0004,"AQ-Phy")
        msg += " " + dbgConvertBitStateToStr(anegLkpStat1,0x2000,"Short-Reach")
        msg += "," + dbgConvertBitStateToStr(anegLkpStat1,0x1000,"AQRate Downshift")
        msg += "," + dbgConvertBitStateToStr(trngCtrl1,0x0002,"THP_24Tap")

        #--------------------------------
        msg += "\n%s    [LKP] EEE:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(anegEeeLinkParnerAbility,0x0004,"10G-EEE")
        #These 5G and 2.5G capabilities are NOT available during autoneg.
        #They are only exchanged during training phase  
        #msg += "," + dbgConvertBitStateToStr(anegEeeLinkParnerAbility2,0x0002,"5G-EEE")
        #msg += "," + dbgConvertBitStateToStr(anegEeeLinkParnerAbility2,0x0001,"2.5G-EEE")
        msg += "," + dbgConvertBitStateToStr(anegEeeLinkParnerAbility,0x0004,"1G-EEE")
        msg += "," + dbgConvertBitStateToStr(anegEeeLinkParnerAbility,0x0002,"100M-EEE")

        #--------------------------------
        #These 5G and 2.5G capabilities are NOT available during autoneg.
        #They are only exchanged during training phase  
        #msg += "\n%s  Capabilities THP bypass:" % formatMsgIndent()
        #msg += " " + dbgConvertBitStateToStr(aneg10GBaseTStatus2,0x0004,"5G-THP-Bypass")
        #msg += "," + dbgConvertBitStateToStr(aneg10GBaseTStatus2,0x0008,"2.5G-THP-Bypass")

        #--------------------------------
        msg += "\n%s    [LKP] IEEE FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(aneg10GStatus,0x0002,"10G-FR")
        #These 5G and 2.5G capabilities are NOT available during autoneg.
        #They are only exchanged during training phase  
        #msg += " " + dbgConvertBitStateToStr(aneg10GStatus,0x0010,"5G-FR")
        #msg += "," + dbgConvertBitStateToStr(aneg10GStatus,0x0008,"2.5G-FR")

        #--------------------------------
        msg += "\n%s    [LKP] Aq-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(autonegotiationReceiveReservedVendorStatus2,0x0001,"Enable")

        #--------------------------------
        msg += "\n%s    [LKP] Cisco-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0100,"Enable")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0200,"THP")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0400,"ExtendedMaxWait")
        msg += "," + dbgConvertBitStateToStr(globalReservedProvisioning5,0x0800,"DisableTimer")
        
        msg += "\n%s    [LKP] CNC-FR:" % formatMsgIndent()
        msg += " " + dbgConvertBitStateToStr(rfiCtrl1,0x0040,"Enable")

        #--------------------------------
        msg += "\n%s    [LKP] RFI-FR:" % formatMsgIndent()
        msg += "," + dbgConvertBitStateToStr(rfiCtrl1,0x0010,"Support")
        msg += "," + dbgConvertBitStateToStr(rfiCtrl1,0x0020,"ExtendedMaxWait")
        
        msg += "\n"
    return msg

def formatAnegInfo_PostTraining(arg0, arg1):
    global anegBreakLinkTimestamp
    global currentPhyControl
    currentTimeStamp = getTime(arg0,  arg1)
    
        
    resVenStat = currentPhyControl.pifReadData(0x07C810)
    venStat    = currentPhyControl.pifReadData(0x07C800)
    
    connState = anegConnectionStates[((resVenStat & 0x3e00) >> 9)]
    rate = anegRates[((venStat & 0x000e) >> 1)]
    
    #--------------------------------
    msg = "%s:%d ms\n%sTraining complete: Connection State: %s, Rate:%s" % \
        (formatTimeStamp(currentTimeStamp),
        (currentTimeStamp - anegBreakLinkTimestamp),
        formatMsgIndent(), connState, rate)
             
    #--------------------------------
    #Local Post-Training abilities
    aneg10GCtrl  = currentPhyControl.pifReadData(0x070020)
    anegEeeAdvertisement2 = currentPhyControl.pifReadData(0x07003E)
    aneg10GBaseTControl2 = currentPhyControl.pifReadData(0x070040)

    #--------------------------------
    msg += "\n%sLocal Info:" % formatMsgIndent()

    #--------------------------------
    msg += "\n%s    [DUT] EEE:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(anegEeeAdvertisement2,0x0002,"5G-EEE")
    msg += "," + dbgConvertBitStateToStr(anegEeeAdvertisement2,0x0001,"2.5G-EEE")
    
    #--------------------------------
    msg += "\n%s    [DUT] IEEE FR:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(aneg10GCtrl,0x0040,"5G-FR")
    msg += "," + dbgConvertBitStateToStr(aneg10GCtrl,0x0020,"2.5G-FR")

    #--------------------------------
    msg += "\n%s    [DUT] IEEE FR THP bypass:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(aneg10GBaseTControl2,0x0004,"5G-THP-Bypass")
    msg += "," + dbgConvertBitStateToStr(aneg10GBaseTControl2,0x0008,"2.5G-THP-Bypass")

    #--------------------------------
    aneg10GStatus = currentPhyControl.pifReadData(0x070021)
    anegEeeLinkParnerAbility2 = currentPhyControl.pifReadData(0x07003F)
    aneg10GBaseTStatus2 = currentPhyControl.pifReadData(0x070041)

    #--------------------------------
    #Remote Post-Training abilities
    msg += "\n%sLKP Info:" % formatMsgIndent()

    #--------------------------------
    msg += "\n%s    [LKP] EEE:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(anegEeeLinkParnerAbility2,0x0002,"5G-EEE")
    msg += "," + dbgConvertBitStateToStr(anegEeeLinkParnerAbility2,0x0001,"2.5G-EEE")
    
    #--------------------------------
    msg += "\n%s    [LKP] IEEE FR:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(aneg10GStatus,0x0010,"5G-FR")
    msg += "," + dbgConvertBitStateToStr(aneg10GStatus,0x0008,"2.5G-FR")

    #--------------------------------
    msg += "\n%s    [LKP] IEEE FR THP bypass:" % formatMsgIndent()
    msg += " " + dbgConvertBitStateToStr(aneg10GBaseTStatus2,0x0004,"5G-THP-Bypass")
    msg += "," + dbgConvertBitStateToStr(aneg10GBaseTStatus2,0x0008,"2.5G-THP-Bypass")
    
    msg += "\n"
    return msg

phyStatePrevTimestamp = 0
def formatPhyStateMsg(arg0, arg1, arg2):
    global phyStatePrevTimestamp
    currentTimeStamp = getTime(arg0,  arg1)
    msg = "%s:%d ms\n%sPHY State = %s\n" % (formatTimeStamp(currentTimeStamp), 
                                            (currentTimeStamp - phyStatePrevTimestamp),
                                            formatMsgIndent(), phyState[arg2])
    phyStatePrevTimestamp = currentTimeStamp
    return msg

def formatTrainingTypeMsg(arg0, arg1, arg2, arg3, arg4, arg5):
    global phyStatePrevTimestamp
    currentTimeStamp = getTime(arg0,  arg1)
    msg = "%s:%d ms\n%s%s Baud = %d Constellation = %s MDI mask 0x%02X\n"  % (formatTimeStamp(currentTimeStamp), 
                                            (currentTimeStamp - phyStatePrevTimestamp),
                                            formatMsgIndent(), trainingType[arg2],
                                            arg3, constellation[arg4], arg5)
    return msg

def formatAnegStatus(status):
    msg = "Autonegotiation Exit Status = %s" % (anegExitStatus[status])
    return msg

def formatUSXMsg(timeLsw, timeMsw, type, rate):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    msg = "%s USX%d " % (formatTimeStamp(currentTimeStamp), ((type & 0xff00) >> 8)) 
    msg += UsxMsgType[type & 0xff]
    msg += " Rate:%s" % anegRates[rate]
    return msg

def formatSysTransition(timeLsw, timeMsw, link, status):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    msg = "%s " % formatTimeStamp(currentTimeStamp)
    if link == 1:
        if status == 1:
            msg += "SIF Cfg: RKL1 Block Locked"
        else:
            msg += "SIF Cfg: Warning: No RKL1 Block Lock"
    elif link == 2:
        if (status & 0xf) == 0:
            msg += "SYS Monitor: Rx Link Transitioned to DOWN. SIF[%d] SD[%d] RF[%d]" % (((status >> 12) & 0x1),
                                                                                         ((status >> 8) & 0x1),
                                                                                         ((status >> 4) & 0x1)) 
        elif (status & 0xf) == 1:
            msg += "SYS Monitor: Rx Link Transitioned to UP. SIF[%d] SD[%d] RF[%d]"   % (((status >> 12) & 0x1),
                                                                                         ((status >> 8) & 0x1),
                                                                                         ((status >> 4) & 0x1)) 
        elif (status & 0xf) == 2:
            msg += "SYS Monitor: Tx Link Transitioned to UP"
        elif (status & 0xf) == 3:
            msg += "SYS Monitor: Tx Link Transitioned to DOWN"
    elif link == 3:
        """
        msg += "Sys Init: [Mode:%s Rate:%s Transition:%s]" % (sysModes[((status >> 12) & 0xf)],
                                                              (anegRates[((status >> 8) & 0xf)]),
                                                              (SysInitResetType[(status & 0xf)]))
        """
        msg += "Sys Init: [Mode:%s]" % (sysModes[(status & 0xf)])
    elif link == 4:
        #msg += "SIF Aneg Start: [Mode:XSGMII Rate:%d]" % (xsgmiiAnegRates[status])
        msg += "SIF Aneg Start: [Mode:XSGMII Rate:0x%04x]" % (status)
    elif link == 5:
        msg += "SIF Aneg Start: [Mode:USX Rate:%s]" % (anegRates[status])
    elif link == 6:
        msg += "SD Init: [sdMode:%s sysMode:%s lanemask:0x%04x]" % (sdModes[(status >> 4 & 0xf)],
                                                                    sysModes[((status >> 8) & 0xf)],
                                                                    (status & 0xf))
    elif link == 7:
        msg += "SIF Init: [Mode:XFI Rate:10G Transition:%s]" % SysInitResetType[(status & 0xf)]
    elif link == 8:
        msg += "SIF Init: [Mode:XFI Rate:AQRate Transition:%s]" % SysInitResetType[(status & 0xf)]
    elif link == 9:
        msg += "SIF Init: [Mode:SGMII Rate:1G Transition:%s]" % SysInitResetType[(status & 0xf)]
    elif link == 10:
        msg += "SIF Init: [Mode:SGMII Rate:100M Transition:%s]" % SysInitResetType[(status & 0xf)]
    elif link == 11:
        msg += "Sys Loopback: [Type:%s Rate:%s]" % (sysLoopbacks[((status >> 8) & 0xff)],
                                                    (anegRates[(status & 0xf)]))
    elif link == 12:
        if status == 0:
            msg += "SEC: Disabled"
        else:
            msg += "SEC: Enabled"
    elif link == 13:
        msg += "XGS Connect: XgsMode:%s Rate:%s Sec:%d PktGen:%d" % (xgsModes[(status >> 12) & 0xf],
           anegRates[status & 0xf], ((status >> 8)& 0xf), ((status >> 4) & 0xf))
    elif link == 14:
        msg += "XGS Init: Rate:%s Ports[XFI1:%s XAUI:%s MDI:%s]" % ((anegRates[(status & 0xf)]),
                                                                    xgsXfi1Port[((status >> 12)& 0xf)], 
                                                                    xgsXauiPort[((status >> 8)& 0xf)],
                                                                    xgsMdi1Port[((status >> 4)& 0xf)])
    elif link == 15:
        msg += "USX HW ANEG: SMC:%s. HW Initiated USX Aneg." % (UsxAnegHwSmcStates[status & 0xf])
    elif link == 16:
        msg += "USX ANEG Timeout: Restart. SMC:%s" % (UsxAnegHwSmcStates[status & 0xf])
    elif link == 17:
        if status == 0:
            msg += "SD Tx[0]: Silent"
        else:
            msg += "SD Tx[1]:Enabled"
    elif link == 18:
        msg += "SD: SMC State [%s] -> [%s]" % (SdSmcStates[status & 0xf],
                                               SdSmcStates[(status >> 8) & 0xf])
    elif link == 19:
        msgStatus = status & 0xf
        if msgStatus == 0:
            msg += "SEC Init[Disable]"
        elif msgStatus == 1:
            msg += "SEC Init[Enable]"
        elif msgStatus == 2:
            msg += "SEC Engage[%s]" % xgsClockModes[((status >> 8) & 0xf)]
    elif link == 20:
        msg += "SD Monitor init State:%s Lanemask:%04x" % (SdSmcStates[(status >> 8) & 0xf],
                                                           (status & 0xf))
    elif link == 21:
        if status == 0:
            msg += "USX Disabled"
        else:
            msg += "USX Enabled"
    elif link == 22:
        if status == 0:
            msg += "SEC:PTP disabled"
        else:
            msg += "SEC:PTP enabled"
    elif link == 23:
        if status & 0x1:
            msg += "MSM LINE "
        else:
            msg += "MSM SYS "
        msg += "Transitioned to TX[%d] RX[%d]" % (((status >> 2) & 0x1), ((status >> 1) & 0x1))

    return msg

def formatSysSmcMsg(type, timeLsw, timeMsw, msgID, errCode):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    if type == 0:
        msgType = "SEND"
    else:
        msgType = "RCV"
    return "%s SYS Msg %s: %s errCode:%d" %  (formatTimeStamp(currentTimeStamp),
                                              msgType, SysSmcMsgType[msgID], errCode)

def formatSysUsxAnegDebug(timeLsw, timeMsw, rkl1BlkLock, usx1SmcState, rxUnidataIndication):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    if rkl1BlkLock == 1:
        link = "UP"
    else:
        link = "DOWN"
    return "%s USX1: RxLink[%s] SMC:%s: rudi:%s" %  (formatTimeStamp(currentTimeStamp), link, 
            UsxAnegHwSmcStates[usx1SmcState], UsxAnegRudi[rxUnidataIndication])

def formatChkStatus(mmd, addr, regData):
    msg = "%02X.%04X = 0x%04X" % (mmd, addr, regData)
    return msg

def formatSysXgsSwitchover(timeLsw, timeMsw, type):
    
    currentTimeStamp = getTime(timeLsw, timeMsw)
    msg = "%s SYS Switchover:" % (formatTimeStamp(currentTimeStamp))
    
    enable = (type >> 8) & 0x00ff
    if enable == 1:
        msg += " Enabled "
    else:
        msg += " Disabled"
    
    msgId  = type & 0x00ff    
    if msgId == 1 and enable == 1:
            msg += " XFI1->MDI"
    elif msgId == 2:
        msg += " MDI->XFI1"
    elif msgId == 3:
        msg += " XAUI->MDI"
    elif msgId == 4 and enable == 0:
            msg += " XFI->MDI. USX Aneg Restart"
    elif msgId == 5 and enable == 0:
            msg + " XFI1->MDI. SIF CFG"
    elif msgId == 6:
        msg += " XFI1->SYS-SEC"
    elif msgId == 7:
        msg += " SYS-SEC->XFI1"
    elif msgId == 8:
        msg += " NET-SEC->MDI"
    elif msgId == 9:
        msg += " MDI->NET-SEC"
    else:
        msg += "%d" % msgId 
    
    return msg

def formatSysMgr(timeLsw, timeMsw, sdReset, sifReset, sysMode, sdMode, sifOpMode, sysRate):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    msg = "%s SYS Mgr: " % (formatTimeStamp(currentTimeStamp))
    
    msg += "SD-%s " % SdResetType[sdReset]
    msg += "SIF-%s " % SysInitResetType[sifReset]
    msg += "sysMode[%s] " % (sysModes[sysMode])
    msg += "sdMode[%s] " % (sdModes[sdMode])
    msg += "sifMode[%s] " % (sifOpModes[sifOpMode])
    msg += "sysRate[%s] " % (anegRates[sysRate])
    
    return msg

def krTrainingAlarms(alarms):
    msg = ''
    
    if alarms >> 6 & 0x1:
        msg += "Change,"
    if alarms >> 5 & 0x1:
        msg += "FL-Lo,"
    if alarms >> 4 & 0x1:
        msg += "FL-Hi,"
    if alarms >> 2 & 0x1:
        msg += "ERR-Mark,"
    if alarms >> 1 & 0x1:
        msg += "ERR-DME,"
    if alarms >> 0 & 0x1:
        msg += "ERR-PRBS,"
    
    return msg

def formatKrCoeff(coeff):
    msg = "\n\tCOEFF :0x%04x " % coeff
    msg += "PRESET:%d " % ((coeff >> 13) & 0x1)
    msg += "INIT:%d " %   ((coeff >> 12) & 0x1)
    
    msg += "PRE :%s " % krCoeffUpdate[(coeff >> 0) & 0x3]
    msg += "MAIN:%s " % krCoeffUpdate[(coeff >> 2) & 0x3]
    msg += "POST:%s " % krCoeffUpdate[(coeff >> 4) & 0x3]
    return msg
  
def formatKrStatus(status):
    msg = "\n\tSTATUS:0x%04x " % status
    if status & 0x8000:
        msg += "READY           "
    else:
        msg += "TRNG            "
    
    msg += "PRE :%s " % krCoeffStatus[(status >> 0) & 0x3]
    msg += "MAIN:%s " % krCoeffStatus[(status >> 2) & 0x3]
    msg += "POST:%s " % krCoeffStatus[(status >> 4) & 0x3]
    return msg


def krAnNextPageMsgCode(code):
    msg = "UNKNOWN"
    if code == 0x001:
        msg = "NULL"
    elif code == 0x005:
        msg = "OUI "
    elif code == 0x00a:
        msg = "EEE "
    return msg

def krAnDecodeCodeWord(type, word47_32, word31_16, word15_0):
    msg = "%s:" % type
    
    if type == "BASE":
        if word31_16 == 0 and word15_0 == 0:
            msg += "NULL"
            return msg
        
        if ((word31_16 >> 7) & 0x1) == 0x1:
            msg += "  KR"
        else:
            msg += " !KR"
    
        if((word31_16 >> 5) & 0x1) == 0x1:
            msg += "  KX"
        else:
            msg += " !KX"
        
        if((word15_0 >> 14) & 0x1) == 0x1:
            msg += "  ACK"
        else:
            msg += " !ACK"
         
        if((word15_0 >> 15) & 0x1) == 0x1:
            msg += "  NP"
        else:
            msg += " !NP" 
        
        msg += " enonce:0x%02x"  % ((word15_0  >> 5) & 0x1F)
        msg += " txnonce:0x%02x" % ((word31_16 >> 0) & 0x1F)
    
        if ((word15_0 >> 0) & 0x1F) == 0x1:
            msg += "  802.3"
        else:
            msg += " !802.3"
    elif type == "NEXT":
        msgCodeType = krAnNextPageMsgCode(word15_0 & 0x7FF)
        msg += " msg:%s" % msgCodeType
        if msgCodeType != "UNKNOWN":
            msg += " T:%d" % ((word15_0 >> 11) & 0x1)
            if ((word15_0 >> 12) & 0x1) == 1:
                msg += "  ACK2"
            else:
                msg += " !ACK2"
            if ((word15_0 >> 13) & 0x1):
                msg += "  MP"
            else:
                msg += " !MP"
            if ((word15_0 >> 14) & 0x1) == 1:
                msg += "  ACK"
            else:
                msg += " !ACK"
            if ((word15_0 >> 15) & 0x1) == 1:
                msg += "  NP"
            else:
                msg += " !NP"
    elif type == "UNF":
        msg += ""
        
    return msg

# Used for messages that can be seen by customers - scripts/debug/KR/*.py (Intel)
def formatKrMsgExternal(timeLsw, timeMsw, id, arg0, arg1, arg2):
    return formatKrMsgInternal(timeLsw, timeMsw, id, arg0, arg1, arg2)

# Used for messages that are for internal use only
def formatKrMsgInternal(timeLsw, timeMsw, id, arg0, arg1, arg2):
    return formatKrPmdMsg(timeLsw, timeMsw, id, arg0, arg1, arg2)

def formatKrPmdMsg(timeLsw, timeMsw, id, arg0, arg1, arg2):
    currentTimeStamp = getTime(timeLsw, timeMsw)
    if id < 100:
        msgType = "KR"
    else:
        msgType = "KR/X AN"
        
    msg = "%s %s[%d]:" % (formatTimeStamp(currentTimeStamp), msgType, id)
    
    coeff = arg0
    status = arg1
    
    if id == 0:
        msg += "coeffs[0x%04x] status[0x%04x]" % (arg0, arg1)
    elif id == 1:
        msg += "TX: %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 2:
        msg += "RX:  %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 3:
        msg += "PMD: state transition [%s -> %s]" % (krTrainingSmcStates[arg0], 
                                                     krTrainingSmcStates[arg1])
    elif id == 4:
        msg += "coeffUpdate: preset:%d, init:%d coeff update:%d" % (((arg0 >> 1) & 0x1),
                            (arg0 & 0x1), arg1)
    elif id == 5:
        msg += ""
    elif id == 6:
        msg += "%s Remote newCoeff:0x%02x -> 0x%02x Status:%s" % (krTap[(arg1 & 0xf)],
                    ((arg0 >> 8) & 0xff), (arg0 & 0xff), krRemoteCoeffStatus[(arg1 >> 8) & 0xff])
    elif id == 7:
        msg += "Local: state transition [%s -> %s]" % (krLocalCoeffUpdateState[arg0], 
                                                        krLocalCoeffUpdateState[arg1])
    elif id == 8:
        msg += "LOGIC (req, res):  pre(%s, %s); main(%s, %s); post(%s, %s)" % \
                        (krCoeffUpdate[((arg0 >> 12) & 0xf)], krCoeffStatus[((arg0 >> 8) & 0xf)], 
                        krCoeffUpdate[((arg0 >> 4) & 0xf)], krCoeffStatus[(arg0 & 0xf)], 
                        krCoeffUpdate[((arg1 >> 4) & 0xf)], krCoeffStatus[(arg1 & 0xf)])
    elif id == 9:
        if arg1 == 0:
            msg += "eye improving next Req State = %s" % krLocalCoeffUpdateState[arg0]
        else:
            msg += "eye not improving next Req State = %s" % krLocalCoeffUpdateState[arg0]
    elif id == 10:
        msg += "SD Set Tx: pre:0x%02x main:0x%02x post:0x%02x" % \
                (((arg0 >> 8) & 0xff), (arg0 & 0xff), ((arg1 >> 8) & 0xff))
    elif id == 11:
        msg += "TOP: state transition [%s -> %s] count: %d" % \
                (krSmcState[((arg0 >> 8) & 0xff)], krSmcState[(arg0 & 0xff)],
                 (arg1 & 0xff))
    elif id == 12:
        msg += "Top Training Init. LaneMask[0x%04x]" % arg0 
    elif id == 13:
        msg += "Local: pre:%s main:%s post:%s" % \
                (krCoeffStatus[((arg0 >> 8) & 0xf)], 
                 krCoeffStatus[((arg0 >> 0) & 0xf)], 
                 krCoeffStatus[((arg1 >> 0) & 0xf)])
    elif id == 14:
        msg += "RX: %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 15:
        msg += "Invalid Coeff/Status: %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 16:
        if ((arg1 >> 8) & 0x1) == 1:
            msg += "Frame Lock State after RxInvert:%s" % (krFrameLockState[arg0])
        else:
            msg += "Frame Lock State:%s Lock:%d" % (krFrameLockState[arg0], arg1)
    elif id == 17:
        msg += "krPmdTransmit:"
        if arg0 == 0:
            msg += "Disabled"
        else:
            msg += "Enabled"
    elif id == 18:
        msg += "TX: invalid %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 19:
        msg += "TX: Training: %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))              
    elif id == 20:
        msg += "TX: no-change %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 21:
        if arg2 == 1:
            stage = "After"
        else:
            stage = "Before"
        msg += "Remote Tap:%s %s state transition [%s -> %s] LCL:ResUpdateStatus:%s REM:ReqCoeffUpdate:%s REM:Preset:%d REM:INIT:%d" % \
            (krTap[(arg0 & 0xf)], stage,
             krRemoteCoeffUpdateState[(arg0 >> 12) & 0xf], 
             krRemoteCoeffUpdateState[(arg0 >>  8) & 0xf],
             krCoeffStatus[((arg1 >> 12) & 0xf)], krCoeffUpdate[((arg1 >> 8) & 0xf)],
             ((arg1 >> 1) & 0x1), (arg1 & 0x1))
            
    elif id == 22:
        msg += "RX: invalid %s %s" % (formatKrCoeff(arg0), formatKrStatus(arg1))
    elif id == 23:
        msg += "Frame Lock Alarm:%d Lock:%d" % (arg0, arg1)
    elif id == 24:
        if arg0 == 1:
            msg += "TX:ENABLED"
        else:
            msg += "TX:DISABLED"
    elif id == 25:
        msg += "Local: phase transition [%s -> %s]" % \
                (krLocalPhase[arg0], krLocalPhase[arg1])
    elif id == 26:
        msg += "Local: Ack:%d %d" % (arg0, arg1)              
    elif id == 27:
        msg += "Dummy:0x%04x 0x%04x" % (arg0, arg1) 
    elif id == 28:
        if arg1 == 1:
            msg += "Local: ninit:0x%04x" % ((arg0 >> 8) & 0xf)
        elif arg1 == 2:
            msg += "Local: CoarseCount:%d" % (arg0)
    elif id == 29:
        phase = "INV  "
        if arg1 == 0:
            phase = "2:DOWN"
        elif arg1 == 1:
            phase = "2:LEFT"
        elif arg1 == 2:
            phase = "2:UP  "
        elif arg1 == 3:
            phase = "2:RT  "
        elif arg1 == 4:
            phase = "2:UP:O"
        elif arg1 == 5:
            phase = "2:RT:O"
        elif arg1 == 6:
            phase = "3:DOWN"
        elif arg1 == 7:
            phase = "3:LEFT"
        elif arg1 == 8:
            phase = "3:UP  "
        elif arg1 == 9:
            phase = "3:UP:O"
        elif arg1 == 10:
            phase = "3:RT:O"
        elif arg1 == 11:
            phase = "4:DOWN"
        elif arg1 == 12:
            phase = "4:LEFT"
            
        msg += "Local:%s: (Pre,Post)=(%d, %d) Step:(%d,%d)" % (phase,
                    (-1)*((arg0 >> 12) & 0xf), (-1)*((arg0 >> 8) & 0xf), 
                    ((arg0 >> 4)  & 0xf), (arg0 & 0xf))
    elif id == 30:
        phaseStr = "INV  "
        phase = arg1 & 0xf
        started = False
        if phase == 0:
            phaseStr = "2:INIT"
        elif phase == 1:
            phaseStr = "2:S:FOM"
        elif phase == 2:
            phaseStr = "2:W:FOM"
        elif phase == 3:
            phaseStr = "3"
        elif phase == 4:
            phaseStr = "4:FOM "
        elif phase == 5:
            msg += "Fine: Rx Cal Started "
            started = True
            
        if started != True:
            msg += "Local:%s EyeSize:0x%04x State:%d LaneMask:0x%02x" % (phaseStr, 
                    arg0, ((arg1 >> 12) & 0xf), ((arg1 >> 4) & 0xff))
        
        
    elif id == 31:
        phase = arg1 & 0xf
        phaseStr = "Coarse"
        if phase == 1:
            phaseStr = "Fine"
        msg += "Local: %s Best FOM:0x%04x Pre:%d Post:%d" % (phaseStr, (arg1 >> 8) & 0xff, 
                                                                (-1) * ((arg0 >> 8) & 0xff), 
                                                                (-1) * (arg0 & 0xff))
    elif id == 32:
        if arg0 == 1:
            msg += "Local: Preset Set"
        elif arg0 == 2:
            msg += "TX: Preset Found"
        elif arg0 == 3:
            msg += "Remote: Preset Set"
        elif arg0 == 4:
            msg += "Coeff update: tap:%s Remote Preset Set" % krTap[arg1]      
    elif id == 33:
        msg += "HACK: Rx Invert"
    elif id == 34:
        msg = "Set SD TX Lane:%d Amplitude:%02d Pre:%02d Main:%02d Post:%02d" % (((arg0 >> 12) & 0xf),
                ((arg0 >> 8) & 0xf), ((arg1 >> 8) & 0xff), 
                (arg0 & 0xff), (arg1 & 0xff))
    elif id == 35 or id >= 235:
        if arg0 == 0:
            msg += "Training Started"
        elif arg0 == 1:
            msg += "Training Failed"
        elif arg0 == 2:
            msg += "Training Completed"
        elif arg0 == 3:
            msg += "Training Failed due to incorrect mode[%s] rate[%s]" % (sysModes[(arg1 >> 8) & 0xff],
                                                                           anegRates[arg1 & 0xff])
    elif id == 36:
        msg += "%s Remote Status:%s max[0x%02x] min[0x%02x] PRESET[0x%02x] COEFF[0x%02x]" % (krTap[(arg0 & 0xf)],
                    krRemoteCoeffUpdateState[(arg0 >> 8) & 0xf],
                    ((arg1 >> 8) & 0xff), (arg1 & 0xff),
                    ((arg2 >> 8) & 0xff), (arg2 & 0xff))
    
    elif id == 40:
        msg += "Feedback pre[0x%02x] main[0x%02x] post[0x%02x]" % (arg0, arg1, arg2)
    elif id == 41:
        msg += "Rx EQ Start"
    elif id == 42:
        msg += "LocalTx preTapCounter[%d] mainDecNeeded[%d]" % (arg0, arg1)
    
    elif id == 100: # KR Autoneg messages begin @ 100
        if arg1 & 0x1 == 0:
            msg += "Re-Init"
        else:
            msg += "Init. Transitioning to SD-Mode[%s] LaneMask[0x%04x]" % (sdModes[arg0], 
                                                                            ((arg1 >> 8) & 0xf))
    elif id == 101:
        msg += "TX 31:16[0x%04x] 15:0[0x%04x]" % (arg1, arg0)
    elif id == 102:
        msg += "RX 31:16[0x%04x] 15:0[0x%04x]" % (arg1, arg0)
    elif id == 103:
        msg += "AN SIG Detect[0x%04x] laneMask[%04x]" % (arg0, arg1)
    elif id == 104:
        msg += "AN Disabled. Transitioning to SD-Mode[%s] LaneMask[0x%04x]" % (sdModes[arg0], arg1)
    elif id == 105:
        msg += "AN Disable"
    elif id == 106:
        msg += "RX reversed 1[0x%04x] 0[0x%04x]" % (arg1, arg0)
    elif id == 107:
        msg += "TX reversed 1[0x%04x] 0[0x%04x]" % (arg1, arg0)
    elif id == 108:
        msg += "CMP:%d prev[0x%04x] rx[0x%04x]" % (id & 0x1, arg0, arg1)
    elif id == 109:
        msg += "CMP Result:%d" % (arg0)
    elif id == 110:
        msg += "RxAM:%02d RxAck:%02d Rx:%02d TXACK:%02d\n" % (((arg0 >> 8) & 0xff), 
                                                            ((arg0 >> 0) & 0xff),
                                                            ((arg1 >> 8) & 0xff),
                                                            ((arg1 >> 0) & 0xff))
    elif id == 111:
        msg += "PREV-RX 1[0x%04x] 0[0x%04x]\n" % (arg1, arg0)
    elif id == 112:
        msg += "TEMP 1[0x%04x] 0[0x%04x]\n" % (arg1, arg0)
    elif id >= 113 and id <= 120:
        if id >= 117:
            dir = "TX"
        else:
            dir = "RX"
        pageType = ""
        if id == 113 or id == 117:
            pageType = "INVALID"
        elif id == 114 or id == 118:
            pageType = "BASE"
        elif id == 115 or id == 119:
            pageType = "NEXT"
        elif id == 116 or id == 120:
            pageType = "UNF"
        msg += "%s [0x%04x 0x%04x 0x%04x] " % (dir, arg2, arg1, arg0)
        msg += " %s" % (krAnDecodeCodeWord(pageType, arg2, arg1, arg0))
    elif id == 121:
        msg += ""
    elif id == 122:
        msg += "Page Init\n\n"
    elif id == 123:
        msg += "Misc:0x%x 0x%x" % (arg1, arg0)
    elif id == 124:
        msg += "Alarm:"
        if arg0 & 0x0001 != 0:
            msg += "Rx Page,"
        if arg0 & 0x0002 != 0:
            msg += "Ability Match,"
        if arg0 & 0x0004 != 0:
            msg += "Ack Match,"
        if arg0 & 0x0008 != 0:
            msg += "Consistency Match,"
        if arg0 & 0x0010 != 0:
            msg += "RX Idle,"
        if arg0 & 0x0020 != 0:
            msg += "DME Error,"
        if arg0 & 0x0040 != 0:
            msg += "Ack Finished"
    elif id == 125:
        msg += "Alarm 03.EC0C [%s -> %s]" % (krTrainingAlarms(arg0), krTrainingAlarms(arg1))
    elif id == 126:
        msg += "AN: state transition [%s -> %s]" % \
                (krAnSmcState[arg0], krAnSmcState[arg1])
    elif id == 127:
        msg += "Aneg Timeout"
    elif id == 128:
        if arg0 == 0:
            msg += "Before:"
        msg += "Int Ack Finished"
        
    """
    elif id == 121:
        msg += "Tx[Ack:%d Curr:%s Send:%d] Rx[Ack:%d Curr:%s Next:%s]\n" % ((arg0 >> 8 & 0x1),
                        krAnPageType[arg0 & 0xf], (arg0 >> 12 & 0x1),
                        (arg1 >> 8 & 0x1), 
                        krAnPageType[arg1 & 0xf], krAnPageType[arg1 >> 4 & 0xf])
    """

        
    return msg

def formatstr(format, args):
    mystr = format % (args)
    return mystr

def unsigned2signed(data, nBits):
    """
    Convert from unsigned to sign
    Params:
          data  = Input data
          nBits = Data bit width. Most significant bit is sign bit.
    Example: unsigned2signed(0xFFFF, 16) = -1
    """
    signBit = data & (1 << (nBits - 1))
    data = data - (signBit << 1)
    return data

def signed2unsigned(data, nBits):
    """
    Convert from signed to unsigned
    Params:
          data  = Input data
          nBits = Data bit width.
    Example: signed2unsigned(-1, 16) = 0xFFFF
    """
    if(data < 0):
        data = data + (1 << nBits)
    return data


#################################################################
#
# Internal support functions and classes 
#    NOT allowed to be called by external modules) 
#
#


def getMsg(data):
    """
    Get message string and number of arguments
    """
    return [msgIds[data][0], msgIds[data][1]]


def createByteListFromString(aLine, format):
    """
    Create byte list from the string
    """

    line = aLine.strip()

    if line.find('0xA0047,') >= 0:
        line = line.replace('0xA0047,', '')
    if line.find('0xA0048,') >= 0:
        line = line.replace('0xA0048,', '')
    if line.find('0xA0049,') >= 0:
        line = line.replace('0xA0049,', '')

    byteList = []
    if format == "H":
        bytes = map(lambda x: int(x,16), line.split())
        byteList.append(bytes)
    else:
        try:
            data = int(line, 16)
            for i in range(4):
                byte = (data >> (8 * i)) & 0xFF
                byteList.append(byte)
        except:
            pass

    return byteList

def binaryStrToByteList(aBinaryStr):
    vByteList = [ord( x ) for x in aBinaryStr]
    return vByteList

def createByteList(filename, format):
    """
    Create byte list from the input file
    """

    try:
        if format == 'ble' or format == 'bbe':
            f = open(filename, 'rb')
        else: 
            f = open(filename, 'r')
    except:
        print "Could not open %s" % filename

    byteList = []
    if format == 'ble' or format == 'bbe':
        bytesStr = f.read()
        #print bytesStr
        byteList = binaryStrToByteList(bytesStr);
    else:
        lines = f.readlines()
    
        for line in lines:
            byteListOneLine = createByteListFromString(line,format)
            byteList.extend(byteListOneLine)

    f.close()
    return byteList


def spliceBytes(byteList):
    """
    Concatenate byte list into word
    """
    x = 0
    i = 0
    for each in byteList:
        x = x + each*(256**i)
        i = i + 1

    return x


def pivotList(a, index):
    """
    Pivot list around index
    """
    length = len(a)
    b = a[index:length]
    b.extend(a[0:index])
    return b

def getTime(lsw, msw):
    """
    Create 32 bit time stamp from 16 bit lsw and 16 bit msw inputs
    """

    if(lsw < 0):
        lsw = lsw + (1 << 16)

    if(msw < 0):
        msw = msw + (1 << 16)

    timeStamp = lsw + (msw << 16)
    return timeStamp


def list2str(stream):
    """

    Convert list of shorts into string

    """

    out = ''
    for c in stream:
        lbyte = c & 0xFF
        if(lbyte == 0):
            break
        out = out + chr(lbyte)
        #print lbyte
        mbyte = ((c & 0xFF00)>>8)&0xFF
        if(mbyte == 0):
            break
        #print mbyte
        out = out + chr(mbyte)

    #print out

    # Get Rid of double new lines
    out = out.replace('\r','')

    # Get Rid of empty lines
    result = ''
    for s in out.split('\n') :
        line = s.strip()
        if len(line)>0:
            result += s.strip() + '\n'
    # leave a trailing \n only if there was one
    if out[-1] != '\n' :
        result  = result[:-1]

    return result


class CDbgTraceConsts():
    """
    Debug Buffer Register Addresses and Status
    """
    HostBuffLswAddr              = 0xA0041
    HostBuffMswAddr              = 0xA0042
    TraceDebugStatusAddr         = 0xA0043
    TraceDebugBufferLenAddr      = 0xA0047
    TraceDebugBufferDepthAddr    = 0xA0048
    TraceDebugBufferRdPtrAddr    = 0xA0049
    HostBuffByteLengthAddr       = 0xA004B
    
    TraceDebugSendRequest        = 0x1
    TraceDebugRestartRequest     = 0x3
    TraceDebugSendFreeze         = 0x4
    TraceDebugSendUnFreeze       = 0x5
    
    """
    Debug Buffer Request and Status fields 
    """
    TraceDebugRequestMask       = 0x000f
    TraceDebugRequestShift      = 0
    TraceDebugRequestFlagsMask  = 0x00f0
    TraceDebugRequestFlagsShift = 4
    TraceDebugStatusMask        = 0x0f00
    TraceDebugStatusShift       = 8
    TraceDebugStatusFlagsMask   = 0xf000
    TraceDebugStatusFlagsShift  = 12
    
    TraceDebugStatusDataGrantedWithOverflow_Legacy  = 0x2
    TraceDebugStatusFlagDataGrantedWithOverflow     = 0x1
    TraceDebugStatusFlagDataGrantedWithResync       = 0x2
    
    """
    Debug Buffer Request and Status fields 
    """
    GlobalMacControl0RegisterFirmwareLoadedMask     = 0x0008
    GlobalMacControl0RegisterFirmwareLoadedShift    = 0
    GlobalMacControl0RegisterAddr                   = 0x1E1000


#--------------------------------------------------------------------
class CPhyControlStub( object ) :
    def __init__( self ) :
        pass

    def pifFlush(self) :
        return
    
    def pifReadData(self, aAddr):
        return 0

    def pifWrite(self, address, data) :
        return

    def pifWriteData(self, address, data) :
        return

#--------------------------------------------------------------------
class CDebugTraceResultDict( object ) :
    def __init__( self ) :
        self.mResultDict = {}
        self.mResultDict["status"] = -1 
        self.mResultDict["confirmed"] = False 
        self.mResultDict["rawMessages"] = []
        self.mResultDict["traceStatus"] = 0
        self.mResultDict["dataRequestStatus"] = "unknown"
        self.mResultDict["errMessages"] = ""
        self.mResultDict["dbgRawRemainder"] = []
        self.mResultDict["timestamp"] = ""

    def ResultDictSet(self,aResultDict):
        self.mResultDict = aResultDict

    def ResultDictGet(self):
        return self.mResultDict

#--------------------------------------------------------------------
class CDebugTraceRawFileWriter( object ) :
    def __init__( self ) :
        self.mHandle = None
        self.mFilename = ""
    def __del__(self):
        self.FileClose()
        
    def FileOpen(self, aFileName):
        fnName = sys._getframe().f_code.co_name
        if self.mHandle == None:
            vOpenMode = 'w'
            if (aFileName == self.mFilename): 
                vOpenMode = 'a'
            try:
                vHandle = open(aFileName, vOpenMode)
            except:
                dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                    "Could not open output file: %s" % aFileName
                    )
            else:
                self.mHandle = vHandle
                self.mFilename = aFileName

    def FileClose(self):
        if self.mHandle != None:
            self.mHandle.close()
            self.mHandle = None 

    def FileDelete(self, aFileName = None):
        fnName = sys._getframe().f_code.co_name
        self.FileClose()

        if aFileName == None:
            vFileName = self.mFilename
        else: 
            vFileName = aFileName
            try:
                os.remove(vFileName)
            except:
                dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                    "Could not delete output file: %s" % vFileName
                    )
            else:
                self.mFilename = None 

    def WriteRawMessage(self, aDebugTraceResultDict ):
        fnName = sys._getframe().f_code.co_name
        if self.mHandle:
            vResultDict = aDebugTraceResultDict.ResultDictGet()
            dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": Recording record: ",
                vResultDict 
                )
            vResultDictStr = str(vResultDict)
            self.mHandle.write(vResultDictStr)
            self.mHandle.write("\n")
            self.mHandle.flush()

#--------------------------------------------------------------------
class CDebugTraceRawFileReader( object ) :
    def __init__( self ) :
        self.mHandle = None
        self.mFilename = ""
        self.mRawRecords = []

    def __del__(self):
        self.FileClose()

    def FileOpen(self, phyCtrl, aFileName):
        fnName = sys._getframe().f_code.co_name
        if self.mHandle == None:
            try:
                vHandle = open(aFileName, 'r')
                self.mHandle = vHandle
            except:
                dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                    "Could not open output file: %s" % aFileName
                    )
                
            if self.mHandle != None:
                lines = [line.rstrip('\n') for line in self.mHandle]
        
                for line in lines :
                    if ( line.strip().startswith("#") or line.strip() == "" ):
                        #skip comments and empty lines 
                        pass
                    else:
                        try:
                            vRecord = eval(line)
                        except:
                            vRecord = line
                            
                        self.mRawRecords.append(vRecord)
                
                dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                    "Loaded records for file: %s NumRecords: %s" % (aFileName, len(self.mRawRecords))
                    )
        
    def FileClose(self):
        if self.mHandle != None:
            self.mHandle.close()
            self.mHandle = None 
         

    def RawRecordsGet(self ):
        return self.mRawRecords

#--------------------------------------------------------------------
class CPhyCtrlData(object) :
    def __init__( self, phyCtrl ) :
        self.mPhyCtrl = phyCtrl
        self.mHostDebugTraceBuffer = []
        self.mRequestPending = 0
        self.mRawFileWriter = CDebugTraceRawFileWriter()
        self.mRawFileReader = CDebugTraceRawFileReader()
        #self.CDebugTraceResultDict = ()

    """
    Set Request Pending flag
    """
    def requestPendingSet(self, aVal):
        #fnName = sys._getframe().f_code.co_name

        self.mRequestPending = aVal

    """
    Get Request Pending flag
    """
    def requestPendingGet(self):
        #fnName = sys._getframe().f_code.co_name

        return self.mRequestPending


    def hostDebugTraceBufferReset(self):
        fnName = sys._getframe().f_code.co_name
    
        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": ",
            "Resetting host trace buffer: object: %s, Dumped Data: %s" % (self.mPhyCtrl, self.mHostDebugTraceBuffer)
            )
        self.mHostDebugTraceBuffer = []

    """
    Set static debug trace buffer
    """
    def hostDebugTraceBufferSet(self, aNewData):
        fnName = sys._getframe().f_code.co_name

        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": in: ",
            "phy: %s, aNewData: %s " % (self.mPhyCtrl, aNewData)
            )

        self.mHostDebugTraceBuffer = []
        self.mHostDebugTraceBuffer.append(aNewData)

        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": out: ",
            "phy: %s, Data: %s" % (self.mPhyCtrl, self.mHostDebugTraceBuffer)
            )

    def hostDebugTraceBufferAdd(self, aNewData):
        fnName = sys._getframe().f_code.co_name

        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": in: ",
            "phy: %s, aNewData: %s " % (self.mPhyCtrl, aNewData)
            )
        
        # Append new data to the host trace buffer as a list
        self.mHostDebugTraceBuffer.append(aNewData)
        
        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": out: ",
            "phy: %s, Data: %s" % (self.mPhyCtrl, self.mHostDebugTraceBuffer)
            )

    """
    Get all messages from static debug trace as a combined single message
    """
    def hostDebugTraceBufferGet(self):
        fnName = sys._getframe().f_code.co_name

        vListAllMessages = []
        for vMessage in self.mHostDebugTraceBuffer:
            dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": ",
                "Fragment: phy: %s, message: %s" % (self.mPhyCtrl, vMessage)
                )
            vListAllMessages.extend(vMessage)
    
        dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": out: ",
            "Complete message: phy: %s, message: %s " % (self.mPhyCtrl, vListAllMessages)
            )
        return vListAllMessages

    """
    Get the length of all accumulated messages 
    """
    def hostDebugTraceBufferLenGet(self):
        vListAllMessages = []
        vListAllMessages  = self.hostDebugTraceBufferGet()
        return len(vListAllMessages)

    """
    Get Raw file writer object
    """
    def RawFileWriterGet(self):

        return self.mRawFileWriter
        
    """
    Get Raw file reader object
    """
    def RawFileReaderGet(self):

        return self.mRawFileReader

#--------------------------------------------------------------------
class CDebugTraceData( object ) :
    def __init__( self ) :
        self.mPhyCtrlData = {}

    def phyCtrlDataGet(self, phyCtrl):
        if (0 == (phyCtrl in self.mPhyCtrlData)):
            self.mPhyCtrlData[phyCtrl] = CPhyCtrlData(phyCtrl)
            
        return self.mPhyCtrlData[phyCtrl]


"""
Get Response

"""
def __dbgBufferResponseGet__(phyCtrl ):

    vResponse = phyCtrl.pifReadData(CDbgTraceConsts.TraceDebugStatusAddr)
    
    return vResponse

"""
Send Request

"""
def __dbgBufferRequestSend__(phyCtrl, aRequest ):

    phyCtrl.pifWrite(CDbgTraceConsts.TraceDebugStatusAddr, aRequest)
    phyCtrl.pifFlush()


"""
Send Data Request

"""
def __dbgBufferDataRequestSend__(phyCtrl):
    fnName = sys._getframe().f_code.co_name
    
    request = CDbgTraceConsts.TraceDebugSendRequest
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "phy: %s Sending data request: 0x%04x" % (phyCtrl,request)
        )
    __dbgBufferRequestSend__(phyCtrl, request)

"""
Send Freeze Request and wait for response

"""
def __dbgBufferFreezeRequestSendAndPollForResponse__(phyCtrl):
    fnName = sys._getframe().f_code.co_name
    
    request = CDbgTraceConsts.TraceDebugSendUnFreeze
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "phy: %s Sending Freeze request: 0x%04x" % (phyCtrl,request)
        )
    [confirmed, status, traceStatus, errMessage] = __dbgBufferSendRequestAndPollForResponse__(phyCtrl, request)
    return [confirmed, status, traceStatus, errMessage]

"""
Send UnFreeze Request and wait for response

"""
def __dbgBufferUnFreezeRequestSendAndPollForResponse__(phyCtrl):
    fnName = sys._getframe().f_code.co_name
    
    request = CDbgTraceConsts.TraceDebugSendUnFreeze
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "phy: %s Sending UnFreeze request: 0x%04x" % (phyCtrl,request)
        )
    [confirmed, status, traceStatus, errMessage] = __dbgBufferSendRequestAndPollForResponse__(phyCtrl, request)
    return [confirmed, status, traceStatus, errMessage]

"""
Send DebugRestart Request and wait for response

"""
def __dbgBufferDebugRestartRequestSendAndPollForResponse__(phyCtrl):
    fnName = sys._getframe().f_code.co_name
    
    request = CDbgTraceConsts.TraceDebugRestartRequest
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "phy: %s Sending DebugRestart request: 0x%04x" % (phyCtrl,request)
        )
    [confirmed, status, traceStatus, errMessage] = __dbgBufferSendRequestAndPollForResponse__(phyCtrl, request)
    return [confirmed, status, traceStatus, errMessage]

"""
Check if previously sent data request was granted or not

return 
    status :
        "init"
        "corruption"
        "pending"
        "confirmed"
    traceStatus : 

"""
def __dbgBufferCheckIfDataRequestGranted__(phyCtrl, aTimeout = 0):
    fnName = sys._getframe().f_code.co_name

    
    request = CDbgTraceConsts.TraceDebugSendRequest
    [granted, status, traceStatus, errMessage] = __dbgBufferPollForResponse__(phyCtrl,request, aTimeout)

    return [granted, status, traceStatus, errMessage]

"""
Check if previously sent request was granted or not

"""
def __dbgBufferCheckIfRequestGranted__(phyCtrl, aOriginalRequest):
    status = "unknown" 
    traceStatus = __dbgBufferResponseGet__(phyCtrl)

    #Matching rules: request == response 
    vRequestId = ( aOriginalRequest & CDbgTraceConsts.TraceDebugRequestMask ) >> CDbgTraceConsts.TraceDebugRequestShift
    vRequestFieldInStatus = ( traceStatus & CDbgTraceConsts.TraceDebugRequestMask  ) >> CDbgTraceConsts.TraceDebugRequestShift
     
    vResponseFieldInStatus = ( traceStatus & CDbgTraceConsts.TraceDebugStatusMask ) >> CDbgTraceConsts.TraceDebugStatusShift  
    if (traceStatus == 0 ):
        #fw was reset after request was issued
        status = "init" 
    elif (vRequestFieldInStatus != vRequestId ):
        #Request ID that we wrote no longer matches
        #IC is likely resetting 
        status = "corruption" 
    elif (vResponseFieldInStatus == 0 ):
        status = "pending"
    else: 
        #we got some kind of response to our request
        #ensure that there is no corruption. 
        #i.e fw was reset after request was issued
        #ensure that the fw echoed the request
        if (vResponseFieldInStatus == vRequestId):
            status = "confirmed"
        else: 
            #handle special case with legacy firmware
            #where TraceDebugSendRequest (0x1) is echoed back as TraceDebugStatusFlagDataGrantedWithOverflow_Legacy (0x2 in MSB)  
            if (vRequestId == CDbgTraceConsts.TraceDebugSendRequest):
                if ( vResponseFieldInStatus == CDbgTraceConsts.TraceDebugStatusDataGrantedWithOverflow_Legacy ):
                        status = "confirmed"
                else: 
                    status = "corruption"
            else: 
                status = "corruption"
                            
    return [status, traceStatus]

"""
Poll of response to previously sent request

"""
def __dbgBufferPollForResponse__(phyCtrl, aOriginalRequest, aTimeout = 2.0):
    fnName = sys._getframe().f_code.co_name

    traceStatus = 0
    confirmed = False
    errMsg = ""
    
    timeout = aTimeout
    
    start = time.clock()
    # Wait for request to be confirmed
    vDebugVerbosityLevel = gDebugVerbosityLevels["verbose01"]
    while True: 
        [status, traceStatus] = __dbgBufferCheckIfRequestGranted__(phyCtrl, aOriginalRequest)
        if (status == "corruption"):
            errMsg += "WARNING: Incoherent response to request. IC reset might be in progress: phy: %s request: 0x%04x response: 0x%04x\n" % (phyCtrl,aOriginalRequest,traceStatus)
            dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
                errMsg
                )
            traceStatus = aOriginalRequest
            break
        elif (status == "init"):
            errMsg += "WARNING: Firmware reinitialized. phy: %s request: 0x%04x response: 0x%04x\n" % (phyCtrl,aOriginalRequest,traceStatus)
            dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
                errMsg
                )
            break
        elif (status == "confirmed"):
            confirmed = True
            break
        elif (status == "pending"):
            #keep on waiting for response...
            vDebugVerbosityLevel = gDebugVerbosityLevels["verbose02"]
            pass
        else: 
            errMsg += "ERROR: Unsupported status: %s phy: %s request: 0x%04x response: 0x%04x\n" % (status, phyCtrl,aOriginalRequest,traceStatus)
            dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                errMsg
                )
            raise
              
        #print "Request:0x%04x Time Spent: %s traceStatus:0x%04x Granted:%d]" % (aOriginalRequest, str(time.clock() - start), traceStatus, confirmed)

        #loop exit condition
        if ((time.clock() - start) >= timeout ):
            status == "timeout"
            break #<<<< break >>>>

        time.sleep(0.01)
    
    vElapsedTime = str(time.clock() - start)
    dbgPrint( vDebugVerbosityLevel, fnName, ": ",
        "phy: %s original request: 0x%04x response: 0x%04x confirmed: %d status: \"%s\" pool timeout: %s ElapsedTime: %s" % (phyCtrl, aOriginalRequest, traceStatus, confirmed, status, timeout, vElapsedTime)
        )

    return [confirmed, status, traceStatus, errMsg]

"""
Send Requests to the Debug Buffer and Wait for Grant

"""
def __dbgBufferSendRequestAndPollForResponse__(phyCtrl, request, aTimeout = 2.0):
    fnName = sys._getframe().f_code.co_name

    __dbgBufferRequestSend__(phyCtrl, request)
    
    [confirmed, status, traceStatus, errMsg] = __dbgBufferPollForResponse__(phyCtrl, request, aTimeout)
    
    return [confirmed, status, traceStatus, errMsg]

"""
Get the number of bytes accumulated in the firmware buffer

"""
def __dbgBufferFirmwareBufferDepthGet__(phyCtrl):

    vVal = phyCtrl.pifReadData(CDbgTraceConsts.TraceDebugBufferDepthAddr)
    return vVal 

"""
Get the number of bytes transfered by the firmware buffer in the host buffer

"""
def __dbgBufferHostBufferDepthGet__(phyCtrl):

    vVal = phyCtrl.pifReadData(CDbgTraceConsts.HostBuffByteLengthAddr)
    return vVal 

#################################################################
#
# API functions (allowed to be called by external modules 
#
#
def resetDebugBuffer(phyCtrl):
    """
    Desc:
        This call will clear all accumulated data in the firmware dbgTrace buffer.
        it issues TraceDebugRestartRequest command and waits for it to complete
    Params: 
            phyCtrl = handle to phyCtrl
    Return  status
            status = 0 - success
                    -1 - error
    """
    fnName = sys._getframe().f_code.co_name

    dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
        "phy: %s Resetting Debug Buffer" % (phyCtrl)
        )
    
    start = time.clock()
    
    errMsg = ""
    errMessage = ""
    
    #------------------------------------------------------------
    [confirmed, status, traceStatus, errMessage] = __dbgBufferDebugRestartRequestSendAndPollForResponse__(phyCtrl)
    if not confirmed:
        errMessage += "ERROR: Request to Reset Debug Buffer was not confirmed. TraceStatus:0x%04x\n" % (traceStatus)  
        errMsg += errMessage
        dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
            errMessage
            )
        status = -1
    else:
        status = 0
    
    
    #------------------------------------------------------------
    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
    #clear internal state machine state
    vPhyCtrlData.requestPendingSet(0)
    #dump accumulated remainder data as it is no longer relevant
    vPhyCtrlData.hostDebugTraceBufferReset()
    
    dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
        "phy: %s status: %s Time spent: %s" % (phyCtrl, status, str(time.clock() - start))
        )
    
    return status

def printTrace(phyCtrl, buff, msgList=None):
    """
    Desc:
    Params: 
            phyCtrl = handle to phyCtrl
            buff = List containing messages. List may contain fractional
                   number of messages.
            msgList = This is a list of messages that should be parsed and the
                   the rest should be ignored. This is done for giving
                   debug trace parsing to customer (example: KR for Intel),
                   without revealing too much.
                   Example List: msgList = ['DGB_ID_KR_AN', 'DGB_ID_KR_PMD', 'DGB_ID_KR_PMD2']
    Return  [msgString rem status]
                msgString = Message string in human readable form containing integer whole number of messages.
                processed = List with the raw messages that have been decoded or dropped
                rem = List with the remainder fractional message that couldn't be decoded.
                status = 0 - success
                         1 - parse error
                         2 - callback function error
    """

    fnName = sys._getframe().f_code.co_name

    ### Here we keep a copy of phyCtrl in a global so that debug trace
    ### format functions have access to it. Passing this as an argument
    ### is a bit tricky to do, since these are invoked as callbacks.
    global currentPhyControl
    currentPhyControl = phyCtrl

    #
    # Print out the data from the buffer in human readable form
    #
    vNumWordsInBuffer = len(buff)
    outString = ''
    rem = []
    status = 0
    skip = 0
    ind = 0 # Index for iterating buffer
    msgStrId = ''  # Keep Track of MsgId that could be used for filtering later.
    for data in buff:
        dbgPrint( gDebugVerbosityLevels["verbose03"], fnName, ": ",
            "buff data=0x%04x idx=%d" % (data,ind)
            )
        
        #------------------------------------------------------------
        if(skip == 0):
            args = []
            try:
                msg = getMsg(data)
                
                if (ind ==  0 ):
                    if 'gDebugTestModeCorruptFirstMessage' in globals():
                        if gDebugTestModeCorruptFirstMessage:
                            raise ValueError("Debug: Drop First message")
            except:
                errStr = "ERROR: Parsing Debug Trace Error: Bad message in trace 0x%04x (%d). Buffer index:%d len:%d" % (data, data, ind, vNumWordsInBuffer)
                dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                    errStr
                    )

                bufferData = '[' + ", ".join(map(lambda x: "%04X" % x, buff[ind:])) + ']'

                dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": Unprocessed data (dec): ",
                    buff[ind:]
                    )
                dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": Unprocessed data (hex): ",
                    bufferData
                    )

                #uncomment for debugging trace corruptions
                #raise
            
                outString += errStr + "\n"  
                status = 1

                ind = ind + 1 # index for iterating buff
                continue

            #------------------------------------------------------------
            nArgs = msg[0]
            msgCall = msg[1]
            msgStrId = msg[1]
            msgIdentification = data
            
            dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
                 'msgStrId=%s (%d,0x%04X) nArgs=%d ' % (msgStrId, msgIdentification, msgIdentification, nArgs)
                 )
            #------------------------------------------------------------
            # Certain messages have variable number of arguments.
            vNumArgsExpectedAsPartOfTheMessage = ( 0
                or ( msgCall.find('DBG_ID_PRINTF') != -1 )
                or ( msgCall.find('DBG_ID_CHECKPOINT') != -1)
                );
            if vNumArgsExpectedAsPartOfTheMessage :
                # Message length includes the length field (i.e. Message with zero arguments will have numArgs == 1)
                if((ind + 1) <= len(buff) - 1):
                    nArgs = buff[ind+1] 
                    #Check for stream corruption. 
                    if ( msgCall.find('DBG_ID_PRINTF') != -1 ):
                        vMaxNumArgs = MAX_NUM_ARGS_IN_PRINTF_MSG
                    else: 
                        vMaxNumArgs = MAX_NUM_ARGS_IN_DBG_MSG
                    if ( nArgs > vMaxNumArgs ):
                        errStr = 'Warning: Stream corruption detected. msgIdentification=0x%04x (%d), nArgs=%d, max allowed vMaxNumArgs=%d ' % (msgIdentification,msgIdentification,nArgs, vMaxNumArgs)  
                        dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                            errStr
                            )
                        outString += errStr + "\n"  
                        nArgs = 0
                else:
                    # Reached the end of the buffer, number of arguments is in
                    # the next buffer break out of loop to return the fractional message in the reminder output
                    skip = 1
                    break
                dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                    'var args cmd msgStrId=%s nArgs=%d ' % (msgStrId, nArgs)
                    )

            skip = nArgs
        else:
            args.append(data)
            skip = skip - 1
        
        #------------------------------------------------------------
        #Last word?
        if (ind == ( vNumWordsInBuffer - 1)):
            if 'gDebugTestModeDoNotProcessLastMessage' in globals(): 
                if gDebugTestModeDoNotProcessLastMessage == 1: 
                    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                        "Debug: skipping processing of msgCall=%s" % (msgCall)
                        )
                    skip = 1

        #------------------------------------------------------------
        if(skip == 0):
            msgCall = msgCall + '([ ' + ", ".join(map(str, args)) + '])'
            msgCall = '' + msgCall
            dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                "msgCall=%s" % (msgCall)
                )
            msgArgs = '[' + ", ".join(map(lambda x: "%04X" % x, args)) + ']'
            dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                "msgArgs(hex)=%s" % (msgArgs)
                )
            
            try:
                drop = False  # Start with the assumption that we do not drop
                if msgList != None:   # check only if msgIDs are supplied.
                    if not (msgStrId in msgList):  # do we have our msgId, else drop
                        drop = True
                        
                decodedMessage = ''    # need to set a value before use.
                if not drop:  # only if not be dropped. This also includes 'DBG_ID_PRINTF'
                    decodedMessage = eval(msgCall)                    
                outString = outString + decodedMessage
                
                vDecodedMessageLines = decodedMessage.splitlines()
                vlineIndex = 1
                for vLine in vDecodedMessageLines:
                    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                        "decodedMessage: line: %3d: %s" % (vlineIndex, vLine)
                        )
                    vlineIndex+=1
            except Exception,e:
                (exc_type, exc_value, exc_traceback) = sys.exc_info()
                tb_list = traceback.extract_tb(sys.exc_info()[2])
                tb_list = traceback.format_list(tb_list)
                
                errStr = "ERROR: Parsing Debug Trace: Bad callback function %s. Buffer index:%d len:%d." % (msgCall, ind, len(buff))
                errStr += "Unexpected error:%s" % sys.exc_info()[0]
                errStr +=  " Exception:%s" % str(e)
                errStr += "\n Stack Trace:" 
                #print exception type
                errStr +=  "\nException type:"
                errStr +=  "%s" % exc_type
                errStr +=  "\nTraceback entries:"
                for elt in tb_list:
                    errStr += elt
                dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                    errStr
                    )
                outString += errStr + "\n"  

                status = 2
                #resetDebugBuffer(phyCtrl)
                #buff = []
                #return ['', buff, status]

        ind = ind + 1 # index for iterating buff

    #------------------------------------------------------------
    # Get the fractional message.
    # If skip is greater than zero it means we haven't processed the complete message
    if(skip > 0):
        args.insert(0, msgIdentification)
        rem = args

    return [outString, rem, status]


    """

    Debug data parser:
     
    Note: This function restarts processing of the trace stream on every call 
        and does not keep track of incomplete messages

    inputFormat = None => Direct memory read from device is assumed
                'd': Memory dump of dbgBuff structure; see dbgBuff_t in dbgBuffer.h 
                'ble': Concatenated complete dbgtrace messages in raw binary little-endian format
                    e.g. printf(str)
                        '\x13\x00\x17\x00RX EQ CAL: curr state: 0; next state: 1 (1)\n'
                    corresponds to string: RX EQ CAL: curr state: 0; next state: 1 (1)\n
                'bbe': Concatenated complete dbgtrace messages in raw binary big-endian format
                    e.g. printf(str)
                        '\x00\x13\x00\x17XRE  QAC:Lc ru rtsta:e0  ;entxs atet : 11(\n)'
                    corresponds to string: RX EQ CAL: curr state: 0; next state: 1 (1)\n
                'q': QA debug trace logs
                    ; unwrapped copy of the main firmware trace buffer 
                    ; Data elements are in big-endian format  
                    ; each line contains a single hexadecimal 32-bit number in the format
                    ; DDCCBBAA
                    ; where BBAA - 16-bit big-endian hex integer with index Y  
                    ; where DDCC - 16-bit big-endian hex integer with index Y+1
                    0xA0047 - buffer size in bytes  
                    0xA0048 - number of bytes to parse starting at offset in 0xA0049
                    0xA0049 - trace starts at this offset in bytes
                    
                    e.g: printf(str) 
                        0xA0047, 00800  
                        0xA0048, 00030
                        0xA0049, 00006
                        
                        00000000 
                        00130000
                        58520017
                        20514520
                        3a4c4143
                        72756320
                        74732072
                        3a657461
                        203b3020
                        7478656e
                        61747320
                        203a6574
                        31282031
                        00000a29

                    corresponds to string: RX EQ CAL: curr state: 0; next state: 1 (1)\n
                'M': Direct memory read from device
                    reads the main trace buffer directly from the device then unwraps and parses it
                'R': File with previously collected RAW trace (see DbgTraceRawFileCollectAndWrite())
                    Each line is record containing dbgtrace extracted via hostbuffer mechanism
                    e.g. DBG_ID_ANEG_STATE; printf(str)  
                    {'status': 0, 'confirmed': True, 'errMessages': '', 'dataRequestStatus': 'confirmed', 'dbgRawRemainder': [], 'rawMessages': [8L, 1607L, 0L, 7L], 'timestamp': 1475094408.8970001, 'traceStatus': 257}
                    {'status': 0, 'confirmed': True, 'errMessages': '', 'dataRequestStatus': 'confirmed', 'dbgRawRemainder': [], 'rawMessages': [0x13, 0x17, 0x5852, 0x4520, 0x2051, 0x4143, 0x3A4C, 0x6320, 0x7275, 0x2072, 0x7473, 0x7461, 0x3A65, 0x3020, 0x203B, 0x656E, 0x7478, 0x7320, 0x6174, 0x6574, 0x203A, 0x2031, 0x3128, 0xA29], 'timestamp': 1475094409.5870001, 'traceStatus': 0x101}
                    corresponds to trace: 
                        1607 ms::1607 ms\n
                                Autoneg Arbiter State = ABILITY_DETECT\n
                        RX EQ CAL: curr state: 0; next state: 1 (1)\n
                'H': File generated in hw similator
                    One space separated Hex string per line (LSB First) containing complete message
                    The hex sting contains 16-bit integers in little-endian format  
                    e.g:
                        08 00 47 06 00 00 07 00 
                        13 00 17 00 52 58 20 45 51 20 43 41 4C 3A 20 63 75 72 72 20 73 74 61 74 65 3A 20 30 3B 20 6E 65 78 74 20 73 74 61 74 65 3A 20 31 20 28 31 29 0A
                    corresponds to: printTrace: msgCall=DBG_ID_ANEG_STATE([ 1607, 0, 7])
                    corresponds to: printTrace: msgCall=DBG_ID_PRINTF (19,0x0013)([ 23, 22610, 17696, 8273, 16707, 14924, 25376, 29301, 8306, 29811, 29793, 14949, 12320, 8251, 25966, 29816, 29472, 24948, 25972, 8250, 8241, 12584, 2601])
                    corresponds to trace:
                        1607 ms::1607 ms\n
                                Autoneg Arbiter State = ABILITY_DETECT\n
                        RX EQ CAL: curr state: 0; next state: 1 (1)\n
                       
    """
def parseDebugTrace(phyCtrl, outputFile=None, inputFile=None, inputFormat=None, inputString=None):

    fnName = sys._getframe().f_code.co_name

    #
    # Validate arguments
    #
    if inputFile != None:

        # Check input file
        if inputFile != None:
            try:
                fIn = open(inputFile, 'r')
            except:
                print "Parsing Debug Trace Error: Could not open input file %s" % inputFile
                return
        fIn.close()

        # If input format is not specified it defaults to 'M' (read from memory)
        if inputFormat == None:
            inputFormat = 'M'
        elif inputFormat not in ['d', 'ble', 'bbe', 'q', 'M','R', 'H']:
            print 'Parsing Debug Trace Error: Invalid input format option: %s' % (inputFormat)
            return
    else:
        if inputString != None:
            # When input file is not specified input format must be 'H' (simulation log)
            if inputFormat == None:
                inputFormat = 'H'
        else:
            # When input file is not specified input format must be 'M' (read from memory)
            if inputFormat == None:
                inputFormat = 'M'
            elif inputFormat != 'M':
                print 'Parsing Debug Trace Error: Invalid input format option %s ' % (inputFormat)
                return

    fOut = None

    #------------------------------------------------------------
    if phyCtrl == None:
        # 'M' (read from memory) type requires a valid phyCtrl to be passed 
        if inputFormat == 'M':
            print 'Parsing Debug Trace Error: phyCtrl object is required to be passed in for input format option: %s' % (inputFormat)
            return
        
        #Use phyControl stub
        phyCtrl = CPhyControlStub()

    # If the output is defined as the name of output file :
    if type(outputFile) is str :
        try:
            fOut = open(outputFile, 'w')
        except:
            print "Parsing Debug Trace Error: Could not open output file %s" % outputFile
            return
    # The default is stdout
    elif outputFile == None :
        fOut = sys.stdout
    # Or it can be a file or string file
    else :
        fOut = outputFile

    #------------------------------------------------------------
    vUnwrapRequred = True
    vCallPrintTrace = True

    #------------------------------------------------------------
    if(inputFormat == 'ble') or (inputFormat == 'bbe'):
        # Create byte List
        byteList = createByteList(inputFile, inputFormat)
        #print byteList

        nElements = len(byteList) / 2
        nBytes = 2
        index = 0
        buff = [0]*nElements
        for i in range(nElements):
            vElementBytes = byteList[index:index+nBytes:]
            if(inputFormat == 'bbe'):
                vElementBytes = vElementBytes[::-1] #reverse list for big-endian
            value = spliceBytes(vElementBytes)
            #print value
            index = index + nBytes
            if nElements > 1:
                buff[i] = value
            else:
                buff[0] = value

        #print buff 
        
        readIndex = 0
        wordsToRead = nElements

    #------------------------------------------------------------
    if(inputFormat == 'd'):

        # Create byte List
        byteList = createByteList(inputFile, inputFormat)

        # Dictionary keys function will return keys in arbitrary order
        # therefore keys need to be sorted to get the right order.
        # Requirement of dictionary keys are to be alphabetically ordered
        # by adding corresponding prefix
        keys = sorted(formatSpec.keys())

        # Parse byte list according to the format
        index = 0
        for k in keys:
            nElements = formatSpec[k]['nEle']
            nBytes = formatSpec[k]['nBytesPerEle']
            for i in range(nElements):
                value = spliceBytes(byteList[index:index+nBytes])
                index = index + nBytes
                if nElements > 1:
                    formatSpec[k]['val'][i] = value
                else:
                    formatSpec[k]['val'] = value


        # Unwrap the circular buffer
        buffLength = formatSpec['D01_length']['val']
        buffStart = formatSpec['D16_bufferStorage']['val']
        readStart = formatSpec['D08_readStartOfMsg']['val']
        readIndex = (readStart - buffStart) / 2
        wordsToRead = formatSpec['D11_bufferDepth']['val'] / 2
        buff = formatSpec['D17_buff']['val']

    #------------------------------------------------------------
    if(inputFormat == 'q'):

        # Create byte List
        byteList = createByteList(inputFile, inputFormat)

        buffLength = spliceBytes(byteList[0:3]) / 2
        buff = [0]*buffLength
        wordsToRead = spliceBytes(byteList[4:7]) / 2
        readIndex = spliceBytes(byteList[8:11]) / 2
        index = 12
        for i in range(buffLength):
            buff[i] = spliceBytes(byteList[index:index+2])
            index = index + 2

    #------------------------------------------------------------
    if(inputFormat == 'M'):

        TimeOut = 2.0 # Time out in seconds for trace buffer requests to be granted

        #
        # Send request to FW to freeze debug trace
        #
        print "Requesting FW to Freeze Debug Trace...",
        try:
            phyCtrl.pifWrite(0xA0043, 0x0004)
        except:
            print "Parsing Debug Trace Error:  Cannot read from device"
            return

        phyCtrl.pifFlush()
        print "Done"
        print "Waiting for FW to acknowledge that FREEZE request is granted...",
        startTime = time.clock()
        elapsedTime = 0
        while (elapsedTime < TimeOut):
            time.sleep(0.25)
            request = phyCtrl.pifReadData(0xA0043)
            if (request == 0x0404) :
                print "Done"
                break
            elapsedTime = time.clock() - startTime
        if(elapsedTime >= TimeOut):
            print "\nParsing Debug Trace Warning:  Time Out while waiting for FREEZE request to be granted."

        #
        # Dump debug trace
        #
        buffLength = phyCtrl.pifReadData(0xA0047) / 2
        buff = [0]*buffLength
        wordsToRead = phyCtrl.pifReadData(0xA0048) / 2
        readIndex = phyCtrl.pifReadData(0xA0049) / 2
        mem.initFromReg(lswReg = 0XA0045, mswReg = 0XA0046)
        if mem.getPointer():
            print "Reading out debug trace data..."
            buff = mem[('short', buffLength)]
            # Convert to unsigned short. Note that processor memory class does not have option
            # to read data in unsigned short format.
            ii = 0
            for x in buff:
                buff[ii] = signed2unsigned(x, 16)
                ii = ii + 1


        #
        # Send Request to FW to UnFreeze Debug Trace...
        #
        print "Requesting FW to Un-Freeze Debug Trace...",
        phyCtrl.pifWrite(0xA0043, 0x0005)
        phyCtrl.pifFlush()
        print "Done"
        print "Waiting for FW to acknowledge that UN-FREEZE request is granted...",
        startTime = time.clock()
        elapsedTime = 0
        while (elapsedTime < TimeOut):
            time.sleep(0.25)
            request = phyCtrl.pifReadData(0xA0043)
            if (request == 0x0505) :
                print "Done"
                break
            elapsedTime = time.clock() - startTime
        if(elapsedTime >= TimeOut):
            print "\nParsing Debug Trace Warning: Time Out while waiting for UN-FREEZE request to be granted."

    #------------------------------------------------------------
    if(inputFormat == 'H'):
        vCallPrintTrace = False
        vUnwrapRequred = False
        
        if inputString != None:
            vMessageList = createByteListFromString(inputString, inputFormat)
        else: 
            vMessageList = createByteList(inputFile, inputFormat)

        vMessageIndex = 0
        decodedMessage = ""
        for vMessage in vMessageList: 
            #print "vMessage: %s" % (vMessage) 
            dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
                "Reading message: %s" % (vMessage)
                )
            index = 0
            vBuff = []
            for i in range(0,len(vMessage)/2) :
                #print "i: %s index: %s bytes: %s" % (i,index, vMessage[index:index+2])
                vWord = spliceBytes(vMessage[index:index+2])
                #print "vWord: %s" % (vWord)
                vBuff.append(vWord)
                index = index + 2

            errMsg = ""
            [decodedSingleMessage, rem, printTraceStatus] = printTrace(phyCtrl, vBuff)
            if len(rem) != 0:
                errMsg = "WARNING: Undecoded partial trace in message group. Index: %s partial data: %s" % (vMessageIndex, rem)
                dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
                    errMsg
                    )
            if len(errMsg) > 0:
                decodedMessage += errMsg + "\n"
            decodedMessage += decodedSingleMessage
                
            vMessageIndex += 1  
        
    #------------------------------------------------------------
    if(inputFormat == 'R'):
        vCallPrintTrace = False
        vUnwrapRequred = False
        [status, decodedMessage] = DbgTraceGetFromRawFile(phyCtrl, inputFile )

    #------------------------------------------------------------
    if vUnwrapRequred:
        unwrapBuff = pivotList(buff, readIndex)
        unwrapBuff = unwrapBuff[0:wordsToRead]

    #------------------------------------------------------------
    if vCallPrintTrace:
        [decodedMessage, rem, printTraceStatus] = printTrace(phyCtrl, unwrapBuff)
        
        if len(rem) != 0:
            errMsg = "WARNING: Undecoded partial message after call to printTrace: %s" % rem
            dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
                errMsg
                )
            decodedMessage += errMsg  

    #------------------------------------------------------------
    if(fOut != None):
        fOut.write(decodedMessage)
    else:
        print decodedMessage


    if type(outputFile) is str :
        # Close the file:
        fOut.close()
    else :
        fOut.flush()


"""
DbgTraceGet() is a debug message retrieval function. This is a simpler version of 
parseDebugTrace(), that returns human-readable messages from the Debug Buffer. 
Also it handles errors while retrieving the buffer.

    Params: phyCtrl: handle to phycontrol object
            printInfo: if host wants this function to print diagnostic info or skip.
            freeze: Optional. If host wants to freeze/unfreeze buffer during capture.
            msgList = Optional. This is a list of messages that should be parsed and the
               the rest should be ignored. This is done for giving
               debug trace parsing to customer (example: KR for Intel),
               without revealing too much.
               Example List: msgList = ['DGB_ID_KR_AN', 'DGB_ID_KR_PMD', 'DGB_ID_KR_PMD2']
    Return: [status, DecodedBuffer]
        status:  0:  Success
                 1:  Reserved
                 2:  Warning: Overflow occurred, but DecodedBuffer still valid. Some traces may have been lost
                 3:  Warning: No available data in the buffer    
                 4:  Warning: Parser reported error while decoding buffer.    
                 5:  Warning: resync was reported by the firmware, but DecodedBuffer still valid. Some traces may have been lost    
                -1:  Error: Freeze request was not granted by firmware
                     Empty Debug Buffer is returned
        DecodedBuffer: Decoded Messages. Only valid when status >= 0
                Empty DecodedBuffer is valid, if there were no messages found

    Usage: 
    dbg = dbgtrace.DebugTrace(phyCtrl)
    Service this function in a loop similar to this below:
        while True:
            [status, msg] = dbg.TraceGet()
            if status < 0:
                print "Error: TraceGet() returned error code:%d", status
            elif len(msg) > 0: 
                print msg
            else:
                print '.'
                
            time.sleep(1)
    

"""
def DbgTraceGet(phyCtrl, printInfo=False, freeze=False, msgList=None):
    fnName = sys._getframe().f_code.co_name

    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "Start of DbgTraceGet()printInfo: %s freeze: %s " % (printInfo, freeze)
        )

    status = 0
    errMsg = ""
    decodedMessage = ""

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)

    vDebugTraceResultDict = __DbgTraceGetRaw__(phyCtrl,printInfo,freeze)
    vResultDict = vDebugTraceResultDict.ResultDictGet()
    errMsg += vResultDict["errMessages"] 

    status = vResultDict["status"]
    if vResultDict["confirmed"]:
        vRawFileWriter = vPhyCtrlData.RawFileWriterGet()
        [statusParse, decodedMessage, errMessageParse] = __DbgTraceParseRaw__(phyCtrl, vDebugTraceResultDict , msgList)
        vRawFileWriter.WriteRawMessage(vDebugTraceResultDict)

        errMsg +=  errMessageParse
        if statusParse != 0:
           status = 4

    #print decodedMessage
            
    if len(errMsg) > 0:   # Only if there is something to print. Else new lines need not be printed.
        decodedMessage = errMsg + "\n" + decodedMessage
    
    #endStr = "\nTRACE DEBUG: At the end of DbgTraceGet()\n"
    #decodedMessage = startStr + decodedMessage + endStr
    
    dbgPrint( gDebugVerbosityLevels["verbose02"], fnName, ": ",
        decodedMessage
        )
    
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "End of DbgTraceGet() status: %s" % (status)
        )
    
    return [status, decodedMessage]


"""
DbgTraceRawFileCollectAndWrite() collects RAW debug messages from device and writes it into specified file. 
It has the same behaviour as DbgTraceGet() except it doesn't parse received messages. 
It simply appends them in dict format to the specified file

    Params: phyCtrl: handle to phycontrol object
            printWarning: if host wants this function to print warning or skip.
                Warning could be generated during overflow or error cases.
                Warning could also be generated when there is nothing in the buffer to retrieve. This gets noisy!
    Return: [status, errMsg]
        status:  0:  Success
                 1:  Reserved
                 2:  Warning: Overflow occurred, but DecodedBuffer still valid. Some traces may have been lost
                 3:  Warning: No available data in the buffer    
                 5:  Warning: resync was reported by the firmware, but DecodedBuffer still valid. Some traces may have been lost    
                -1:  Error: Freeze request was not granted by firmware
                     Empty Debug Buffer is returned
        errMsg: Error messages collected while extracting ram messages from the device

    Usage: 
    dbg = dbgtrace.DebugTrace(phyCtrl)
    Service this function in a loop similar to this below:
        while True:
            [status, errMsg] = dbg.DbgTraceRawFileCollectAndWrite()
            if status < 0:
                print "Error: DbgTraceRawFileCollectAndWrite() returned error code:%d", status
            time.sleep(1)
    

"""
def DbgTraceRawFileCollectAndWrite(phyCtrl, aFile, printWarning = False):
    fnName = sys._getframe().f_code.co_name

    status = 0
    errMsg = ""

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
    vRawFileWriter = vPhyCtrlData.RawFileWriterGet()
    vRawFileWriter.FileOpen(aFile)

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
    
    vDebugTraceResultDict = __DbgTraceGetRaw__(phyCtrl)
    vResultDict = vDebugTraceResultDict.ResultDictGet()
    errMsg += vResultDict["errMessages"] 
    
    status = vResultDict["status"]
    if vResultDict["confirmed"]:
        vRawFileWriter = vPhyCtrlData.RawFileWriterGet()
        vRawFileWriter.WriteRawMessage(vDebugTraceResultDict)

    vRawFileWriter.FileClose()
    
    return [status, errMsg]

"""
DbgTraceRawFileDelete() deletes passed in RAW file or whichever was used in calls to DbgTraceRawFileCollectAndWrite() 
and returns human-readable messages; same messages that you would have gotten if you were to call DbgTraceGet() on line device 

    Params: phyCtrl: handle to phycontrol object
            aFile = Optional. Specifies file to delete. 
                if not specified then the file that was used in calls to DbgTraceRawFileCollectAndWrite() will be deleted 
    Return: None

"""

def DbgTraceRawFileDelete(phyCtrl, aFile = None):
    fnName = sys._getframe().f_code.co_name

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
    vRawFileWriter = vPhyCtrlData.RawFileWriterGet()
    
    vRawFileWriter.FileDelete(aFile)

"""
DbgTraceGetFromRawFile() processed RAW file (collected earlier with DbgTraceRawFileCollectAndWrite()) 
and returns human-readable messages; same messages that you would have gotten if you were to call DbgTraceGet() on line device 

    Params: phyCtrl: handle to phycontrol object
            msgList = Optional. This is a list of messages that should be parsed and the
               the rest should be ignored. This is done for giving
               debug trace parsing to customer (example: KR for Intel),
               without revealing too much.
               Example List: msgList = ['DGB_ID_KR_AN', 'DGB_ID_KR_PMD', 'DGB_ID_KR_PMD2']
    Return: [status, DecodedBuffer]
        status:  0:  Success
                 1 - parse error
                 2 - callback function error
        decodedMessage: Error messages and Decoded Messages

    Usage: 
    dbg = dbgtrace.DebugTrace(phyCtrl)
    Service this function in a loop similar to this below:
    [status, errMsg] = dbg.DbgTraceGetFromRawFile()
    if status != 0:
        print "Error: DbgTraceGetFromRawFile() returned error code:%d", status

"""
def DbgTraceGetFromRawFile(phyCtrl, aFile, msgList = None):
    fnName = sys._getframe().f_code.co_name

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
    vRawFileReader = vPhyCtrlData.RawFileReaderGet()
    
    vRawFileReader.FileOpen(phyCtrl, aFile)
    vRecords = vRawFileReader.RawRecordsGet()

    dbgPrint( gDebugVerbosityLevels["info"], fnName, ": Processing records ",
        "NumRecords: %s" % (len(vRecords))
        )

    #dump accumulated remainder data, if any
    #to guarantee we start processing from the first byte of the Raw file data   
    vPhyCtrlData.hostDebugTraceBufferReset()

    vDebugTraceResultDict = CDebugTraceResultDict()

    vAllDecodedMessages = ""
    statusParse = 0
    for vRecord in vRecords:
        vDebugTraceResultDict.ResultDictSet(vRecord)
        dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": Processing record: ",
            (str(vDebugTraceResultDict.ResultDictGet()))
            )
        [statusParse, decodedMessage, errMessageParse] = __DbgTraceParseRaw__(phyCtrl,vDebugTraceResultDict, msgList)
        if len(errMessageParse) > 0:   # Only if there is something to print. Else new lines need not be printed.
            decodedMessage = errMessageParse + "\n" + decodedMessage
        vAllDecodedMessages += decodedMessage
    
    return [statusParse, vAllDecodedMessages]


"""
__DbgTraceGetRaw__() is a debug message retrieval function. This is a simpler version of 
parseDebugTrace(), that returns human-readable messages from the Debug Buffer. 
Also it handles errors while retrieving the buffer.

    Params: phyCtrl: handle to phycontrol object
            printInfo: if host wants this function to print diagnostic messages or skip.
                Warning could be generated during overflow or error cases.
                Warning could also be generated when there is nothing in the buffer to retrieve. This gets noisy!
            freeze: Optional. If host wants to freeze/unfreeze buffer during capture.
            msgList = Optional. This is a list of messages that should be parsed and the
               the rest should be ignored. This is done for giving
               debug trace parsing to customer (example: KR for Intel),
               without revealing too much.
               Example List: msgList = ['DGB_ID_KR_AN', 'DGB_ID_KR_PMD', 'DGB_ID_KR_PMD2']
    Return: [status, DecodedBuffer]
        status:  0:  Success
                 1:  Reserved
                 2:  Warning: Overflow occurred, but DecodedBuffer still valid. Some traces may have been lost
                 3:  Warning: No available data in the buffer    
                 5:  Warning: resync was reported by the firmware, but DecodedBuffer still valid. Some traces may have been lost    
                -1:  Error: Freeze request was not granted by firmware
                     Empty Debug Buffer is returned
        DecodedBuffer: Decoded Messages. Only valid when status >= 0
                Empty DecodedBuffer is valid, if there were no messages found

    Usage: 
    dbg = dbgtrace.DebugTrace(phyCtrl)
    Service this function in a loop similar to this below:
        while True:
            [status, dbgBuffer, errMsg] = dbg.TraceGetRaw()
            if status < 0:
                print "Error: TraceGet() returned error code:%d", status
            elif len(dbgBuffer) > 0: 
                print msg
                
            else:
                print '.'
                
            time.sleep(1)
    

"""

def __DbgTraceGetRaw__(phyCtrl, printInfo=False, freeze=False):
    fnName = sys._getframe().f_code.co_name

    status = 0
    errMsg = ""
    dbgBuffer = []

    vDebugTraceResultDict = CDebugTraceResultDict()
    vResultDict = vDebugTraceResultDict.ResultDictGet()

    vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)

    #------------------------------------------------------------
    vGlobalMacControlRegister =  phyCtrl.pifReadData(CDbgTraceConsts.GlobalMacControl0RegisterAddr)
    vFirmwareLoaded = ( vGlobalMacControlRegister & CDbgTraceConsts.GlobalMacControl0RegisterFirmwareLoadedMask ) >> CDbgTraceConsts.GlobalMacControl0RegisterFirmwareLoadedShift
    if (vFirmwareLoaded == 0): 
        status = 3
        errMessage = "INFO: Could not extract trace. Firmware is currently reloading or have not yet been loaded.\n"
        errMsg += errMessage 
        dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
            errMessage
            )
        vResultDict["status"] = status 
        vResultDict["errMessages"] = errMsg
        return vDebugTraceResultDict

    #------------------------------------------------------------
    bytesToReadInFirmwareBuffer = __dbgBufferFirmwareBufferDepthGet__(phyCtrl)
    bytesToReadInHostBuffer = __dbgBufferHostBufferDepthGet__(phyCtrl)
    
    #------------------------------------------------------------
    #Issue data request if there isn't one pending already
    vRequestPending = vPhyCtrlData.requestPendingGet()
    vDataRequestTimeoutWhenDataIsAvailible = 0.050
    vDataRequestTimeout = 0
    if (vRequestPending == 0 ):

        #Issue request for data, if not already confirmed by previous requests
        #we don't want to request and lose data already in the host buffer
        __dbgBufferDataRequestSend__( phyCtrl )
        vPhyCtrlData.requestPendingSet(1)

        #Do we have data to extract?
        vDataAvailibleInFirmwareBuffer = (bytesToReadInFirmwareBuffer > 0)
        if (vDataAvailibleInFirmwareBuffer):
            #Data is available. Poll for a bit on first data request 
            vDataRequestTimeout = vDataRequestTimeoutWhenDataIsAvailible

    #------------------------------------------------------------
    vMaxTries = 2
    vNumTries = 0 
    while True:
        [confirmed, vDataRequestStatus, traceStatus, errMessage] = __dbgBufferCheckIfDataRequestGranted__( phyCtrl, vDataRequestTimeout )
        
        vResultDict["confirmed"] = confirmed 
        vResultDict["dataRequestStatus"] = vDataRequestStatus
        vResultDict["traceStatus"] = traceStatus
        errMsg += errMessage
        vResultDict["errMessages"] = errMsg
        
        if not confirmed:
            if (vDataRequestStatus == "init") or (vDataRequestStatus == "corruption"):
                #fw reinitialized or there is a corruption/unexpected status code 
                #clear whatever partial messages we have accumulated and request again

                #dump accumulated remainder data, if any.
                vPhyCtrlData.hostDebugTraceBufferReset()

                if (vDataRequestStatus == "corruption" ):
                    dbgPrint( gDebugVerbosityLevels["error"], fnName, ": ",
                        errMessage
                        )
                else:
                    if printInfo:
                        dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
                            errMessage
                            )

                dbgPrint( gDebugVerbosityLevels["info"], fnName, ": ",
                    "Re-issuing Data request"
                    )
                __dbgBufferDataRequestSend__( phyCtrl )
                vPhyCtrlData.requestPendingSet(1)

                vNumTries +=1 
                if vNumTries < vMaxTries:
                    bytesToReadInFirmwareBuffer = __dbgBufferFirmwareBufferDepthGet__(phyCtrl)
                    #Do we have data to extract?
                    vDataAvailibleInFirmwareBuffer = (bytesToReadInFirmwareBuffer > 0)
                    if (vDataAvailibleInFirmwareBuffer):
                        #Data is available. Poll for a bit on first data request 
                        vDataRequestTimeout = vDataRequestTimeoutWhenDataIsAvailible

                    continue # <<<< continue >>>>

                if (vDataRequestStatus == "corruption" ):
                    #corruption persists
                    status = -1 #error
                else:
                    status = 3 #no data. call back later
            else:
                status = 3 #no data. call back later

            vResultDict["status"] = status 
            vResultDict["errMessages"] = errMsg
            return vDebugTraceResultDict
        
        break # <<<< break >>>>

    #------------------------------------------------------------
    #Request for data has been confirmed by the firmware, extract the data
    vPhyCtrlData.requestPendingSet(0)

    #------------------------------------------------------------
    bytesToReadInFirmwareBuffer = __dbgBufferFirmwareBufferDepthGet__(phyCtrl)
    bytesToReadInHostBuffer = __dbgBufferHostBufferDepthGet__(phyCtrl)
    wordsInhostDebugTraceBuffer = vPhyCtrlData.hostDebugTraceBufferLenGet()
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": ",
        "phy: %s bytesToReadInHostBuffer: %s bytesToReadInFirmwareBuffer: %s wordsInhostDebugTraceBuffer: %s" % (phyCtrl, bytesToReadInHostBuffer, bytesToReadInFirmwareBuffer, wordsInhostDebugTraceBuffer)
        )
    
    vResponseFlags = ( traceStatus & CDbgTraceConsts.TraceDebugStatusFlagsMask ) >> CDbgTraceConsts.TraceDebugStatusFlagsShift  
    vResponseFieldInStatus = (traceStatus & CDbgTraceConsts.TraceDebugStatusMask) >> CDbgTraceConsts.TraceDebugStatusShift  
    #------------------------------------------------------------
    vStatusResync = ( 0
        or ((vResponseFlags & CDbgTraceConsts.TraceDebugStatusFlagDataGrantedWithResync) != 0)
        )
        
    if ( vStatusResync ):
        errMessage = 'WARNING: Debug Trace Buffer was reinitialized! TraceStatus: 0x%04x\n' % traceStatus
        #Printing of these warnings into errMsg is now done in __DbgTraceParseRaw__ 
        #errMsg += errMessage  
        dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
            errMessage
            )
        status = 5

    #------------------------------------------------------------
    vStatusOverflow = ( 0
        or ((vResponseFlags & CDbgTraceConsts.TraceDebugStatusFlagDataGrantedWithOverflow) != 0)
        or ((vResponseFieldInStatus & CDbgTraceConsts.TraceDebugStatusDataGrantedWithOverflow_Legacy) != 0)
        )
    if ( vStatusOverflow ):
        errMessage = 'WARNING: Debug Trace Buffer Overflow ! TraceStatus: 0x%04x\n' % traceStatus
        #Printing of these warnings into errMsg is now done in __DbgTraceParseRaw__ 
        #errMsg += errMessage  
        dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
            errMsg
            )
        status = 2

    #------------------------------------------------------------
    if (vStatusOverflow or vStatusResync):
        #dump accumulated remainder data on overflows and resyncs
        vPhyCtrlData.hostDebugTraceBufferReset()
    
    #------------------------------------------------------------
    # Freeze the Buffer, optional
    if freeze:
        [confirmed, status, traceStatus, errMessage] = __dbgBufferFreezeRequestSendAndPollForResponse__(phyCtrl)
        if not confirmed:
            errMessage += "ERROR: Request to Freeze Debug Buffer was not confirmed. TraceStatus:0x%04x\n" % (traceStatus)  
            errMsg += errMessage
            dbgPrint( gDebugVerbosityLevels["warning"], fnName, ": ",
                errMessage
                )
            __dbgBufferUnFreezeRequestSendAndPollForResponse__(phyCtrl)
            status = -1
            vResultDict["status"] = status 
            vResultDict["errMessages"] = errMsg
            return vDebugTraceResultDict
    
    #------------------------------------------------------------
    # Read the new data from host buffer
    lswAddr = phyCtrl.pifReadData(CDbgTraceConsts.HostBuffLswAddr)
    mswAddr = phyCtrl.pifReadData(CDbgTraceConsts.HostBuffMswAddr)
    hostBuffAddr = (lswAddr | (mswAddr << 16))

    bytesToRead = __dbgBufferHostBufferDepthGet__(phyCtrl)

    vResultDict["timestamp"] = time.time()
    
    dbgPrint( gDebugVerbosityLevels["verbose01"], fnName, ": Reading trace data. ",
        "phy: %s bytesToRead: %s" % (phyCtrl, bytesToRead)
        )
    # Read debug trace host buffer (short integers)
    dbgBuffer = phyCtrl.readProcessorMemoryAdv(hostBuffAddr, bytesToRead/2, 2) 

    #Store raw data 
    vResultDict["rawMessages"] = dbgBuffer
    vResultDict["status"] = status 
    vResultDict["errMessages"] = errMsg
    vResultDict["dbgRawRemainder"] = vPhyCtrlData.hostDebugTraceBufferGet()
    
    #------------------------------------------------------------
    #clear pending count after reading all data out
    phyCtrl.pifWriteData(CDbgTraceConsts.HostBuffByteLengthAddr,0)
    
    #------------------------------------------------------------
    # UnFreeze the Buffer, if frozen in the first place
    if freeze:
        __dbgBufferUnFreezeRequestSendAndPollForResponse__(phyCtrl)
    
    # For Debugging Only
    wordsToRead = phyCtrl.pifReadData(CDbgTraceConsts.TraceDebugBufferDepthAddr) / 2
    readIndex = phyCtrl.pifReadData(CDbgTraceConsts.TraceDebugBufferRdPtrAddr) / 2
    
    vResultDict["status"] = status 
    vResultDict["errMessages"] = errMsg
    
    return vDebugTraceResultDict

"""
__DbgTraceParseRaw__() is a debug message parser function. 
    It is part of the API that allows the user to work with RAW dbgtrace extracted from device 
    it returns human-readable messages from the Debug Buffer as well as the corresponding RAW data 

    Params: phyCtrl: handle to phycontrol object
            dbgBuffer: RAW debugbuffer data extracted from device using __DbgTraceGetRaw__() call
            msgList = Optional. This is a list of messages that should be parsed and the
               the rest should be ignored. This is done for giving
               debug trace parsing to customer (example: KR for Intel),
               without revealing too much.
               Example List: msgList = ['DGB_ID_KR_AN', 'DGB_ID_KR_PMD', 'DGB_ID_KR_PMD2']
    Return: [status, DecodedBuffer]
        status:  0:  Success
                 1 - parse error
                 2 - callback function error
        decodedMessage: Decoded Messages. Only valid when status >= 0
                Empty DecodedBuffer is valid, if there were no messages found
        errMsg: error messages captured during parsing

    Usage: 
    dbg = dbgtrace.DebugTrace(phyCtrl)
    Service this function in a loop similar to this below:
        while True:
            [status, dbgBuffer, errMsg] = dbg.__DbgTraceGetRaw__(phyCtrl)
            if status < 0:
                print "Error: __DbgTraceGetRaw__() returned error code:%d", status
                [status, decodedMessage, errMsg] = dbg.TraceParseRaw(phyCtrl,dbgBuffer)
                if status < 0:
                    print "Error: __DbgTraceParseRaw__() returned error code:%d", status
                elif len(decodedMessage) > 0: 
                    print decodedMessage
            else:
                print '.'
                
            time.sleep(1)
    

"""

def __DbgTraceParseRaw__(phyCtrl, aDebugTraceResultDict, msgList=None):
    fnName = sys._getframe().f_code.co_name

    #------------------------------------------------------------
    status = 0
    errMsg = ""
    traceStatus = 0
    decodedMessage = ""

    #------------------------------------------------------------
    vResultDict = aDebugTraceResultDict.ResultDictGet()

    vFoundRecord = 0
    if type(vResultDict) is dict:
        #We may have a record that appears valid. Go ahead with processing
        vFoundRecord = 1
    else:
        vFoundRecord = 0
        errMessage = 'WARNING: Skipping incorrectly formatted record: %s"' % vResultDict
        errMsg += errMessage  
        dbgPrint(gDebugVerbosityLevels["warning"], fnName, ": ",
            errMessage
            )
    #------------------------------------------------------------
    if vFoundRecord:

        if "traceStatus" in vResultDict:
            traceStatus = vResultDict["traceStatus"]
        else: 
            traceStatus = 0
            errMessage = 'WARNING: no \"traceStatus\" field found in the record. Assuming 0x0000: %s"' % vResultDict
            errMsg += errMessage  
            dbgPrint(gDebugVerbosityLevels["warning"], fnName, ": ",
                errMessage
                )

        #------------------------------------------------------------
        vResponseFlags = (traceStatus & CDbgTraceConsts.TraceDebugStatusFlagsMask) >> CDbgTraceConsts.TraceDebugStatusFlagsShift  
        vResponseFieldInStatus = (traceStatus & CDbgTraceConsts.TraceDebugStatusMask) >> CDbgTraceConsts.TraceDebugStatusShift  
        #------------------------------------------------------------
        vStatusResync = (0
            or ((vResponseFlags & CDbgTraceConsts.TraceDebugStatusFlagDataGrantedWithResync) != 0)
            )

        if (vStatusResync):
            errMessage = 'WARNING: Debug Trace Buffer was reinitialized! TraceStatus: 0x%04x\n' % traceStatus
            errMsg += errMessage  
            dbgPrint(gDebugVerbosityLevels["warning"], fnName, ": ",
                errMessage
                )

        #------------------------------------------------------------
        vStatusOverflow = (0
            or ((vResponseFlags & CDbgTraceConsts.TraceDebugStatusFlagDataGrantedWithOverflow) != 0)
            or ((vResponseFieldInStatus & CDbgTraceConsts.TraceDebugStatusDataGrantedWithOverflow_Legacy) != 0)
            )
        if (vStatusOverflow):
            errMessage = 'WARNING: Debug Trace Buffer Overflow ! TraceStatus: 0x%04x\n' % traceStatus
            errMsg += errMessage  
            dbgPrint(gDebugVerbosityLevels["warning"], fnName, ": ",
                errMsg
                )

        #------------------------------------------------------------
        vPhyCtrlData = gDebugTraceData.phyCtrlDataGet(phyCtrl)
        
        if (vStatusOverflow or vStatusResync):
            # dump accumulated remainder data on overflows and resyncs
            vPhyCtrlData.hostDebugTraceBufferReset()

        #------------------------------------------------------------
        vPhyCtrlData.hostDebugTraceBufferAdd(vResultDict["rawMessages"])
        
        dbgBuffer = []
        dbgBuffer = vPhyCtrlData.hostDebugTraceBufferGet() 

        if len(dbgBuffer) > 0: 
            dbgPrint(gDebugVerbosityLevels["verbose01"], fnName, ": Processing: ",
                vResultDict
                )

        # Decode the data from the host buffer
        [decodedMessage, rem, printStatus] = printTrace(phyCtrl, dbgBuffer, msgList)
        vResultDict["dbgRawRemainder"] = rem

        # Reinitialize the host trace buffer with left-over from the decode process
        vPhyCtrlData.hostDebugTraceBufferSet(rem)

        if len(rem) > 0:
            dbgPrint(gDebugVerbosityLevels["verbose01"], fnName, ": After printTrace remainder: ",
                rem
                )

        if printStatus != 0:
            errMessage = "Error: Parser Reported an error: %d\n" % printStatus  
            errMsg += errMessage
            dbgPrint(gDebugVerbosityLevels["warning"], fnName, ": ",
                errMessage
                )

            # Request the firmware to re-initialize the buffer
            __dbgBufferUnFreezeRequestSendAndPollForResponse__(phyCtrl)
            
            # dump accumulated remainder data on parsing error
            vPhyCtrlData.hostDebugTraceBufferReset()

            status = printStatus

        if len(dbgBuffer) > 0: 
            dbgPrint(gDebugVerbosityLevels["verbose01"], fnName, ": Processed: ",
                vResultDict
                )

    return [status, decodedMessage, errMsg]

#################################################################
#
# Message Parsing Functions
#
##

def formatMsgIndent():
    return '%10s' % ('')

def formatTimeStamp(time):
    return  str(time) + ' ms:'
    
def parseGfe(a) :

    p1 = a & 0xf
    p2 = (a >> 4) & 0xf
    p3 = (a >> 8) & 0xf
    p4 = (a >> 12) & 0xf

    bb = '%2d, %2d, %2d, %2d' %(p1, p2, p3, p4)
    return bb

def formatAecDlySearch(ch, dly, norm):
    normThreshold = 5000
    s = formatMsgIndent()
    s += 'AEC: ch=%d, dly=%d, norm=%d' % (ch, dly, norm)
    if(norm > normThreshold):
        s += ': Warning !!! AEC coeff norm exceeds threshold'
    return s
    
def formatCheckpoint(args):
    
    s = ""
    vNumArgs = 0
    if len(args) >= 1:
        # numArgs accounts for itself in the message(i.e. Message with zero arguments will have numArgs == 1)
        vNumArgs = args[0]
        
    if len(args) >= 3:
        s += '[ %s ] Checkpoint: ' % formatTimeStamp(getTime(args[1], args[2]))
    else:
        s += '[ Unknown ] Checkpoint: '
        
    if len(args) >= 4:
        for x in range(3,vNumArgs):
            s += ' 0x%04x' % (args[x])
    s += ' ['
    if len(args) >= 4:
        for x in range(3,vNumArgs):
            s += ' %d' % (args[x])
    s += ' ]'
    return s

def formatTimeGfeStamp(time):
    return  "%4d ms:" % time

def parseGeDebugInfo(timeArgOne, allStates, allPgas, adcOne, adcTwo, adcThree, adcFour, errorOne, errorTwo, errorThree, errorFour):
    
    stateOne = allStates & 0xf
    stateTwo = (allStates >> 4) & 0xf
    stateThree = (allStates >> 8) & 0xf
    stateFour = (allStates >> 12) & 0xf
    
    pgaOne = allPgas & 0xf
    pgaTwo = (allPgas >> 4) & 0xf
    pgaThree = (allPgas >> 8) & 0xf
    pgaFour = (allPgas >> 12) & 0xf
    
    linkStatus = errorFour & 0x3
    
    s = formatTimeGfeStamp(converTimeGfe(timeArgOne))
    s += ' (%2d,  %2d, %3d, %3d)' %(stateOne, pgaOne, adcOne, errorOne)
    s += ' (%2d,  %2d, %3d, %3d)' %(stateTwo, pgaTwo, adcTwo, errorTwo)
    s += ' (%2d,  %2d, %3d, %3d)' %(stateThree, pgaThree, adcThree, errorThree)
    s += ' (%2d,  %2d, %3d, %3d)' %(stateFour, pgaFour, adcFour, errorFour >> 2)
    
    s+= ' (%1d, %1d)' %((linkStatus & 1), ((linkStatus >> 1) & 1))
    
    return s
    
def parseGeDebugNonAq(a):
    msg = 'Non-AQ link partner. AQ is 1G-slave. Apply the new RDS filter. '
    
    tgeState = a & 0xf
    tgePga = (a >> 4) & 0xf
    tgeChannel = (a >> 8) & 0x3
    
    msg += 'ch: %d, st: %d, PGA: %d' %(tgeChannel, tgeState, tgePga)  
    
    return msg    

def formatMdix(dataOne):
    if (dataOne >= 5):
        semiCrossCounter = dataOne >> 3
        msg = 'initial semi cross counter = %d' %semiCrossCounter
    else :
        if (dataOne == 4):
            msg = ''   
            msg += '                Ch0                  Ch1                 Ch2                 Ch3         LinkSt\n'
            msg += '   Time: (ST, PGA, ADC, ERR) (ST, PGA, ADC, ERR) (ST, PGA, ADC, ERR) (ST, PGA, ADC, ERR) (L, R)'
        else :
            ab = (dataOne & 1)
            cd = ((dataOne >> 1) & 1)
            msg = 'mdix a-b:%d, c-d:%d' %(ab,cd)        

    return msg
    
def parseGfeTrainResult(a):
    if ((a & 1) == 0) :
        if ((a >> 1) == 0): 
            msg = 'IEEE Time Out!'
        if ((a >> 1) == 1):
            msg = 'Link Up Detected for the first time!' 
    else :
        if ((a >> 1) == 0): 
            msg = 'gfe Train announces link is down!'
        if ((a >> 1) == 1):
            msg = 'gfe Train announces link is up!' 
        if ((a >> 1) == 2):
            msg = 'gfe Train announces link is aborted!'
        if ((a >> 1) == 3):
            msg = 'gfe Train announces link down with no signal detected.!'    
    return msg 

def converTimeGfe(a):
    b = int(round(a*1.0/78.125))
    return b 

def parseGeSlicerResult(t, a, b):
    msg = ''
    msecounts = [a & 31, a >> 5, (b >> 1) & 31, b >> 6]
    countThreshold = (t>>8) & 0xFF
    mseThreshold = t & 0xFF

    for m in msecounts:
        if (m > countThreshold):
            msg += 'MSE Threshold FAILURE !!! \n'
            break
    
    msg += 'MSE thresholds (mse, counter) = (%d, %d) \n' % (mseThreshold, countThreshold)        
    msg += 'MSE counter = [%2d, %2d, %2d, %2d]' %(msecounts[0], msecounts[1], msecounts[2], msecounts[3])    
    
    return msg

def ipPhoneParseMessage(aLsb, aMsb, bLsb, bMsb, cLsb):
    msg = 'Ip phone detected! '
    msg += 'crL: %d, ' %(aLsb + (aMsb << 16))
    msg += 'crM: %d, ' %(bLsb + (bMsb << 16))
    msg += 'crH: %d' %cLsb
    return msg    


def rateTransitionParseMessage(dutRateRequest, lkpRateRequest, resolvedRate):
    
    rateTranTable = ['Continue',
                     'Reserved 0',
                     'Reserved 1',
                     'Retrain 10G',
                     'Retrain 5G',
                     'Retrain 2.5G',
                     'Retrain 1G',
                     'Reserved 2']
    
    msg = 'Rate Trans: DUT = %s, LKP = %s, Resolved Rate = %s' % (rateTranTable[dutRateRequest], rateTranTable[lkpRateRequest], rates[resolvedRate])
    
    return msg

def freqOffSetGe(sdmOffset, picOffsetLsw, picOffsetMsw):
    msg = ''

    sdmScale = 0.0238
    #picScale = 1.192 # EUROPA
    picScale = 1.192 / 256 # EUROPA C

    sdmOffset = unsigned2signed(sdmOffset, 16)
    sdmPpm = sdmScale * sdmOffset
    picOffset = picOffsetLsw + (picOffsetMsw << 16)
    picOffset = unsigned2signed(picOffset, 32)
    picPpm = picOffset * picScale
        
    msg += 'SDM-LSB: %d, PPM acquired: %2.2f\n' % (sdmOffset, sdmPpm)
    
    msg += formatMsgIndent()
    
    msg += 'PICFreqOffset-LSB: %d, PPM acquired: %2.2f\n' % (picOffset, picPpm)

    msg += formatMsgIndent()    

    totalPpm = sdmPpm + picPpm
    msg += 'Total acquired PPM: %2.2f' %totalPpm    
    return msg 

def txDacValueChange(a): 
    dacValue = a >> 8    
    temperature = a & 0xff
    if (temperature >= 128):
        temperature -= 256
    msg = 'Temperature: %d, Tx Dac value: %d' %(temperature, dacValue)
    return msg

def ipPhoneDebugParse(txRx, crLLsb, crLMsb, crMLsb, crMMsb, crHLsb, crHMsb, totalPowerLsb, totalPowerMsb, diffPowerLsb, diffPowerMsb):
    msg = ''
    tx = txRx & 0x3
    rx = (txRx >> 2) & 0x3    
    msg += 'tx: %d, rx: %d, ' %(tx, rx)
    
    crL = crLLsb + (crLMsb << 16)
    crM = crMLsb + (crMMsb << 16)
    crH = crHLsb + (crHMsb << 16)
    msg += 'CR = [%d, %d, %d]\n' %(crL, crM, crH)
    
    totalPower = totalPowerLsb + (totalPowerMsb << 16)
    msg += 'total-power = %d\n' %totalPower
    
    diffPower = diffPowerLsb + (diffPowerMsb << 16)
    if (diffPower > (2**31 -1)):
        diffPower -= (2**32)
    msg += 'power-difference = %d\n' %diffPower    
    
    return msg    

def snrCalc(aNumerator, aDenominator):
    vSnr = 0
    if (aDenominator):
        vSnr = 10*math.log10(float(aNumerator)/float(aDenominator))
    return vSnr
    
def formatRate(rate):
    return anegRates[rate]

def formatSerdesMode(serdesMode):
    return sdModes[serdesMode]
    
def formatEnableDisable(enable):
    if (enable):
        return 'ENABLE'
    else:
        return 'DISABLE'
        
def formatRateAdaptation(rateAdaptation):
    return rateAdaptationModes[rateAdaptation]
    
def formatLoopback(loopbackType):
    return sysLoopbacks[loopbackType]
    
def formatTestMode(testMode):
    return systemInterfaceTestModes[testMode]
    
def formatPktGen(packetGenType):
    if(packetGenType == eSIF_PACKET_GEN_SYSTEM):
        return  'SYSTEM SIDE'
    elif(packetGenType == eSIF_PACKET_GEN_LOOKASIDE):
        return  'LOOKASIDE SIDE'
    elif(packetGenType == eSIF_PACKET_GEN_MDI):
        return  'MDI SIDE'
    elif(packetGenType == eSIF_PACKET_GEN_OFF):
        return 'OFF'
    else:
        return 'Invalid'

def formatTrueFalse(value):
    if(value):
        return 'TRUE'
    else:
        return 'FALSE'
        
def formatSysState(value):
    return sysState[value]

    
#--------------------------------------------------------------------
#global objects
gDebugTraceData=CDebugTraceData()

"""
dbghelper.py: Anil: Dec13: Removing standalone support, since the contents of this file 
are included (pasted) into dbgtrace.py.
"""



######### END of contents from dbghelper.py ###############

def _DBG_ID_PRINTF(arg):
    result = list2str(arg[1:])
    return result


msgIds = [
    (7, 'DBG_ID_TIME_STAMP', "%s%2d: %5d %4.1f %4.1f %4.1f %4.1f %7.2f\n"),
    (1, 'DBG_ID_FAILURE', "%sFailure = %s\n"),
    (1, 'DBG_ID_LINKSTATUS', '%sLink Status = %s\n'),
    (3, 'DBG_ID_LNKRECOVERY', "%s\n%s%s Link Recovery\n"),
    (6, 'DBG_ID_TRAININGTYPE', "%s\n"),
    (3, 'DBG_ID_MDIO_EVENT', "%s\n%sMdio Event = %s\n"),
    (3, 'DBG_ID_GLB_FAULT', "%s\n%sGlobal Fault = %s\n"),
    (3, 'DBG_ID_PHY_STATE', "%s\n"),
    (3, 'DBG_ID_ANEG_STATE', "%s\n"),
    (4, 'DBG_ID_ANEG_PAGE', "Aneg Page: %s\n"),
    (2, 'DBG_ID_ANEG_INFO', "%sAutoneg: %s\n"),
    (3, 'DBG_ID_ANEG_INFO_2', "%sAutoneg: %s\n"),
    (4, 'DBG_ID_ANEG_INFO_3', "%sAutoneg: %s\n"),
    (3, 'DBG_ID_FREQ_OFFSET', "%s %s\n"),
    (1, 'DBG_ID_CDR_SOURCE', "%sCdr source channel = %d\n"),
    (6, 'DBG_ID_CDR_SOURCE_SWITCH', "%s\n%sNew cdr source channel = %d, snr = %5.2fdB. Old cdr source channel = %d, snr = %5.2fdB\n"),
    (11, 'DBG_ID_FILTERSCALE', "%s%s ch %d: num = %d, den = %d, target = %d\n%sTxGain %5d %5d, RxGain %5d %5d, RxMag = %5d %5d\n"),
    (3, 'DBG_ID_DFE_COEF', "%sDFE for ch %d tap no %d = %d\n"),
    (3, 'DBG_ID_THP_COEF', "%sTHP for ch %d tap no %d = %d\n"),
    (0, 'DBG_ID_PRINTF', _DBG_ID_PRINTF),
    (5, 'DBG_ID_SIF_CLK_MUX_INFO', "xauiRx_125MhzClockEnable    = %d\nusxClockMuxSelect           = %d\nsecClockMuxSelection        = %d\nxgsReferenceClockMuxSelect  = %d\nxgsClockSelect              = %d\n"),
    (6, 'DGB_ID_KR_EXT', "%s\n"),
    (6, 'DGB_ID_KR_INT', "%s\n"),
    (11, 'DBG_ID_XFI_CNTR', "XFI_%d - (%05d) Interval: %d_msec\nTKL good count - 0x%04X_%04X\nTKL error count- 0x%04X_%04X\nRKL good count - 0x%04X_%04X\nRKL error count- 0x%04X_%04X\n"),
    (10, 'DBG_ID_PCS_CNTR', "PCS - (%05d) Interval: %d_msec\nTPL good count - 0x%04X_%04X\nTPL error count- 0x%04X_%04X\nRPL good count - 0x%04X_%04X\nRPL error count- 0x%04X_%04X\n"),
    (5, 'DBG_ID_SERDES_EYE_DIAG', "Serdes Eye - %d:\n  Right:0x%04X, Left:0x%04X, Top:0x%04X, Bottom:0x%04X\n"),
    (3, 'DBG_ID_SERDES_WR_TOUT', "Warning: No Write Ack from Vsemi reg(%d) = %d after %d cycles\n"),
    (2, 'DBG_ID_SERDES_RD_TOUT', "Warning: No Read Ack from Vsemi reg(%d) after %d cycles\n"),
    (4, 'DBG_ID_VSEMI_BIT_RD', " vsemiBitRead(0x%01x, d%d, 0x%02x) = 0x%02x\n"),
    (4, 'DBG_ID_VSEMI_BIT_WR', "vsemiBitWrite(0x%01x, d%d, 0x%02x) = 0x%02x\n"),
    (6, 'DBG_ID_GFE_100M', "%s PGA = %s, AIF-POWER= %5d, %5d, %5d, %5d\n"),
    (11, 'DBG_ID_GFE_GE', "%s\n"),
    (1, 'DBG_ID_GFE_MDI', "%s\n"),
    (2, 'DBG_ID_GFE_RESULT', "%s %s\n"),
    (3, 'DBG_ID_GFE_SLC', "%s\n"),
    (4, 'DBG_ID_SYS_TRANSITION', "%s\n"),
    (5, 'DBG_ID_SYS_MSG', "%s\n"),
    (3, 'DBG_ID_XGS_SWITCHOVER', "%s\n"),
    (5, 'DBG_ID_SIF_USX_ANEG', "%s\n"),
    (4, 'DBG_ID_USX', "%s\n"),
    (8, 'DBG_ID_SYS_MGR_RESET', "%s\n"),
    (9, 'DBG_ID_ALARM_XFI0', "Alarm:\n04.CC01: 0x%04X\n03.CC03: 0x%04X\n03.CC07: 0x%04X\n03.E864: 0x%04X\n03.E865: 0x%04X\n03.E869: 0x%04X\n03.EC05: 0x%04X\n03.EC06: 0x%04X\n03.EC0D: 0x%04X\n"),
    (9, 'DBG_ID_ALARM_XFI1', "Alarm:\n04.CC01: 0x%04X\n03.CC03: 0x%04X\n03.CC07: 0x%04X\n03.E874: 0x%04X\n03.E875: 0x%04X\n03.E879: 0x%04X\n03.EC05: 0x%04X\n03.EC06: 0x%04X\n03.EC0E: 0x%04X\n"),
    (3, 'DBG_ID_CHK_STATUS', "%s%s\n"),
    (2, 'DBG_ID_CHK_STATUS_STAMP', "%sAlarm Check:\n"),
    (5, 'DBG_ID_SEGMENT_POWERDOWN', "Ch%1d %s S%d out. SN=%d AN=%d\n"),
    (6, 'DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN', "%s\nSNR %5.2f %5.2f %5.2f %5.2f\n"),
    (6, 'DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN_MSGTYPE1', "%s\nSNR %5.2f %5.2f %5.2f %5.2f\n"),
    (3, 'DBG_ID_NUMBER_OF_SEGMENTS_OPTIMIZED', "Segments:\nOut=%d MaxAllowed=%d Total=%d\n"),
    (8, 'DBG_ID_POWER_GATED_SEGMENTS', "Ch%d fir power masks:\nDEC=%04x\nNEC0=%01x NEC1=%01x NEC2=%01x\nFEC0=%01x FEC1=%01x FEC2=%01x\n"),
    (5, 'DBG_ID_IP_PHONE', "%s\n"),
    (11, 'DBG_ID_IP_PHONE_DEBUG', "%s\n"),
    (1, 'DBG_ID_LDPC_AVG_ITERATIONS', "ldpc-avg-iterations = %6.4f\n"),
    (3, 'DBG_ID_SEGMENT_RESTORE', "Ch%1d %s S%d power restored\n"),
    (3, 'DBG_ID_RATE_TRAN_RES', "%s%s\n"),
    (0, 'DBG_ID_RATE_TRAN_ERR', "%sRate Trans info not received \n"),
    (5, 'DBG_ID_CHECKLINK', "CheckLink %d: AvgLdpc = %5.2f Thresh = %5.2f ErrFrames = %d CRC8 = %d\n"),
    (6, 'DBG_ID_LINK_DOWN_STATUS', "%s Link Down: HB=%d BL=%d PCS=%d RPL=%d\n"),
    (4, 'DBG_ID_LDPC_EVENT', "%s LDPCErr: %d CrcErr: %d\n"),
    (2, 'DBG_ID_ACTIVE_LKP', "%s\n%s Active Link Partner Detected\n"),
    (2, 'DBG_ID_CABLE_CODE', "%s Cable Code = %d, Cable Length = %d m \n"),
    (2, 'DBG_ID_BOOST', "%s Boost ch%d = %d\n"),
    (1, 'DBG_ID_TX_SLW_HOLD', "%s TX Slw Rate Hold is changed %d\n"),
    (3, 'DBG_ID_DAC_VALUE_TEMP_CAL', "%s\n%s%s\n"),
    (1, 'DBG_ID_ANEG_STATUS', "%s%s\n"),
    (1, 'DBG_ID_LINK_DOWN_LDPC_ITERATION', "Link Down  due to high average max ldpc iteration = %4.2f \n"),
    (3, 'DBG_ID_LKP_PBO_PBOADJUST', "Request %d more power from lkp, Pbo = %d, PboAdjust= %d \n"),
    (3, 'DBG_ID_DUT_PBO_PBOADJUST', "lkp requested %d more power, Pbo = %d, PboAdjust= %d \n"),
    (5, 'DBG_ID_SEGMENT_POWERDOWN_REVERTED', "Reverted *** : Ch%1d %s S%d in. SN=%d AN=%d\n"),
    (0, 'DBG_ID_SEGMENT_OPTIMIZATION_WARNING1', "Warning !! Exiting without doing segment optimization due to uncorrected LDPC frames or CRC8 errors\n"),
    (1, 'DBG_ID_LDPC_AVG_ITERATIONS_MSGTYPE1', "ldpc-avg-iterations = %6.4f\n"),
    (2, 'DBG_ID_AFE_SHORT', "Threshold code: %d, cable code: %d, apply afe short settings for 10G\n"),
    (1, 'DBG_ID_AFE_MID_SWITCH', "Calibrated midswitch value is: %d\n"),
    (2, 'DBG_ID_FFE_MRVL', "TGE FFE shift change for non-aquantia at PGA = %d. Threshold = %d\n"),
    (1, 'DBG_ID_TX_MISALIGNMENT', "TX Misalignment enabled on line %d\n"),
    (0, 'DBG_ID_TR_DISTURB_STARTED', "TR changes has been started\n"),
    (0, 'DBG_ID_TR_DISTURB_FINISHED', "TR changes has been finished\n"),
    (4, 'DBG_ID_TONE_GENERATION_STARTED', "%s\n Tone Generation started on ch%d\n with frequency index=%d (%.2f Mhz)\n"),
    (2, 'DBG_ID_TONE_GENERATION_STOPPED', "%s\n Tone Generation stopped\n"),
    (5, 'DBG_ID_TONE_DETECTIED', "%s\n Tone detection power on ch%d\n with frequency index=%d (%.2f Mhz) is %d * 0.5 dBm\n"),
    (14, 'DBG_ID_SYS_INIT', "%s\n System side init configuration:\n rate=%s serdesMode=%s\n autoneg=%s training=%s\n reset=%s serdesSilence=%s\n rateAdaptation=%s security=%s\n ptp=%s loopback=%s\n testMode=%s pktGen=%s\n"),
    (3, 'DBG_ID_SYS_USX_MODE_INITIALIZATION', "%s\n USX mode initialization for rate=%s\n"),
    (3, 'DBG_ID_SYS_XFI_MODE_INITIALIZATION', "%s\n XFI mode initialization for rate=%s\n"),
    (3, 'DBG_ID_SYS_SGMII_MODE_INITIALIZATION', "%s\n SGMII mode initialization for rate=%s\n"),
    (3, 'DBG_ID_SYS_OCSGMII_MODE_INITIALIZATION', "%s\n OCSGMII mode initialization for rate=%s\n"),
    (3, 'DBG_ID_SYS_MACSEC_INITIALIZATION', "%s\n MACSEC initialization for rate=%s\n"),
    (3, 'DBG_ID_SYS_MACSEC_HEADER_BRINGUP', "%s\n Bringingup MACSEC header and initializing it for rate=%s\n"),
    (2, 'DBG_ID_SYS_MACSEC_HEADER_SHUTDOWN', "%s\n Shutting down MACSEC header\n"),
    (3, 'DBG_ID_SERDES_INITIALIZATION', "%s\n Serdes initialization for serdesMode=%s\n"),
    (2, 'DBG_ID_SYS_TX_TRANSITIONED_UP', "%s\n System interface TX transitioned from DOWN to UP\n"),
    (2, 'DBG_ID_SYS_TX_TRANSITIONED_DOWN', "%s\n System interface TX transitioned from UP to DOWN\n"),
    (4, 'DBG_ID_SYS_RX_LINK_TRANSITIONED_UP', "%s\n System interface RX transitioned from DOWN to UP\n linkUp=%s sdCalDone=%s.\n"),
    (4, 'DBG_ID_SYS_RX_LINK_TRANSITIONED_DOWN', "%s\n System interface RX transitioned from UP to DOWN\n linkUp=%s.\n"),
    (4, 'DBG_ID_SYS_AUTONEG_STARTED', "%s\n System interface Autoneg started\n     Rate=%s, autoneg codeWord=0x%x\n"),
    (4, 'DBG_ID_MSM_SYS_TRANSITION', "%s\n MSM SYS transition TX=%s, RX=%s\n"),
    (4, 'DBG_ID_MSM_LINE_TRANSITION', "%s\n MSM LINE transition TX=%s, RX=%s\n"),
    (3, 'DBG_ID_PTP_ENABLE', "%s\n PTP = %s\n"),
    (6, 'DBG_ID_GENERAL_LOOPBACK', "%s\n Processing loopback request:\n Previous:=%s %s\n New=%s %s\n"),
    (4, 'DBG_ID_GENERAL_LOOPBACK_UNSUPPORTED', "%s\n Error : Unsupported loopback:\n %s %s\n"),
    (6, 'DBG_ID_PACKET_GENERATION', "%s\n Processing packet generation request:\n Previous:=%s %s\n New=%s %s\n"),
    (4, 'DBG_ID_SYS_LINK_DOWN', "%s\n System side link is down. LinkUp[%d] SigDetect[%d] Reinitializing...\n"),
    (3, 'DBG_ID_SYS_SERDES_STATUS_FAIL', "%s\n Serdes status = 0x%x. Reinitializing...\n"),
    (3, 'DBG_ID_SYS_ANEG_STATUS_FAIL', "%s\n SYS Aneg status = %s. Reinitializing...\n"),
    (4, 'DBG_ID_SYS_PACKET_GENERATION_UNSUPPORTED', "%s\n Error : Unsupported packet generation:\n %s %s\n"),
    (4, 'DBG_ID_SYS_PACKET_GENERATION_PARAMS', "%s\n New packet generation direction=%s rate=%s\n"),
    (4, 'DBG_ID_SYS_LOOPBACK_PARAMS', "%s\n New Loopback type=%s rate=%s\n"),
    (4, 'DBG_ID_SYS_STATE_TRANSITION', "%s\nSSM [%s]->[%s]\n"),
    (4, 'DBG_ID_SD_AN_TR_STATE_TRANSITION', "%s\nSD Aneg/Trng SMC: [%s]->[%s]\n"),
    (4, 'DBG_ID_SYS_RA_ANEG_STATE_TRANSITION', "%s\nSYS RA Aneg SMC: [%s]->[%s]\n"),
    (2, 'DBG_ID_SYS_STATE_MACHINE_TIMEOUT', "%s\n***** System side state machine timed out *****\n"),
    (2, 'DBG_ID_SYS_LINK_UP', "%s\n System side link is Up. Entering link Monitoring state\n"),
    (2, 'DBG_ID_SYS_STATE_SIGNAL_DETECT_MISSING', "%s\n Serdes Signal Detect missing. Resetting the SYS state machine\n"),
    (3, 'DBG_ID_SYS_SERDES_EQUALIZATION_FAIL', "%s\n Serdes calibration failed for %d time(s). Retrying...\n"),
    (2, 'DBG_ID_SYS_SERDES_CALIBRATION_TIMEOUT', "%s\n##### serdes calibration timed out #####\n"),
    (4, 'DBG_ID_SYS_SERDES_TX_STATUS', "%s\nSerdes TX %d -> %d\n"),
    (3, 'DBG_ID_AEC_DELAY_SEARCH', "%s\n"),
    (2, 'DBG_ID_TX_LPI_IN', "%s Tx LPI In\n"),
    (2, 'DBG_ID_TX_LPI_OUT', "%s Tx LPI Out\n"),
    (2, 'DBG_ID_RX_LPI_IN', "%s Rx LPI In\n"),
    (2, 'DBG_ID_RX_LPI_OUT', "%s Rx LPI Out\n"),
    (1, 'DBG_ID_EEE_LINK_FAIL', "Link Failed, Force Rx/Tx out, refFail=%d\n"),
    (2, 'DBG_ID_USM_HANDSHAKE_FAIL', "USM Handshake failed at address: 0x%08X, mask: 0x%04X\n"),
    (2, 'DBG_ID_USM_POST_HANDSHAKE_FAIL', "USM Handshake zero check failed at address: 0x%08X, mask: 0x%04X\n"),
    (1, 'DBG_ID_CHECKPOINT', "%s\n"),
    (1, 'DBG_ID_REFRAME', "Reframe Link Status = %d\n"),
    (2, 'DBG_ID_ANEG_POST_TRAINING', "%s\n"),
    (0, 'DBG_ID_SMB0_ENTERED_ISR', "Entered SMB0 ISR.\n"),
    (0, 'DBG_ID_SMB0_IDLE_READMODE', "SMB0_STATE_IDLE: slaveReadMode\nSMB0_STATE_IDLE: Receive Byte command sequence not implemented.\n"),
    (1, 'DBG_ID_SMB0_IDLE_TO_EXPECTINGCC', "SMB0_STATE_IDLE --> SMB0_STATE_EXPECTING_CC (SMBus device addr 0x%X) (args[0])\n"),
    (0, 'DBG_ID_SMB0_IDLE_BADADDRESS', "SMB0_STATE_IDLE: !slaveAddressDetectedBit\n"),
    (1, 'DBG_ID_SMB0_EXPECTINGCC_TO_AFTERCC', "SMB0_STATE_EXPECTING_CC --> SMB0_STATE_AFTER_CC (command code 0x%X)\n"),
    (1, 'DBG_ID_SMB0_AFTERCC_READ', "SMB0_STATE_AFTER_CC: read- Sending 0x%X\n"),
    (0, 'DBG_ID_SMB0_AFTERCC_TO_AFTERREAD', "SMB0_STATE_AFTER_CC --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n"),
    (0, 'DBG_ID_SMB0_AFTERCC_RSANDWRITE', "SMB0_STATE_AFTER_CC: repeatedStart AND !slaveReadMode\nSMB0_STATE_AFTER_CC: invalid command sequence\nSMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n"),
    (3, 'DBG_ID_SFP_AFTERCC_WRITE', "SFP write- setting SMBus device 0x%X addr 0x%X to 0x%X\n"),
    (0, 'DBG_ID_SMB0_AFTERCC_TO_IDLE', "SMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n"),
    (1, 'DBG_ID_SMB0_AFTERREAD_READ', "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE: block read- Sending 0x%X\n"),
    (0, 'DBG_ID_SMB0_AFTERREAD_TO_AFTERREAD', "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n"),
    (0, 'DBG_ID_SMB0_AFTERREAD_TO_IDLE', "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_IDLE\n"),
    (0, 'DBG_ID_SMB0_NOALARM', "SMB0_ISR !interruptAlarmBit\n"),
    (1, 'DBG_ID_SMB0_TIMEOUT', "SMB0 state machine timeout, in state: %d\nState #%d --> SMB0_STATE_IDLE\n"),
    (0, 'DBG_ID_SMB0_CALLBACKS_NOT_SET', "SMB0_ISR Callback functions not registered.\n"),
    (1, 'DBG_ID_SFP_FLASHLOAD_A0_FAILED', "SFP-DDMI: Loading A0 memory map values from FLASH failed with code: %d.\n"),
    (1, 'DBG_ID_SFP_FLASHLOAD_A2_FAILED', "SFP-DDMI: Loading A2 memory map values from FLASH failed with code: %d.\n"),
    (1, 'DBG_ID_SFP_FLASHSTORE_A2_FAILED', "SFP-DDMI: Storing user-writeable A2 memory map values to FLASH failed with code: %d.\n"),
    (2, 'DBG_ID_INFOEXCHANGE_TIMEOUT', "%s Info Exchange Time Out. Elapsed = %d > TimeOut = %d\n"),
    (0, 'DBG_ID_INFOEXCHANGE_ABORTED', "%s Info Exchange aborted. Transition count detected\n"),
    (0, 'DBG_ID_AUTHENTICATION_FAILED', "Authentication FAILED\n"),
    (1, 'DBG_ID_USM_XGEINIT', "Load USM Master=%d\n"),
    (0, 'DBG_ID_USM_LOAD_TGE', "Load TGE USM\n"),
    (0, 'DBG_ID_USM_LOAD_ERROR', "USM Load ERROR\n"),
    (12, 'DBG_ID_USM_INIT_PAIR_INFO', "RxPhys A/B/C/D on %d,%d,%d,%d;\nTxPhys A/B/C/D on %d,%d,%d,%d;\ninvABCD=%d%d%d%d\n"),
    (6, 'DBG_ID_USM_TGE_DBG_INFO', "USM: state = %d, clock = %d, enable = %d, stall = %d, halt = %d PC = %d\n"),
    (0, 'DBG_ID_TDE_ERROR_CHANGE_PHASE', "SHS: noticed the tdeErr going to change the phase\n"),
    (0, 'DBG_ID_TDE_ERROR_POST_PHASE_CHANGE', "SHS: ERROR: there was a tde Err even after phase change fixes\n"),
    (1, 'DBG_ID_TX_QUANTIZATION', "   Warning: TX DAC Left Shift %d\n"),
    (8, 'DBG_ID_AFO_OFFSET_CANCEL_MESSAGE', "Offsets_afo: %4d %4d %4d %4d aif: %4d %4d %4d %4d\n"),
    (2, 'DBG_ID_PHY_BAUD_CONSTEL_INVALID_CONFIG', "ERROR: phyBaudConstellationSet: Unknown configuration baud=%d; constellation= %d\n"),
    (6, 'DBG_ID_LINK_FAULT_CODE', "%s Fault Set: L.Fault[%x] Rx.Fault[%x] LINT[%x] Sig.Type[%x]\n"),
    (3, 'DBG_ID_SD_RX_EQ_CAL', "RX EQ CAL: curr state: %d; next state: %d (%d)\n"),
    (2, 'DBG_ID_INFO_ABILITY_PAGE_RX', "%sINFO Ability Page Received: 0x%02X%02X\n"),
    (2, 'DBG_ID_INFO_SWAP_PAGE_RX', "%sINFO Swap Page Logical %s %s %s %s\n"),
    (4, 'DBG_ID_TX_CONSTELLATIONS', "%sTX Cnstl Physical: %s %s %s %s \n"),
    (4, 'DBG_ID_RX_CONSTELLATIONS', "%sRX Cnstl Physical: %s %s %s %s \n"),
    (4, 'DBG_ID_SYS_REINIT_DUE_TO_MACSEC_FC_OVERFLOW', "%s\n MACSEC FC overflow. Reinitializing...\n  egressFifoOverFlowStatus = %d, ingressFifoOverFlowStatus = %d \n"),
    (4, 'DBG_ID_RAD_INFO', "RAD: active=%d, channel logical=%d phys=%d, invert=%d\n"),
    (1, 'DBG_ID_SERDES_LOS_FILTER', "serdes los filer enable = %d\n"),
    (3, 'DBG_ID_EEE_FFE_CHAN', "%s EEE FFE channel switched to: %d\n"),
    (0, 'DBG_NUM_ID_MSGS', ""),
]



def DBG_ID_TIME_STAMP(args):
    numargs = 7
    format  = "%s%2d: %5d %4.1f %4.1f %4.1f %4.1f %7.2f\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0], args[1], snrCalc(85*512.0,args[2]), snrCalc(85*512.0,args[3]), snrCalc(85*512.0,args[4]), snrCalc(85*512.0,args[5]), unsigned2signed(args[6], 16)/(5*8.4))

    return result
    # end of function DBG_ID_TIME_STAMP

def DBG_ID_FAILURE(args):
    numargs = 1
    format  = "%sFailure = %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), failureCodes[args[0]])

    return result
    # end of function DBG_ID_FAILURE

def DBG_ID_LINKSTATUS(args):
    numargs = 1
    format  = '%sLink Status = %s\n'
    result  = str()
    result  += format % (formatMsgIndent(), linkStatus[args[0]])

    return result
    # end of function DBG_ID_LINKSTATUS

def DBG_ID_LNKRECOVERY(args):
    numargs = 3
    format  = "%s\n%s%s Link Recovery\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatMsgIndent(), LnktrainingType[args[2]])

    return result
    # end of function DBG_ID_LNKRECOVERY

def DBG_ID_TRAININGTYPE(args):
    numargs = 6
    format  = "%s\n"
    result  = str()
    result  += format % (formatTrainingTypeMsg(args[0], args[1], args[2], args[3], args[4], args[5]))

    return result
    # end of function DBG_ID_TRAININGTYPE

def DBG_ID_MDIO_EVENT(args):
    numargs = 3
    format  = "%s\n%sMdio Event = %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatMsgIndent(), mdioEvents[args[2]])

    return result
    # end of function DBG_ID_MDIO_EVENT

def DBG_ID_GLB_FAULT(args):
    numargs = 3
    format  = "%s\n%sGlobal Fault = %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0],  args[1])), formatMsgIndent(), faults[args[2]])

    return result
    # end of function DBG_ID_GLB_FAULT

def DBG_ID_PHY_STATE(args):
    numargs = 3
    format  = "%s\n"
    result  = str()
    result  += format % (formatPhyStateMsg(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_PHY_STATE

def DBG_ID_ANEG_STATE(args):
    numargs = 3
    format  = "%s\n"
    result  = str()
    result  += format % (formatAutonegMsg(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_ANEG_STATE

def DBG_ID_ANEG_PAGE(args):
    numargs = 4
    format  = "Aneg Page: %s\n"
    result  = str()
    result  += format % (anegPage(args[0], args[1], args[2], args[3]))

    return result
    # end of function DBG_ID_ANEG_PAGE

def DBG_ID_ANEG_INFO(args):
    numargs = 2
    format  = "%sAutoneg: %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), formatAnegInfoMsg(args[0], args[1]))

    return result
    # end of function DBG_ID_ANEG_INFO

def DBG_ID_ANEG_INFO_2(args):
    numargs = 3
    format  = "%sAutoneg: %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), formatAnegInfoMsg_2(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_ANEG_INFO_2

def DBG_ID_ANEG_INFO_3(args):
    numargs = 4
    format  = "%sAutoneg: %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), formatAnegInfoMsg_3(args[0], args[1], args[2], args[3]))

    return result
    # end of function DBG_ID_ANEG_INFO_3

def DBG_ID_FREQ_OFFSET(args):
    numargs = 3
    format  = "%s %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), freqOffSetGe(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_FREQ_OFFSET

def DBG_ID_CDR_SOURCE(args):
    numargs = 1
    format  = "%sCdr source channel = %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0])

    return result
    # end of function DBG_ID_CDR_SOURCE

def DBG_ID_CDR_SOURCE_SWITCH(args):
    numargs = 6
    format  = "%s\n%sNew cdr source channel = %d, snr = %5.2fdB. Old cdr source channel = %d, snr = %5.2fdB\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatMsgIndent(), args[2], (float(args[3])-0x8000)/10.0, args[4], (float(args[5])-0x8000)/10.0)

    return result
    # end of function DBG_ID_CDR_SOURCE_SWITCH

def DBG_ID_FILTERSCALE(args):
    numargs = 11
    format  = "%s%s ch %d: num = %d, den = %d, target = %d\n%sTxGain %5d %5d, RxGain %5d %5d, RxMag = %5d %5d\n"
    result  = str()
    result  += format % (formatMsgIndent(), filters[args[0]], args[1], args[2], args[3], args[4], formatMsgIndent(), args[5], args[6], args[7], args[8], args[9], args[10])

    return result
    # end of function DBG_ID_FILTERSCALE

def DBG_ID_DFE_COEF(args):
    numargs = 3
    format  = "%sDFE for ch %d tap no %d = %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), tuple(args))

    return result
    # end of function DBG_ID_DFE_COEF

def DBG_ID_THP_COEF(args):
    numargs = 3
    format  = "%sTHP for ch %d tap no %d = %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), tuple(args))

    return result
    # end of function DBG_ID_THP_COEF

def DBG_ID_PRINTF(args):
    numargs = 0
    return _DBG_ID_PRINTF(args)
    # end of function DBG_ID_PRINTF

def DBG_ID_SIF_CLK_MUX_INFO(args):
    numargs = 5
    format  = "xauiRx_125MhzClockEnable    = %d\nusxClockMuxSelect           = %d\nsecClockMuxSelection        = %d\nxgsReferenceClockMuxSelect  = %d\nxgsClockSelect              = %d\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4])

    return result
    # end of function DBG_ID_SIF_CLK_MUX_INFO

def DGB_ID_KR_EXT(args):
    numargs = 6
    format  = "%s\n"
    result  = str()
    result  += format % (formatKrMsgExternal(args[0], args[1], args[2], args[3], args[4], args[5]))

    return result
    # end of function DGB_ID_KR_EXT

def DGB_ID_KR_INT(args):
    numargs = 6
    format  = "%s\n"
    result  = str()
    result  += format % (formatKrMsgInternal(args[0], args[1], args[2], args[3], args[4], args[5]))

    return result
    # end of function DGB_ID_KR_INT

def DBG_ID_XFI_CNTR(args):
    numargs = 11
    format  = "XFI_%d - (%05d) Interval: %d_msec\nTKL good count - 0x%04X_%04X\nTKL error count- 0x%04X_%04X\nRKL good count - 0x%04X_%04X\nRKL error count- 0x%04X_%04X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10])

    return result
    # end of function DBG_ID_XFI_CNTR

def DBG_ID_PCS_CNTR(args):
    numargs = 10
    format  = "PCS - (%05d) Interval: %d_msec\nTPL good count - 0x%04X_%04X\nTPL error count- 0x%04X_%04X\nRPL good count - 0x%04X_%04X\nRPL error count- 0x%04X_%04X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9])

    return result
    # end of function DBG_ID_PCS_CNTR

def DBG_ID_SERDES_EYE_DIAG(args):
    numargs = 5
    format  = "Serdes Eye - %d:\n  Right:0x%04X, Left:0x%04X, Top:0x%04X, Bottom:0x%04X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4])

    return result
    # end of function DBG_ID_SERDES_EYE_DIAG

def DBG_ID_SERDES_WR_TOUT(args):
    numargs = 3
    format  = "Warning: No Write Ack from Vsemi reg(%d) = %d after %d cycles\n"
    result  = str()
    result  += format % (args[0], args[1], args[2])

    return result
    # end of function DBG_ID_SERDES_WR_TOUT

def DBG_ID_SERDES_RD_TOUT(args):
    numargs = 2
    format  = "Warning: No Read Ack from Vsemi reg(%d) after %d cycles\n"
    result  = str()
    result  += format % (args[0], args[1])

    return result
    # end of function DBG_ID_SERDES_RD_TOUT

def DBG_ID_VSEMI_BIT_RD(args):
    numargs = 4
    format  = " vsemiBitRead(0x%01x, d%d, 0x%02x) = 0x%02x\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3])

    return result
    # end of function DBG_ID_VSEMI_BIT_RD

def DBG_ID_VSEMI_BIT_WR(args):
    numargs = 4
    format  = "vsemiBitWrite(0x%01x, d%d, 0x%02x) = 0x%02x\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3])

    return result
    # end of function DBG_ID_VSEMI_BIT_WR

def DBG_ID_GFE_100M(args):
    numargs = 6
    format  = "%s PGA = %s, AIF-POWER= %5d, %5d, %5d, %5d\n"
    result  = str()
    result  += format % (formatTimeGfeStamp(converTimeGfe(args[0])), parseGfe(args[1]), args[2], args[3], args[4], args[5])

    return result
    # end of function DBG_ID_GFE_100M

def DBG_ID_GFE_GE(args):
    numargs = 11
    format  = "%s\n"
    result  = str()
    result  += format % (parseGeDebugInfo(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]))

    return result
    # end of function DBG_ID_GFE_GE

def DBG_ID_GFE_MDI(args):
    numargs = 1
    format  = "%s\n"
    result  = str()
    result  += format % (formatMdix(args[0]))

    return result
    # end of function DBG_ID_GFE_MDI

def DBG_ID_GFE_RESULT(args):
    numargs = 2
    format  = "%s %s\n"
    result  = str()
    result  += format % (formatTimeGfeStamp(converTimeGfe(args[0])), parseGfeTrainResult(args[1]))

    return result
    # end of function DBG_ID_GFE_RESULT

def DBG_ID_GFE_SLC(args):
    numargs = 3
    format  = "%s\n"
    result  = str()
    result  += format % (parseGeSlicerResult(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_GFE_SLC

def DBG_ID_SYS_TRANSITION(args):
    numargs = 4
    format  = "%s\n"
    result  = str()
    result  += format % (formatSysTransition(args[0], args[1], args[2], args[3]))

    return result
    # end of function DBG_ID_SYS_TRANSITION

def DBG_ID_SYS_MSG(args):
    numargs = 5
    format  = "%s\n"
    result  = str()
    result  += format % (formatSysSmcMsg(args[0], args[1], args[2], args[3], args[4]))

    return result
    # end of function DBG_ID_SYS_MSG

def DBG_ID_XGS_SWITCHOVER(args):
    numargs = 3
    format  = "%s\n"
    result  = str()
    result  += format % (formatSysXgsSwitchover(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_XGS_SWITCHOVER

def DBG_ID_SIF_USX_ANEG(args):
    numargs = 5
    format  = "%s\n"
    result  = str()
    result  += format % (formatSysUsxAnegDebug(args[0], args[1], args[2], args[3], args[4]))

    return result
    # end of function DBG_ID_SIF_USX_ANEG

def DBG_ID_USX(args):
    numargs = 4
    format  = "%s\n"
    result  = str()
    result  += format % (formatUSXMsg(args[0], args[1], args[2], args[3]))

    return result
    # end of function DBG_ID_USX

def DBG_ID_SYS_MGR_RESET(args):
    numargs = 8
    format  = "%s\n"
    result  = str()
    result  += format % (formatSysMgr(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]))

    return result
    # end of function DBG_ID_SYS_MGR_RESET

def DBG_ID_ALARM_XFI0(args):
    numargs = 9
    format  = "Alarm:\n04.CC01: 0x%04X\n03.CC03: 0x%04X\n03.CC07: 0x%04X\n03.E864: 0x%04X\n03.E865: 0x%04X\n03.E869: 0x%04X\n03.EC05: 0x%04X\n03.EC06: 0x%04X\n03.EC0D: 0x%04X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])

    return result
    # end of function DBG_ID_ALARM_XFI0

def DBG_ID_ALARM_XFI1(args):
    numargs = 9
    format  = "Alarm:\n04.CC01: 0x%04X\n03.CC03: 0x%04X\n03.CC07: 0x%04X\n03.E874: 0x%04X\n03.E875: 0x%04X\n03.E879: 0x%04X\n03.EC05: 0x%04X\n03.EC06: 0x%04X\n03.EC0E: 0x%04X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])

    return result
    # end of function DBG_ID_ALARM_XFI1

def DBG_ID_CHK_STATUS(args):
    numargs = 3
    format  = "%s%s\n"
    result  = str()
    result  += format % (formatMsgIndent(), formatChkStatus(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_CHK_STATUS

def DBG_ID_CHK_STATUS_STAMP(args):
    numargs = 2
    format  = "%sAlarm Check:\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_CHK_STATUS_STAMP

def DBG_ID_SEGMENT_POWERDOWN(args):
    numargs = 5
    format  = "Ch%1d %s S%d out. SN=%d AN=%d\n"
    result  = str()
    result  += format % (args[0], filters[args[1]], args[2], unsigned2signed(args[3], 16), unsigned2signed(args[4], 16))

    return result
    # end of function DBG_ID_SEGMENT_POWERDOWN

def DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN(args):
    numargs = 6
    format  = "%s\nSNR %5.2f %5.2f %5.2f %5.2f\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), snrCalc(85*512.0,args[2]), snrCalc(85*512.0,args[3]), snrCalc(85*512.0,args[4]), snrCalc(85*512.0,args[5]))

    return result
    # end of function DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN

def DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN_MSGTYPE1(args):
    numargs = 6
    format  = "%s\nSNR %5.2f %5.2f %5.2f %5.2f\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), snrCalc(85*512.0,args[2]), snrCalc(85*512.0,args[3]), snrCalc(85*512.0,args[4]), snrCalc(85*512.0,args[5]))

    return result
    # end of function DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN_MSGTYPE1

def DBG_ID_NUMBER_OF_SEGMENTS_OPTIMIZED(args):
    numargs = 3
    format  = "Segments:\nOut=%d MaxAllowed=%d Total=%d\n"
    result  = str()
    result  += format % (args[0], args[1], args[2])

    return result
    # end of function DBG_ID_NUMBER_OF_SEGMENTS_OPTIMIZED

def DBG_ID_POWER_GATED_SEGMENTS(args):
    numargs = 8
    format  = "Ch%d fir power masks:\nDEC=%04x\nNEC0=%01x NEC1=%01x NEC2=%01x\nFEC0=%01x FEC1=%01x FEC2=%01x\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])

    return result
    # end of function DBG_ID_POWER_GATED_SEGMENTS

def DBG_ID_IP_PHONE(args):
    numargs = 5
    format  = "%s\n"
    result  = str()
    result  += format % (ipPhoneParseMessage(args[0], args[1], args[2], args[3], args[4]))

    return result
    # end of function DBG_ID_IP_PHONE

def DBG_ID_IP_PHONE_DEBUG(args):
    numargs = 11
    format  = "%s\n"
    result  = str()
    result  += format % (ipPhoneDebugParse(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]))

    return result
    # end of function DBG_ID_IP_PHONE_DEBUG

def DBG_ID_LDPC_AVG_ITERATIONS(args):
    numargs = 1
    format  = "ldpc-avg-iterations = %6.4f\n"
    result  = str()
    result  += format % (args[0]/256.0)

    return result
    # end of function DBG_ID_LDPC_AVG_ITERATIONS

def DBG_ID_SEGMENT_RESTORE(args):
    numargs = 3
    format  = "Ch%1d %s S%d power restored\n"
    result  = str()
    result  += format % (args[0], filters[args[1]], args[2])

    return result
    # end of function DBG_ID_SEGMENT_RESTORE

def DBG_ID_RATE_TRAN_RES(args):
    numargs = 3
    format  = "%s%s\n"
    result  = str()
    result  += format % (formatMsgIndent(), rateTransitionParseMessage(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_RATE_TRAN_RES

def DBG_ID_RATE_TRAN_ERR(args):
    numargs = 0
    format  = "%sRate Trans info not received \n"
    result  = str()
    result  += format % (formatMsgIndent())

    return result
    # end of function DBG_ID_RATE_TRAN_ERR

def DBG_ID_CHECKLINK(args):
    numargs = 5
    format  = "CheckLink %d: AvgLdpc = %5.2f Thresh = %5.2f ErrFrames = %d CRC8 = %d\n"
    result  = str()
    result  += format % (args[0], args[1]/4096.0, args[2]/4096.0, args[3], args[4])

    return result
    # end of function DBG_ID_CHECKLINK

def DBG_ID_LINK_DOWN_STATUS(args):
    numargs = 6
    format  = "%s Link Down: HB=%d BL=%d PCS=%d RPL=%d\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3], args[4], args[5])

    return result
    # end of function DBG_ID_LINK_DOWN_STATUS

def DBG_ID_LDPC_EVENT(args):
    numargs = 4
    format  = "%s LDPCErr: %d CrcErr: %d\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3])

    return result
    # end of function DBG_ID_LDPC_EVENT

def DBG_ID_ACTIVE_LKP(args):
    numargs = 2
    format  = "%s\n%s Active Link Partner Detected\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatMsgIndent())

    return result
    # end of function DBG_ID_ACTIVE_LKP

def DBG_ID_CABLE_CODE(args):
    numargs = 2
    format  = "%s Cable Code = %d, Cable Length = %d m \n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0],args[1])

    return result
    # end of function DBG_ID_CABLE_CODE

def DBG_ID_BOOST(args):
    numargs = 2
    format  = "%s Boost ch%d = %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0], args[1])

    return result
    # end of function DBG_ID_BOOST

def DBG_ID_TX_SLW_HOLD(args):
    numargs = 1
    format  = "%s TX Slw Rate Hold is changed %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0])

    return result
    # end of function DBG_ID_TX_SLW_HOLD

def DBG_ID_DAC_VALUE_TEMP_CAL(args):
    numargs = 3
    format  = "%s\n%s%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatMsgIndent(), txDacValueChange(args[2]))

    return result
    # end of function DBG_ID_DAC_VALUE_TEMP_CAL

def DBG_ID_ANEG_STATUS(args):
    numargs = 1
    format  = "%s%s\n"
    result  = str()
    result  += format % (formatMsgIndent(), formatAnegStatus(args[0]))

    return result
    # end of function DBG_ID_ANEG_STATUS

def DBG_ID_LINK_DOWN_LDPC_ITERATION(args):
    numargs = 1
    format  = "Link Down  due to high average max ldpc iteration = %4.2f \n"
    result  = str()
    result  += format % (args[0]/256.0)

    return result
    # end of function DBG_ID_LINK_DOWN_LDPC_ITERATION

def DBG_ID_LKP_PBO_PBOADJUST(args):
    numargs = 3
    format  = "Request %d more power from lkp, Pbo = %d, PboAdjust= %d \n"
    result  = str()
    result  += format % ( args[0],args[1],args[2])

    return result
    # end of function DBG_ID_LKP_PBO_PBOADJUST

def DBG_ID_DUT_PBO_PBOADJUST(args):
    numargs = 3
    format  = "lkp requested %d more power, Pbo = %d, PboAdjust= %d \n"
    result  = str()
    result  += format % ( args[0],args[1],args[2])

    return result
    # end of function DBG_ID_DUT_PBO_PBOADJUST

def DBG_ID_SEGMENT_POWERDOWN_REVERTED(args):
    numargs = 5
    format  = "Reverted *** : Ch%1d %s S%d in. SN=%d AN=%d\n"
    result  = str()
    result  += format % (args[0], filters[args[1]], args[2], unsigned2signed(args[3], 16), unsigned2signed(args[4], 16))

    return result
    # end of function DBG_ID_SEGMENT_POWERDOWN_REVERTED

def DBG_ID_SEGMENT_OPTIMIZATION_WARNING1(args):
    numargs = 0
    format  = "Warning !! Exiting without doing segment optimization due to uncorrected LDPC frames or CRC8 errors\n"
    result  = str()
    tempstr = formatstr("Warning !! Exiting without doing segment optimization due to uncorrected LDPC frames or CRC8 errors\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SEGMENT_OPTIMIZATION_WARNING1

def DBG_ID_LDPC_AVG_ITERATIONS_MSGTYPE1(args):
    numargs = 1
    format  = "ldpc-avg-iterations = %6.4f\n"
    result  = str()
    result  += format % (args[0]/256.0)

    return result
    # end of function DBG_ID_LDPC_AVG_ITERATIONS_MSGTYPE1

def DBG_ID_AFE_SHORT(args):
    numargs = 2
    format  = "Threshold code: %d, cable code: %d, apply afe short settings for 10G\n"
    result  = str()
    result  += format % (args[0],args[1])

    return result
    # end of function DBG_ID_AFE_SHORT

def DBG_ID_AFE_MID_SWITCH(args):
    numargs = 1
    format  = "Calibrated midswitch value is: %d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_AFE_MID_SWITCH

def DBG_ID_FFE_MRVL(args):
    numargs = 2
    format  = "TGE FFE shift change for non-aquantia at PGA = %d. Threshold = %d\n"
    result  = str()
    result  += format % (args[0], args[1])

    return result
    # end of function DBG_ID_FFE_MRVL

def DBG_ID_TX_MISALIGNMENT(args):
    numargs = 1
    format  = "TX Misalignment enabled on line %d\n"
    result  = str()
    tempstr = formatstr("TX Misalignment enabled on line %d\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_TX_MISALIGNMENT

def DBG_ID_TR_DISTURB_STARTED(args):
    numargs = 0
    format  = "TR changes has been started\n"
    result  = str()
    tempstr = formatstr("TR changes has been started\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_TR_DISTURB_STARTED

def DBG_ID_TR_DISTURB_FINISHED(args):
    numargs = 0
    format  = "TR changes has been finished\n"
    result  = str()
    tempstr = formatstr("TR changes has been finished\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_TR_DISTURB_FINISHED

def DBG_ID_TONE_GENERATION_STARTED(args):
    numargs = 4
    format  = "%s\n Tone Generation started on ch%d\n with frequency index=%d (%.2f Mhz)\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3], args[3]*400.0/512)

    return result
    # end of function DBG_ID_TONE_GENERATION_STARTED

def DBG_ID_TONE_GENERATION_STOPPED(args):
    numargs = 2
    format  = "%s\n Tone Generation stopped\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_TONE_GENERATION_STOPPED

def DBG_ID_TONE_DETECTIED(args):
    numargs = 5
    format  = "%s\n Tone detection power on ch%d\n with frequency index=%d (%.2f Mhz) is %d * 0.5 dBm\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3], args[3]*400.0/512, unsigned2signed(args[4], 16))

    return result
    # end of function DBG_ID_TONE_DETECTIED

def DBG_ID_SYS_INIT(args):
    numargs = 14
    format  = "%s\n System side init configuration:\n rate=%s serdesMode=%s\n autoneg=%s training=%s\n reset=%s serdesSilence=%s\n rateAdaptation=%s security=%s\n ptp=%s loopback=%s\n testMode=%s pktGen=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]), formatSerdesMode(args[3]), formatEnableDisable(args[4]), formatEnableDisable(args[5]),  formatEnableDisable(args[6]), formatEnableDisable(args[7]), formatRateAdaptation(args[8]), formatEnableDisable(args[9]), formatEnableDisable(args[10]), formatLoopback(args[11]), formatTestMode(args[12]), formatPktGen(args[13]))

    return result
    # end of function DBG_ID_SYS_INIT

def DBG_ID_SYS_USX_MODE_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n USX mode initialization for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_USX_MODE_INITIALIZATION

def DBG_ID_SYS_XFI_MODE_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n XFI mode initialization for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_XFI_MODE_INITIALIZATION

def DBG_ID_SYS_SGMII_MODE_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n SGMII mode initialization for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_SGMII_MODE_INITIALIZATION

def DBG_ID_SYS_OCSGMII_MODE_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n OCSGMII mode initialization for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_OCSGMII_MODE_INITIALIZATION

def DBG_ID_SYS_MACSEC_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n MACSEC initialization for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_MACSEC_INITIALIZATION

def DBG_ID_SYS_MACSEC_HEADER_BRINGUP(args):
    numargs = 3
    format  = "%s\n Bringingup MACSEC header and initializing it for rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]))

    return result
    # end of function DBG_ID_SYS_MACSEC_HEADER_BRINGUP

def DBG_ID_SYS_MACSEC_HEADER_SHUTDOWN(args):
    numargs = 2
    format  = "%s\n Shutting down MACSEC header\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_MACSEC_HEADER_SHUTDOWN

def DBG_ID_SERDES_INITIALIZATION(args):
    numargs = 3
    format  = "%s\n Serdes initialization for serdesMode=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatSerdesMode(args[2]))

    return result
    # end of function DBG_ID_SERDES_INITIALIZATION

def DBG_ID_SYS_TX_TRANSITIONED_UP(args):
    numargs = 2
    format  = "%s\n System interface TX transitioned from DOWN to UP\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_TX_TRANSITIONED_UP

def DBG_ID_SYS_TX_TRANSITIONED_DOWN(args):
    numargs = 2
    format  = "%s\n System interface TX transitioned from UP to DOWN\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_TX_TRANSITIONED_DOWN

def DBG_ID_SYS_RX_LINK_TRANSITIONED_UP(args):
    numargs = 4
    format  = "%s\n System interface RX transitioned from DOWN to UP\n linkUp=%s sdCalDone=%s.\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatTrueFalse(args[2]), formatTrueFalse(args[3]))

    return result
    # end of function DBG_ID_SYS_RX_LINK_TRANSITIONED_UP

def DBG_ID_SYS_RX_LINK_TRANSITIONED_DOWN(args):
    numargs = 4
    format  = "%s\n System interface RX transitioned from UP to DOWN\n linkUp=%s.\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatTrueFalse(args[2]))

    return result
    # end of function DBG_ID_SYS_RX_LINK_TRANSITIONED_DOWN

def DBG_ID_SYS_AUTONEG_STARTED(args):
    numargs = 4
    format  = "%s\n System interface Autoneg started\n     Rate=%s, autoneg codeWord=0x%x\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]), args[3])

    return result
    # end of function DBG_ID_SYS_AUTONEG_STARTED

def DBG_ID_MSM_SYS_TRANSITION(args):
    numargs = 4
    format  = "%s\n MSM SYS transition TX=%s, RX=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatEnableDisable(args[2]), formatEnableDisable(args[3]))

    return result
    # end of function DBG_ID_MSM_SYS_TRANSITION

def DBG_ID_MSM_LINE_TRANSITION(args):
    numargs = 4
    format  = "%s\n MSM LINE transition TX=%s, RX=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatEnableDisable(args[2]), formatEnableDisable(args[3]))

    return result
    # end of function DBG_ID_MSM_LINE_TRANSITION

def DBG_ID_PTP_ENABLE(args):
    numargs = 3
    format  = "%s\n PTP = %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatEnableDisable(args[2]))

    return result
    # end of function DBG_ID_PTP_ENABLE

def DBG_ID_GENERAL_LOOPBACK(args):
    numargs = 6
    format  = "%s\n Processing loopback request:\n Previous:=%s %s\n New=%s %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[3]), formatLoopback(args[2]), formatRate(args[5]), formatLoopback(args[4]))

    return result
    # end of function DBG_ID_GENERAL_LOOPBACK

def DBG_ID_GENERAL_LOOPBACK_UNSUPPORTED(args):
    numargs = 4
    format  = "%s\n Error : Unsupported loopback:\n %s %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[3]), formatLoopback(args[2]))

    return result
    # end of function DBG_ID_GENERAL_LOOPBACK_UNSUPPORTED

def DBG_ID_PACKET_GENERATION(args):
    numargs = 6
    format  = "%s\n Processing packet generation request:\n Previous:=%s %s\n New=%s %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]), formatPktGen(args[3]), formatRate(args[4]), formatPktGen(args[5]))

    return result
    # end of function DBG_ID_PACKET_GENERATION

def DBG_ID_SYS_LINK_DOWN(args):
    numargs = 4
    format  = "%s\n System side link is down. LinkUp[%d] SigDetect[%d] Reinitializing...\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3])

    return result
    # end of function DBG_ID_SYS_LINK_DOWN

def DBG_ID_SYS_SERDES_STATUS_FAIL(args):
    numargs = 3
    format  = "%s\n Serdes status = 0x%x. Reinitializing...\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2])

    return result
    # end of function DBG_ID_SYS_SERDES_STATUS_FAIL

def DBG_ID_SYS_ANEG_STATUS_FAIL(args):
    numargs = 3
    format  = "%s\n SYS Aneg status = %s. Reinitializing...\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), sysAnegStatus[args[2]])

    return result
    # end of function DBG_ID_SYS_ANEG_STATUS_FAIL

def DBG_ID_SYS_PACKET_GENERATION_UNSUPPORTED(args):
    numargs = 4
    format  = "%s\n Error : Unsupported packet generation:\n %s %s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatRate(args[2]), formatPktGen(args[3]))

    return result
    # end of function DBG_ID_SYS_PACKET_GENERATION_UNSUPPORTED

def DBG_ID_SYS_PACKET_GENERATION_PARAMS(args):
    numargs = 4
    format  = "%s\n New packet generation direction=%s rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatPktGen(args[2]), formatRate(args[3]))

    return result
    # end of function DBG_ID_SYS_PACKET_GENERATION_PARAMS

def DBG_ID_SYS_LOOPBACK_PARAMS(args):
    numargs = 4
    format  = "%s\n New Loopback type=%s rate=%s\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatLoopback(args[2]), formatRate(args[3]))

    return result
    # end of function DBG_ID_SYS_LOOPBACK_PARAMS

def DBG_ID_SYS_STATE_TRANSITION(args):
    numargs = 4
    format  = "%s\nSSM [%s]->[%s]\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), formatSysState(args[2]), formatSysState(args[3]))

    return result
    # end of function DBG_ID_SYS_STATE_TRANSITION

def DBG_ID_SD_AN_TR_STATE_TRANSITION(args):
    numargs = 4
    format  = "%s\nSD Aneg/Trng SMC: [%s]->[%s]\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), sdAnegTrngState[args[2]], sdAnegTrngState[args[3]])

    return result
    # end of function DBG_ID_SD_AN_TR_STATE_TRANSITION

def DBG_ID_SYS_RA_ANEG_STATE_TRANSITION(args):
    numargs = 4
    format  = "%s\nSYS RA Aneg SMC: [%s]->[%s]\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), sysRateAdaptAnegState[args[2]], sysRateAdaptAnegState[args[3]])

    return result
    # end of function DBG_ID_SYS_RA_ANEG_STATE_TRANSITION

def DBG_ID_SYS_STATE_MACHINE_TIMEOUT(args):
    numargs = 2
    format  = "%s\n***** System side state machine timed out *****\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_STATE_MACHINE_TIMEOUT

def DBG_ID_SYS_LINK_UP(args):
    numargs = 2
    format  = "%s\n System side link is Up. Entering link Monitoring state\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_LINK_UP

def DBG_ID_SYS_STATE_SIGNAL_DETECT_MISSING(args):
    numargs = 2
    format  = "%s\n Serdes Signal Detect missing. Resetting the SYS state machine\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_STATE_SIGNAL_DETECT_MISSING

def DBG_ID_SYS_SERDES_EQUALIZATION_FAIL(args):
    numargs = 3
    format  = "%s\n Serdes calibration failed for %d time(s). Retrying...\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2])

    return result
    # end of function DBG_ID_SYS_SERDES_EQUALIZATION_FAIL

def DBG_ID_SYS_SERDES_CALIBRATION_TIMEOUT(args):
    numargs = 2
    format  = "%s\n##### serdes calibration timed out #####\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_SYS_SERDES_CALIBRATION_TIMEOUT

def DBG_ID_SYS_SERDES_TX_STATUS(args):
    numargs = 4
    format  = "%s\nSerdes TX %d -> %d\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])),  args[2], args[3])

    return result
    # end of function DBG_ID_SYS_SERDES_TX_STATUS

def DBG_ID_AEC_DELAY_SEARCH(args):
    numargs = 3
    format  = "%s\n"
    result  = str()
    result  += format % (formatAecDlySearch(args[0], args[1], args[2]))

    return result
    # end of function DBG_ID_AEC_DELAY_SEARCH

def DBG_ID_TX_LPI_IN(args):
    numargs = 2
    format  = "%s Tx LPI In\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_TX_LPI_IN

def DBG_ID_TX_LPI_OUT(args):
    numargs = 2
    format  = "%s Tx LPI Out\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_TX_LPI_OUT

def DBG_ID_RX_LPI_IN(args):
    numargs = 2
    format  = "%s Rx LPI In\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_RX_LPI_IN

def DBG_ID_RX_LPI_OUT(args):
    numargs = 2
    format  = "%s Rx LPI Out\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])))

    return result
    # end of function DBG_ID_RX_LPI_OUT

def DBG_ID_EEE_LINK_FAIL(args):
    numargs = 1
    format  = "Link Failed, Force Rx/Tx out, refFail=%d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_EEE_LINK_FAIL

def DBG_ID_USM_HANDSHAKE_FAIL(args):
    numargs = 2
    format  = "USM Handshake failed at address: 0x%08X, mask: 0x%04X\n"
    result  = str()
    result  += format % (args[0], args[1])

    return result
    # end of function DBG_ID_USM_HANDSHAKE_FAIL

def DBG_ID_USM_POST_HANDSHAKE_FAIL(args):
    numargs = 2
    format  = "USM Handshake zero check failed at address: 0x%08X, mask: 0x%04X\n"
    result  = str()
    result  += format % (args[0], args[1])

    return result
    # end of function DBG_ID_USM_POST_HANDSHAKE_FAIL

def DBG_ID_CHECKPOINT(args):
    numargs = 1
    format  = "%s\n"
    result  = str()
    result  += format % (formatCheckpoint(args))

    return result
    # end of function DBG_ID_CHECKPOINT

def DBG_ID_REFRAME(args):
    numargs = 1
    format  = "Reframe Link Status = %d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_REFRAME

def DBG_ID_ANEG_POST_TRAINING(args):
    numargs = 2
    format  = "%s\n"
    result  = str()
    result  += format % (formatAnegInfo_PostTraining(args[0], args[1]))

    return result
    # end of function DBG_ID_ANEG_POST_TRAINING

def DBG_ID_SMB0_ENTERED_ISR(args):
    numargs = 0
    format  = "Entered SMB0 ISR.\n"
    result  = str()
    tempstr = formatstr("Entered SMB0 ISR.\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_ENTERED_ISR

def DBG_ID_SMB0_IDLE_READMODE(args):
    numargs = 0
    format  = "SMB0_STATE_IDLE: slaveReadMode\nSMB0_STATE_IDLE: Receive Byte command sequence not implemented.\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_IDLE: slaveReadMode\nSMB0_STATE_IDLE: Receive Byte command sequence not implemented.\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_IDLE_READMODE

def DBG_ID_SMB0_IDLE_TO_EXPECTINGCC(args):
    numargs = 1
    format  = "SMB0_STATE_IDLE --> SMB0_STATE_EXPECTING_CC (SMBus device addr 0x%X) (args[0])\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_IDLE --> SMB0_STATE_EXPECTING_CC (SMBus device addr 0x%X) (args[0])\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_IDLE_TO_EXPECTINGCC

def DBG_ID_SMB0_IDLE_BADADDRESS(args):
    numargs = 0
    format  = "SMB0_STATE_IDLE: !slaveAddressDetectedBit\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_IDLE: !slaveAddressDetectedBit\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_IDLE_BADADDRESS

def DBG_ID_SMB0_EXPECTINGCC_TO_AFTERCC(args):
    numargs = 1
    format  = "SMB0_STATE_EXPECTING_CC --> SMB0_STATE_AFTER_CC (command code 0x%X)\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SMB0_EXPECTINGCC_TO_AFTERCC

def DBG_ID_SMB0_AFTERCC_READ(args):
    numargs = 1
    format  = "SMB0_STATE_AFTER_CC: read- Sending 0x%X\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SMB0_AFTERCC_READ

def DBG_ID_SMB0_AFTERCC_TO_AFTERREAD(args):
    numargs = 0
    format  = "SMB0_STATE_AFTER_CC --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_AFTER_CC --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_AFTERCC_TO_AFTERREAD

def DBG_ID_SMB0_AFTERCC_RSANDWRITE(args):
    numargs = 0
    format  = "SMB0_STATE_AFTER_CC: repeatedStart AND !slaveReadMode\nSMB0_STATE_AFTER_CC: invalid command sequence\nSMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_AFTER_CC: repeatedStart AND !slaveReadMode\nSMB0_STATE_AFTER_CC: invalid command sequence\nSMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_AFTERCC_RSANDWRITE

def DBG_ID_SFP_AFTERCC_WRITE(args):
    numargs = 3
    format  = "SFP write- setting SMBus device 0x%X addr 0x%X to 0x%X\n"
    result  = str()
    result  += format % (args[0], args[1], args[2])

    return result
    # end of function DBG_ID_SFP_AFTERCC_WRITE

def DBG_ID_SMB0_AFTERCC_TO_IDLE(args):
    numargs = 0
    format  = "SMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_AFTER_CC --> SMB0_STATE_IDLE\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_AFTERCC_TO_IDLE

def DBG_ID_SMB0_AFTERREAD_READ(args):
    numargs = 1
    format  = "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE: block read- Sending 0x%X\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SMB0_AFTERREAD_READ

def DBG_ID_SMB0_AFTERREAD_TO_AFTERREAD(args):
    numargs = 0
    format  = "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_AFTERREAD_TO_AFTERREAD

def DBG_ID_SMB0_AFTERREAD_TO_IDLE(args):
    numargs = 0
    format  = "SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_IDLE\n"
    result  = str()
    tempstr = formatstr("SMB0_STATE_AFTER_READ_BYTE_DATA_BYTE --> SMB0_STATE_IDLE\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_AFTERREAD_TO_IDLE

def DBG_ID_SMB0_NOALARM(args):
    numargs = 0
    format  = "SMB0_ISR !interruptAlarmBit\n"
    result  = str()
    tempstr = formatstr("SMB0_ISR !interruptAlarmBit\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_NOALARM

def DBG_ID_SMB0_TIMEOUT(args):
    numargs = 1
    format  = "SMB0 state machine timeout, in state: %d\nState #%d --> SMB0_STATE_IDLE\n"
    result  = str()
    result  += format % (args[0], args[0])

    return result
    # end of function DBG_ID_SMB0_TIMEOUT

def DBG_ID_SMB0_CALLBACKS_NOT_SET(args):
    numargs = 0
    format  = "SMB0_ISR Callback functions not registered.\n"
    result  = str()
    tempstr = formatstr("SMB0_ISR Callback functions not registered.\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_SMB0_CALLBACKS_NOT_SET

def DBG_ID_SFP_FLASHLOAD_A0_FAILED(args):
    numargs = 1
    format  = "SFP-DDMI: Loading A0 memory map values from FLASH failed with code: %d.\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SFP_FLASHLOAD_A0_FAILED

def DBG_ID_SFP_FLASHLOAD_A2_FAILED(args):
    numargs = 1
    format  = "SFP-DDMI: Loading A2 memory map values from FLASH failed with code: %d.\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SFP_FLASHLOAD_A2_FAILED

def DBG_ID_SFP_FLASHSTORE_A2_FAILED(args):
    numargs = 1
    format  = "SFP-DDMI: Storing user-writeable A2 memory map values to FLASH failed with code: %d.\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SFP_FLASHSTORE_A2_FAILED

def DBG_ID_INFOEXCHANGE_TIMEOUT(args):
    numargs = 2
    format  = "%s Info Exchange Time Out. Elapsed = %d > TimeOut = %d\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[0], args[1])

    return result
    # end of function DBG_ID_INFOEXCHANGE_TIMEOUT

def DBG_ID_INFOEXCHANGE_ABORTED(args):
    numargs = 0
    format  = "%s Info Exchange aborted. Transition count detected\n"
    result  = str()
    result  += format % (formatMsgIndent())

    return result
    # end of function DBG_ID_INFOEXCHANGE_ABORTED

def DBG_ID_AUTHENTICATION_FAILED(args):
    numargs = 0
    format  = "Authentication FAILED\n"
    result  = str()
    tempstr = formatstr("Authentication FAILED\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_AUTHENTICATION_FAILED

def DBG_ID_USM_XGEINIT(args):
    numargs = 1
    format  = "Load USM Master=%d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_USM_XGEINIT

def DBG_ID_USM_LOAD_TGE(args):
    numargs = 0
    format  = "Load TGE USM\n"
    result  = str()
    tempstr = formatstr("Load TGE USM\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_USM_LOAD_TGE

def DBG_ID_USM_LOAD_ERROR(args):
    numargs = 0
    format  = "USM Load ERROR\n"
    result  = str()
    tempstr = formatstr("USM Load ERROR\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_USM_LOAD_ERROR

def DBG_ID_USM_INIT_PAIR_INFO(args):
    numargs = 12
    format  = "RxPhys A/B/C/D on %d,%d,%d,%d;\nTxPhys A/B/C/D on %d,%d,%d,%d;\ninvABCD=%d%d%d%d\n"
    result  = str()
    result  += format % ( args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11])

    return result
    # end of function DBG_ID_USM_INIT_PAIR_INFO

def DBG_ID_USM_TGE_DBG_INFO(args):
    numargs = 6
    format  = "USM: state = %d, clock = %d, enable = %d, stall = %d, halt = %d PC = %d\n"
    result  = str()
    result  += format % ( args[0],args[1],args[2],args[3],args[4],args[5])

    return result
    # end of function DBG_ID_USM_TGE_DBG_INFO

def DBG_ID_TDE_ERROR_CHANGE_PHASE(args):
    numargs = 0
    format  = "SHS: noticed the tdeErr going to change the phase\n"
    result  = str()
    tempstr = formatstr("SHS: noticed the tdeErr going to change the phase\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_TDE_ERROR_CHANGE_PHASE

def DBG_ID_TDE_ERROR_POST_PHASE_CHANGE(args):
    numargs = 0
    format  = "SHS: ERROR: there was a tde Err even after phase change fixes\n"
    result  = str()
    tempstr = formatstr("SHS: ERROR: there was a tde Err even after phase change fixes\n", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_ID_TDE_ERROR_POST_PHASE_CHANGE

def DBG_ID_TX_QUANTIZATION(args):
    numargs = 1
    format  = "   Warning: TX DAC Left Shift %d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_TX_QUANTIZATION

def DBG_ID_AFO_OFFSET_CANCEL_MESSAGE(args):
    numargs = 8
    format  = "Offsets_afo: %4d %4d %4d %4d aif: %4d %4d %4d %4d\n"
    result  = str()
    result  += format % (unsigned2signed(args[0]&0xFFF,12),unsigned2signed(args[1]&0xFFF,12),unsigned2signed(args[2]&0xFFF,12),unsigned2signed(args[3]&0xFFF,12),unsigned2signed(args[4],16),unsigned2signed(args[5],16),unsigned2signed(args[6],16),unsigned2signed(args[7],16))

    return result
    # end of function DBG_ID_AFO_OFFSET_CANCEL_MESSAGE

def DBG_ID_PHY_BAUD_CONSTEL_INVALID_CONFIG(args):
    numargs = 2
    format  = "ERROR: phyBaudConstellationSet: Unknown configuration baud=%d; constellation= %d\n"
    result  = str()
    result  += format % (args[0], args[1])

    return result
    # end of function DBG_ID_PHY_BAUD_CONSTEL_INVALID_CONFIG

def DBG_ID_LINK_FAULT_CODE(args):
    numargs = 6
    format  = "%s Fault Set: L.Fault[%x] Rx.Fault[%x] LINT[%x] Sig.Type[%x]\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3], args[4], args[5])

    return result
    # end of function DBG_ID_LINK_FAULT_CODE

def DBG_ID_SD_RX_EQ_CAL(args):
    numargs = 3
    format  = "RX EQ CAL: curr state: %d; next state: %d (%d)\n"
    result  = str()
    result  += format % (args[0], args[1], args[2])

    return result
    # end of function DBG_ID_SD_RX_EQ_CAL

def DBG_ID_INFO_ABILITY_PAGE_RX(args):
    numargs = 2
    format  = "%sINFO Ability Page Received: 0x%02X%02X\n"
    result  = str()
    result  += format % (formatMsgIndent(), args[1], args[0])

    return result
    # end of function DBG_ID_INFO_ABILITY_PAGE_RX

def DBG_ID_INFO_SWAP_PAGE_RX(args):
    numargs = 2
    format  = "%sINFO Swap Page Logical %s %s %s %s\n"
    result  = str()
    result  += format % (formatMsgIndent(), constellation[(args[0]&0xF)], constellation[((args[0])&0xF0)>>4], constellation[(args[1])&0xF], constellation[((args[1])&0xF0)>>4])

    return result
    # end of function DBG_ID_INFO_SWAP_PAGE_RX

def DBG_ID_TX_CONSTELLATIONS(args):
    numargs = 4
    format  = "%sTX Cnstl Physical: %s %s %s %s \n"
    result  = str()
    result  += format % (formatMsgIndent(), constellation[args[0]], constellation[args[1]], constellation[args[2]], constellation[args[3]])

    return result
    # end of function DBG_ID_TX_CONSTELLATIONS

def DBG_ID_RX_CONSTELLATIONS(args):
    numargs = 4
    format  = "%sRX Cnstl Physical: %s %s %s %s \n"
    result  = str()
    result  += format % (formatMsgIndent(), constellation[args[0]], constellation[args[1]], constellation[args[2]], constellation[args[3]])

    return result
    # end of function DBG_ID_RX_CONSTELLATIONS

def DBG_ID_SYS_REINIT_DUE_TO_MACSEC_FC_OVERFLOW(args):
    numargs = 4
    format  = "%s\n MACSEC FC overflow. Reinitializing...\n  egressFifoOverFlowStatus = %d, ingressFifoOverFlowStatus = %d \n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2], args[3])

    return result
    # end of function DBG_ID_SYS_REINIT_DUE_TO_MACSEC_FC_OVERFLOW

def DBG_ID_RAD_INFO(args):
    numargs = 4
    format  = "RAD: active=%d, channel logical=%d phys=%d, invert=%d\n"
    result  = str()
    result  += format % (args[0], args[1], args[2], args[3])

    return result
    # end of function DBG_ID_RAD_INFO

def DBG_ID_SERDES_LOS_FILTER(args):
    numargs = 1
    format  = "serdes los filer enable = %d\n"
    result  = str()
    result  += format % (args[0])

    return result
    # end of function DBG_ID_SERDES_LOS_FILTER

def DBG_ID_EEE_FFE_CHAN(args):
    numargs = 3
    format  = "%s EEE FFE channel switched to: %d\n"
    result  = str()
    result  += format % (formatTimeStamp(getTime(args[0], args[1])), args[2])

    return result
    # end of function DBG_ID_EEE_FFE_CHAN

def DBG_NUM_ID_MSGS(args):
    numargs = 0
    format  = ""
    result  = str()
    tempstr = formatstr("", tuple(args))
    result  += tempstr

    return result
    # end of function DBG_NUM_ID_MSGS


class DebugTrace(object):
    """
    Class for parsing debug trace
    """

    def __init__(self, _phyControl = None):
        """
        Class initialization
        """

        self.phyControl = _phyControl
        if _phyControl != None:
            import processormemory
            self.mem = processormemory.ProcessorMemory(_phyControl)


            # XXX: HACK to allow imported module dbghelper to see symbols

            import __builtin__
            __builtin__.mem = self.mem
            __builtin__.msgIds = msgIds
            __builtin__.phyControl = _phyControl
            __builtin__._DBG_ID_PRINTF = _DBG_ID_PRINTF
            __builtin__.DBG_ID_TIME_STAMP = DBG_ID_TIME_STAMP
            __builtin__.DBG_ID_FAILURE = DBG_ID_FAILURE
            __builtin__.DBG_ID_LINKSTATUS = DBG_ID_LINKSTATUS
            __builtin__.DBG_ID_LNKRECOVERY = DBG_ID_LNKRECOVERY
            __builtin__.DBG_ID_TRAININGTYPE = DBG_ID_TRAININGTYPE
            __builtin__.DBG_ID_MDIO_EVENT = DBG_ID_MDIO_EVENT
            __builtin__.DBG_ID_GLB_FAULT = DBG_ID_GLB_FAULT
            __builtin__.DBG_ID_PHY_STATE = DBG_ID_PHY_STATE
            __builtin__.DBG_ID_ANEG_STATE = DBG_ID_ANEG_STATE
            __builtin__.DBG_ID_ANEG_PAGE = DBG_ID_ANEG_PAGE
            __builtin__.DBG_ID_ANEG_INFO = DBG_ID_ANEG_INFO
            __builtin__.DBG_ID_ANEG_INFO_2 = DBG_ID_ANEG_INFO_2
            __builtin__.DBG_ID_ANEG_INFO_3 = DBG_ID_ANEG_INFO_3
            __builtin__.DBG_ID_FREQ_OFFSET = DBG_ID_FREQ_OFFSET
            __builtin__.DBG_ID_CDR_SOURCE = DBG_ID_CDR_SOURCE
            __builtin__.DBG_ID_CDR_SOURCE_SWITCH = DBG_ID_CDR_SOURCE_SWITCH
            __builtin__.DBG_ID_FILTERSCALE = DBG_ID_FILTERSCALE
            __builtin__.DBG_ID_DFE_COEF = DBG_ID_DFE_COEF
            __builtin__.DBG_ID_THP_COEF = DBG_ID_THP_COEF
            __builtin__.DBG_ID_PRINTF = DBG_ID_PRINTF
            __builtin__.DBG_ID_SIF_CLK_MUX_INFO = DBG_ID_SIF_CLK_MUX_INFO
            __builtin__.DGB_ID_KR_EXT = DGB_ID_KR_EXT
            __builtin__.DGB_ID_KR_INT = DGB_ID_KR_INT
            __builtin__.DBG_ID_XFI_CNTR = DBG_ID_XFI_CNTR
            __builtin__.DBG_ID_PCS_CNTR = DBG_ID_PCS_CNTR
            __builtin__.DBG_ID_SERDES_EYE_DIAG = DBG_ID_SERDES_EYE_DIAG
            __builtin__.DBG_ID_SERDES_WR_TOUT = DBG_ID_SERDES_WR_TOUT
            __builtin__.DBG_ID_SERDES_RD_TOUT = DBG_ID_SERDES_RD_TOUT
            __builtin__.DBG_ID_VSEMI_BIT_RD = DBG_ID_VSEMI_BIT_RD
            __builtin__.DBG_ID_VSEMI_BIT_WR = DBG_ID_VSEMI_BIT_WR
            __builtin__.DBG_ID_GFE_100M = DBG_ID_GFE_100M
            __builtin__.DBG_ID_GFE_GE = DBG_ID_GFE_GE
            __builtin__.DBG_ID_GFE_MDI = DBG_ID_GFE_MDI
            __builtin__.DBG_ID_GFE_RESULT = DBG_ID_GFE_RESULT
            __builtin__.DBG_ID_GFE_SLC = DBG_ID_GFE_SLC
            __builtin__.DBG_ID_SYS_TRANSITION = DBG_ID_SYS_TRANSITION
            __builtin__.DBG_ID_SYS_MSG = DBG_ID_SYS_MSG
            __builtin__.DBG_ID_XGS_SWITCHOVER = DBG_ID_XGS_SWITCHOVER
            __builtin__.DBG_ID_SIF_USX_ANEG = DBG_ID_SIF_USX_ANEG
            __builtin__.DBG_ID_USX = DBG_ID_USX
            __builtin__.DBG_ID_SYS_MGR_RESET = DBG_ID_SYS_MGR_RESET
            __builtin__.DBG_ID_ALARM_XFI0 = DBG_ID_ALARM_XFI0
            __builtin__.DBG_ID_ALARM_XFI1 = DBG_ID_ALARM_XFI1
            __builtin__.DBG_ID_CHK_STATUS = DBG_ID_CHK_STATUS
            __builtin__.DBG_ID_CHK_STATUS_STAMP = DBG_ID_CHK_STATUS_STAMP
            __builtin__.DBG_ID_SEGMENT_POWERDOWN = DBG_ID_SEGMENT_POWERDOWN
            __builtin__.DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN = DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN
            __builtin__.DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN_MSGTYPE1 = DBG_ID_SNR_MARGIN_EFFECT_ON_SEGMENT_POWERDOWN_MSGTYPE1
            __builtin__.DBG_ID_NUMBER_OF_SEGMENTS_OPTIMIZED = DBG_ID_NUMBER_OF_SEGMENTS_OPTIMIZED
            __builtin__.DBG_ID_POWER_GATED_SEGMENTS = DBG_ID_POWER_GATED_SEGMENTS
            __builtin__.DBG_ID_IP_PHONE = DBG_ID_IP_PHONE
            __builtin__.DBG_ID_IP_PHONE_DEBUG = DBG_ID_IP_PHONE_DEBUG
            __builtin__.DBG_ID_LDPC_AVG_ITERATIONS = DBG_ID_LDPC_AVG_ITERATIONS
            __builtin__.DBG_ID_SEGMENT_RESTORE = DBG_ID_SEGMENT_RESTORE
            __builtin__.DBG_ID_RATE_TRAN_RES = DBG_ID_RATE_TRAN_RES
            __builtin__.DBG_ID_RATE_TRAN_ERR = DBG_ID_RATE_TRAN_ERR
            __builtin__.DBG_ID_CHECKLINK = DBG_ID_CHECKLINK
            __builtin__.DBG_ID_LINK_DOWN_STATUS = DBG_ID_LINK_DOWN_STATUS
            __builtin__.DBG_ID_LDPC_EVENT = DBG_ID_LDPC_EVENT
            __builtin__.DBG_ID_ACTIVE_LKP = DBG_ID_ACTIVE_LKP
            __builtin__.DBG_ID_CABLE_CODE = DBG_ID_CABLE_CODE
            __builtin__.DBG_ID_BOOST = DBG_ID_BOOST
            __builtin__.DBG_ID_TX_SLW_HOLD = DBG_ID_TX_SLW_HOLD
            __builtin__.DBG_ID_DAC_VALUE_TEMP_CAL = DBG_ID_DAC_VALUE_TEMP_CAL
            __builtin__.DBG_ID_ANEG_STATUS = DBG_ID_ANEG_STATUS
            __builtin__.DBG_ID_LINK_DOWN_LDPC_ITERATION = DBG_ID_LINK_DOWN_LDPC_ITERATION
            __builtin__.DBG_ID_LKP_PBO_PBOADJUST = DBG_ID_LKP_PBO_PBOADJUST
            __builtin__.DBG_ID_DUT_PBO_PBOADJUST = DBG_ID_DUT_PBO_PBOADJUST
            __builtin__.DBG_ID_SEGMENT_POWERDOWN_REVERTED = DBG_ID_SEGMENT_POWERDOWN_REVERTED
            __builtin__.DBG_ID_SEGMENT_OPTIMIZATION_WARNING1 = DBG_ID_SEGMENT_OPTIMIZATION_WARNING1
            __builtin__.DBG_ID_LDPC_AVG_ITERATIONS_MSGTYPE1 = DBG_ID_LDPC_AVG_ITERATIONS_MSGTYPE1
            __builtin__.DBG_ID_AFE_SHORT = DBG_ID_AFE_SHORT
            __builtin__.DBG_ID_AFE_MID_SWITCH = DBG_ID_AFE_MID_SWITCH
            __builtin__.DBG_ID_FFE_MRVL = DBG_ID_FFE_MRVL
            __builtin__.DBG_ID_TX_MISALIGNMENT = DBG_ID_TX_MISALIGNMENT
            __builtin__.DBG_ID_TR_DISTURB_STARTED = DBG_ID_TR_DISTURB_STARTED
            __builtin__.DBG_ID_TR_DISTURB_FINISHED = DBG_ID_TR_DISTURB_FINISHED
            __builtin__.DBG_ID_TONE_GENERATION_STARTED = DBG_ID_TONE_GENERATION_STARTED
            __builtin__.DBG_ID_TONE_GENERATION_STOPPED = DBG_ID_TONE_GENERATION_STOPPED
            __builtin__.DBG_ID_TONE_DETECTIED = DBG_ID_TONE_DETECTIED
            __builtin__.DBG_ID_SYS_INIT = DBG_ID_SYS_INIT
            __builtin__.DBG_ID_SYS_USX_MODE_INITIALIZATION = DBG_ID_SYS_USX_MODE_INITIALIZATION
            __builtin__.DBG_ID_SYS_XFI_MODE_INITIALIZATION = DBG_ID_SYS_XFI_MODE_INITIALIZATION
            __builtin__.DBG_ID_SYS_SGMII_MODE_INITIALIZATION = DBG_ID_SYS_SGMII_MODE_INITIALIZATION
            __builtin__.DBG_ID_SYS_OCSGMII_MODE_INITIALIZATION = DBG_ID_SYS_OCSGMII_MODE_INITIALIZATION
            __builtin__.DBG_ID_SYS_MACSEC_INITIALIZATION = DBG_ID_SYS_MACSEC_INITIALIZATION
            __builtin__.DBG_ID_SYS_MACSEC_HEADER_BRINGUP = DBG_ID_SYS_MACSEC_HEADER_BRINGUP
            __builtin__.DBG_ID_SYS_MACSEC_HEADER_SHUTDOWN = DBG_ID_SYS_MACSEC_HEADER_SHUTDOWN
            __builtin__.DBG_ID_SERDES_INITIALIZATION = DBG_ID_SERDES_INITIALIZATION
            __builtin__.DBG_ID_SYS_TX_TRANSITIONED_UP = DBG_ID_SYS_TX_TRANSITIONED_UP
            __builtin__.DBG_ID_SYS_TX_TRANSITIONED_DOWN = DBG_ID_SYS_TX_TRANSITIONED_DOWN
            __builtin__.DBG_ID_SYS_RX_LINK_TRANSITIONED_UP = DBG_ID_SYS_RX_LINK_TRANSITIONED_UP
            __builtin__.DBG_ID_SYS_RX_LINK_TRANSITIONED_DOWN = DBG_ID_SYS_RX_LINK_TRANSITIONED_DOWN
            __builtin__.DBG_ID_SYS_AUTONEG_STARTED = DBG_ID_SYS_AUTONEG_STARTED
            __builtin__.DBG_ID_MSM_SYS_TRANSITION = DBG_ID_MSM_SYS_TRANSITION
            __builtin__.DBG_ID_MSM_LINE_TRANSITION = DBG_ID_MSM_LINE_TRANSITION
            __builtin__.DBG_ID_PTP_ENABLE = DBG_ID_PTP_ENABLE
            __builtin__.DBG_ID_GENERAL_LOOPBACK = DBG_ID_GENERAL_LOOPBACK
            __builtin__.DBG_ID_GENERAL_LOOPBACK_UNSUPPORTED = DBG_ID_GENERAL_LOOPBACK_UNSUPPORTED
            __builtin__.DBG_ID_PACKET_GENERATION = DBG_ID_PACKET_GENERATION
            __builtin__.DBG_ID_SYS_LINK_DOWN = DBG_ID_SYS_LINK_DOWN
            __builtin__.DBG_ID_SYS_SERDES_STATUS_FAIL = DBG_ID_SYS_SERDES_STATUS_FAIL
            __builtin__.DBG_ID_SYS_ANEG_STATUS_FAIL = DBG_ID_SYS_ANEG_STATUS_FAIL
            __builtin__.DBG_ID_SYS_PACKET_GENERATION_UNSUPPORTED = DBG_ID_SYS_PACKET_GENERATION_UNSUPPORTED
            __builtin__.DBG_ID_SYS_PACKET_GENERATION_PARAMS = DBG_ID_SYS_PACKET_GENERATION_PARAMS
            __builtin__.DBG_ID_SYS_LOOPBACK_PARAMS = DBG_ID_SYS_LOOPBACK_PARAMS
            __builtin__.DBG_ID_SYS_STATE_TRANSITION = DBG_ID_SYS_STATE_TRANSITION
            __builtin__.DBG_ID_SD_AN_TR_STATE_TRANSITION = DBG_ID_SD_AN_TR_STATE_TRANSITION
            __builtin__.DBG_ID_SYS_RA_ANEG_STATE_TRANSITION = DBG_ID_SYS_RA_ANEG_STATE_TRANSITION
            __builtin__.DBG_ID_SYS_STATE_MACHINE_TIMEOUT = DBG_ID_SYS_STATE_MACHINE_TIMEOUT
            __builtin__.DBG_ID_SYS_LINK_UP = DBG_ID_SYS_LINK_UP
            __builtin__.DBG_ID_SYS_STATE_SIGNAL_DETECT_MISSING = DBG_ID_SYS_STATE_SIGNAL_DETECT_MISSING
            __builtin__.DBG_ID_SYS_SERDES_EQUALIZATION_FAIL = DBG_ID_SYS_SERDES_EQUALIZATION_FAIL
            __builtin__.DBG_ID_SYS_SERDES_CALIBRATION_TIMEOUT = DBG_ID_SYS_SERDES_CALIBRATION_TIMEOUT
            __builtin__.DBG_ID_SYS_SERDES_TX_STATUS = DBG_ID_SYS_SERDES_TX_STATUS
            __builtin__.DBG_ID_AEC_DELAY_SEARCH = DBG_ID_AEC_DELAY_SEARCH
            __builtin__.DBG_ID_TX_LPI_IN = DBG_ID_TX_LPI_IN
            __builtin__.DBG_ID_TX_LPI_OUT = DBG_ID_TX_LPI_OUT
            __builtin__.DBG_ID_RX_LPI_IN = DBG_ID_RX_LPI_IN
            __builtin__.DBG_ID_RX_LPI_OUT = DBG_ID_RX_LPI_OUT
            __builtin__.DBG_ID_EEE_LINK_FAIL = DBG_ID_EEE_LINK_FAIL
            __builtin__.DBG_ID_USM_HANDSHAKE_FAIL = DBG_ID_USM_HANDSHAKE_FAIL
            __builtin__.DBG_ID_USM_POST_HANDSHAKE_FAIL = DBG_ID_USM_POST_HANDSHAKE_FAIL
            __builtin__.DBG_ID_CHECKPOINT = DBG_ID_CHECKPOINT
            __builtin__.DBG_ID_REFRAME = DBG_ID_REFRAME
            __builtin__.DBG_ID_ANEG_POST_TRAINING = DBG_ID_ANEG_POST_TRAINING
            __builtin__.DBG_ID_SMB0_ENTERED_ISR = DBG_ID_SMB0_ENTERED_ISR
            __builtin__.DBG_ID_SMB0_IDLE_READMODE = DBG_ID_SMB0_IDLE_READMODE
            __builtin__.DBG_ID_SMB0_IDLE_TO_EXPECTINGCC = DBG_ID_SMB0_IDLE_TO_EXPECTINGCC
            __builtin__.DBG_ID_SMB0_IDLE_BADADDRESS = DBG_ID_SMB0_IDLE_BADADDRESS
            __builtin__.DBG_ID_SMB0_EXPECTINGCC_TO_AFTERCC = DBG_ID_SMB0_EXPECTINGCC_TO_AFTERCC
            __builtin__.DBG_ID_SMB0_AFTERCC_READ = DBG_ID_SMB0_AFTERCC_READ
            __builtin__.DBG_ID_SMB0_AFTERCC_TO_AFTERREAD = DBG_ID_SMB0_AFTERCC_TO_AFTERREAD
            __builtin__.DBG_ID_SMB0_AFTERCC_RSANDWRITE = DBG_ID_SMB0_AFTERCC_RSANDWRITE
            __builtin__.DBG_ID_SFP_AFTERCC_WRITE = DBG_ID_SFP_AFTERCC_WRITE
            __builtin__.DBG_ID_SMB0_AFTERCC_TO_IDLE = DBG_ID_SMB0_AFTERCC_TO_IDLE
            __builtin__.DBG_ID_SMB0_AFTERREAD_READ = DBG_ID_SMB0_AFTERREAD_READ
            __builtin__.DBG_ID_SMB0_AFTERREAD_TO_AFTERREAD = DBG_ID_SMB0_AFTERREAD_TO_AFTERREAD
            __builtin__.DBG_ID_SMB0_AFTERREAD_TO_IDLE = DBG_ID_SMB0_AFTERREAD_TO_IDLE
            __builtin__.DBG_ID_SMB0_NOALARM = DBG_ID_SMB0_NOALARM
            __builtin__.DBG_ID_SMB0_TIMEOUT = DBG_ID_SMB0_TIMEOUT
            __builtin__.DBG_ID_SMB0_CALLBACKS_NOT_SET = DBG_ID_SMB0_CALLBACKS_NOT_SET
            __builtin__.DBG_ID_SFP_FLASHLOAD_A0_FAILED = DBG_ID_SFP_FLASHLOAD_A0_FAILED
            __builtin__.DBG_ID_SFP_FLASHLOAD_A2_FAILED = DBG_ID_SFP_FLASHLOAD_A2_FAILED
            __builtin__.DBG_ID_SFP_FLASHSTORE_A2_FAILED = DBG_ID_SFP_FLASHSTORE_A2_FAILED
            __builtin__.DBG_ID_INFOEXCHANGE_TIMEOUT = DBG_ID_INFOEXCHANGE_TIMEOUT
            __builtin__.DBG_ID_INFOEXCHANGE_ABORTED = DBG_ID_INFOEXCHANGE_ABORTED
            __builtin__.DBG_ID_AUTHENTICATION_FAILED = DBG_ID_AUTHENTICATION_FAILED
            __builtin__.DBG_ID_USM_XGEINIT = DBG_ID_USM_XGEINIT
            __builtin__.DBG_ID_USM_LOAD_TGE = DBG_ID_USM_LOAD_TGE
            __builtin__.DBG_ID_USM_LOAD_ERROR = DBG_ID_USM_LOAD_ERROR
            __builtin__.DBG_ID_USM_INIT_PAIR_INFO = DBG_ID_USM_INIT_PAIR_INFO
            __builtin__.DBG_ID_USM_TGE_DBG_INFO = DBG_ID_USM_TGE_DBG_INFO
            __builtin__.DBG_ID_TDE_ERROR_CHANGE_PHASE = DBG_ID_TDE_ERROR_CHANGE_PHASE
            __builtin__.DBG_ID_TDE_ERROR_POST_PHASE_CHANGE = DBG_ID_TDE_ERROR_POST_PHASE_CHANGE
            __builtin__.DBG_ID_TX_QUANTIZATION = DBG_ID_TX_QUANTIZATION
            __builtin__.DBG_ID_AFO_OFFSET_CANCEL_MESSAGE = DBG_ID_AFO_OFFSET_CANCEL_MESSAGE
            __builtin__.DBG_ID_PHY_BAUD_CONSTEL_INVALID_CONFIG = DBG_ID_PHY_BAUD_CONSTEL_INVALID_CONFIG
            __builtin__.DBG_ID_LINK_FAULT_CODE = DBG_ID_LINK_FAULT_CODE
            __builtin__.DBG_ID_SD_RX_EQ_CAL = DBG_ID_SD_RX_EQ_CAL
            __builtin__.DBG_ID_INFO_ABILITY_PAGE_RX = DBG_ID_INFO_ABILITY_PAGE_RX
            __builtin__.DBG_ID_INFO_SWAP_PAGE_RX = DBG_ID_INFO_SWAP_PAGE_RX
            __builtin__.DBG_ID_TX_CONSTELLATIONS = DBG_ID_TX_CONSTELLATIONS
            __builtin__.DBG_ID_RX_CONSTELLATIONS = DBG_ID_RX_CONSTELLATIONS
            __builtin__.DBG_ID_SYS_REINIT_DUE_TO_MACSEC_FC_OVERFLOW = DBG_ID_SYS_REINIT_DUE_TO_MACSEC_FC_OVERFLOW
            __builtin__.DBG_ID_RAD_INFO = DBG_ID_RAD_INFO
            __builtin__.DBG_ID_SERDES_LOS_FILTER = DBG_ID_SERDES_LOS_FILTER
            __builtin__.DBG_ID_EEE_FFE_CHAN = DBG_ID_EEE_FFE_CHAN
            __builtin__.DBG_NUM_ID_MSGS = DBG_NUM_ID_MSGS


            # These globals are from dbghelper

            __builtin__.BUFF_LENGTH_BYTES = BUFF_LENGTH_BYTES
            self.BUFF_LENGTH_BYTES = BUFF_LENGTH_BYTES
            __builtin__.BUFF_LENGTH_SHORTS = BUFF_LENGTH_SHORTS
            self.BUFF_LENGTH_SHORTS = BUFF_LENGTH_SHORTS
            __builtin__.CDbgTraceConsts = CDbgTraceConsts
            self.CDbgTraceConsts = CDbgTraceConsts
            __builtin__.CDebugTraceData = CDebugTraceData
            self.CDebugTraceData = CDebugTraceData
            __builtin__.CDebugTraceRawFileReader = CDebugTraceRawFileReader
            self.CDebugTraceRawFileReader = CDebugTraceRawFileReader
            __builtin__.CDebugTraceRawFileWriter = CDebugTraceRawFileWriter
            self.CDebugTraceRawFileWriter = CDebugTraceRawFileWriter
            __builtin__.CDebugTraceResultDict = CDebugTraceResultDict
            self.CDebugTraceResultDict = CDebugTraceResultDict
            __builtin__.CPhyControlStub = CPhyControlStub
            self.CPhyControlStub = CPhyControlStub
            __builtin__.CPhyCtrlData = CPhyCtrlData
            self.CPhyCtrlData = CPhyCtrlData
            __builtin__.DbgTraceGet = DbgTraceGet
            self.DbgTraceGet = DbgTraceGet
            __builtin__.DbgTraceGetFromRawFile = DbgTraceGetFromRawFile
            self.DbgTraceGetFromRawFile = DbgTraceGetFromRawFile
            __builtin__.DbgTraceRawFileCollectAndWrite = DbgTraceRawFileCollectAndWrite
            self.DbgTraceRawFileCollectAndWrite = DbgTraceRawFileCollectAndWrite
            __builtin__.DbgTraceRawFileDelete = DbgTraceRawFileDelete
            self.DbgTraceRawFileDelete = DbgTraceRawFileDelete
            __builtin__.LnktrainingType = LnktrainingType
            self.LnktrainingType = LnktrainingType
            __builtin__.MAX_NUM_ARGS_IN_DBG_MSG = MAX_NUM_ARGS_IN_DBG_MSG
            self.MAX_NUM_ARGS_IN_DBG_MSG = MAX_NUM_ARGS_IN_DBG_MSG
            __builtin__.MAX_NUM_ARGS_IN_PRINTF_MSG = MAX_NUM_ARGS_IN_PRINTF_MSG
            self.MAX_NUM_ARGS_IN_PRINTF_MSG = MAX_NUM_ARGS_IN_PRINTF_MSG
            __builtin__.SdResetType = SdResetType
            self.SdResetType = SdResetType
            __builtin__.SdSmcStates = SdSmcStates
            self.SdSmcStates = SdSmcStates
            __builtin__.SysInitResetType = SysInitResetType
            self.SysInitResetType = SysInitResetType
            __builtin__.SysSmcMsgType = SysSmcMsgType
            self.SysSmcMsgType = SysSmcMsgType
            __builtin__.UsxAnegHwSmcStates = UsxAnegHwSmcStates
            self.UsxAnegHwSmcStates = UsxAnegHwSmcStates
            __builtin__.UsxAnegRudi = UsxAnegRudi
            self.UsxAnegRudi = UsxAnegRudi
            __builtin__.UsxMsgType = UsxMsgType
            self.UsxMsgType = UsxMsgType
            __builtin__.anegBreakLinkTimestamp = anegBreakLinkTimestamp
            self.anegBreakLinkTimestamp = anegBreakLinkTimestamp
            __builtin__.anegConnectionStates = anegConnectionStates
            self.anegConnectionStates = anegConnectionStates
            __builtin__.anegDbgInfo = anegDbgInfo
            self.anegDbgInfo = anegDbgInfo
            __builtin__.anegDecipherPage = anegDecipherPage
            self.anegDecipherPage = anegDecipherPage
            __builtin__.anegExitStatus = anegExitStatus
            self.anegExitStatus = anegExitStatus
            __builtin__.anegFlagsDecode = anegFlagsDecode
            self.anegFlagsDecode = anegFlagsDecode
            __builtin__.anegPage = anegPage
            self.anegPage = anegPage
            __builtin__.anegRates = anegRates
            self.anegRates = anegRates
            __builtin__.anegRxState = anegRxState
            self.anegRxState = anegRxState
            __builtin__.anegTxState = anegTxState
            self.anegTxState = anegTxState
            __builtin__.arbitState = arbitState
            self.arbitState = arbitState
            __builtin__.autoNegFlags = autoNegFlags
            self.autoNegFlags = autoNegFlags
            __builtin__.binaryStrToByteList = binaryStrToByteList
            self.binaryStrToByteList = binaryStrToByteList
            __builtin__.constellation = constellation
            self.constellation = constellation
            __builtin__.converTimeGfe = converTimeGfe
            self.converTimeGfe = converTimeGfe
            __builtin__.createByteList = createByteList
            self.createByteList = createByteList
            __builtin__.createByteListFromString = createByteListFromString
            self.createByteListFromString = createByteListFromString
            __builtin__.currentPhyControl = currentPhyControl
            self.currentPhyControl = currentPhyControl
            __builtin__.dbgConvertBitStateToStr = dbgConvertBitStateToStr
            self.dbgConvertBitStateToStr = dbgConvertBitStateToStr
            __builtin__.dbgPrint = dbgPrint
            self.dbgPrint = dbgPrint
            __builtin__.decipherAQRateBits = decipherAQRateBits
            self.decipherAQRateBits = decipherAQRateBits
            __builtin__.decipherBasePage = decipherBasePage
            self.decipherBasePage = decipherBasePage
            __builtin__.decipherNextPage = decipherNextPage
            self.decipherNextPage = decipherNextPage
            __builtin__.decipherNextPageMessageCodeField = decipherNextPageMessageCodeField
            self.decipherNextPageMessageCodeField = decipherNextPageMessageCodeField
            __builtin__.eSIF_PACKET_GEN_LOOKASIDE = eSIF_PACKET_GEN_LOOKASIDE
            self.eSIF_PACKET_GEN_LOOKASIDE = eSIF_PACKET_GEN_LOOKASIDE
            __builtin__.eSIF_PACKET_GEN_MDI = eSIF_PACKET_GEN_MDI
            self.eSIF_PACKET_GEN_MDI = eSIF_PACKET_GEN_MDI
            __builtin__.eSIF_PACKET_GEN_OFF = eSIF_PACKET_GEN_OFF
            self.eSIF_PACKET_GEN_OFF = eSIF_PACKET_GEN_OFF
            __builtin__.eSIF_PACKET_GEN_SYSTEM = eSIF_PACKET_GEN_SYSTEM
            self.eSIF_PACKET_GEN_SYSTEM = eSIF_PACKET_GEN_SYSTEM
            __builtin__.failureCodes = failureCodes
            self.failureCodes = failureCodes
            __builtin__.faults = faults
            self.faults = faults
            __builtin__.filters = filters
            self.filters = filters
            __builtin__.formatAecDlySearch = formatAecDlySearch
            self.formatAecDlySearch = formatAecDlySearch
            __builtin__.formatAnegInfoMsg = formatAnegInfoMsg
            self.formatAnegInfoMsg = formatAnegInfoMsg
            __builtin__.formatAnegInfoMsg_2 = formatAnegInfoMsg_2
            self.formatAnegInfoMsg_2 = formatAnegInfoMsg_2
            __builtin__.formatAnegInfoMsg_3 = formatAnegInfoMsg_3
            self.formatAnegInfoMsg_3 = formatAnegInfoMsg_3
            __builtin__.formatAnegInfo_PostTraining = formatAnegInfo_PostTraining
            self.formatAnegInfo_PostTraining = formatAnegInfo_PostTraining
            __builtin__.formatAnegStatus = formatAnegStatus
            self.formatAnegStatus = formatAnegStatus
            __builtin__.formatAutonegMsg = formatAutonegMsg
            self.formatAutonegMsg = formatAutonegMsg
            __builtin__.formatCheckpoint = formatCheckpoint
            self.formatCheckpoint = formatCheckpoint
            __builtin__.formatChkStatus = formatChkStatus
            self.formatChkStatus = formatChkStatus
            __builtin__.formatEnableDisable = formatEnableDisable
            self.formatEnableDisable = formatEnableDisable
            __builtin__.formatKrCoeff = formatKrCoeff
            self.formatKrCoeff = formatKrCoeff
            __builtin__.formatKrMsgExternal = formatKrMsgExternal
            self.formatKrMsgExternal = formatKrMsgExternal
            __builtin__.formatKrMsgInternal = formatKrMsgInternal
            self.formatKrMsgInternal = formatKrMsgInternal
            __builtin__.formatKrPmdMsg = formatKrPmdMsg
            self.formatKrPmdMsg = formatKrPmdMsg
            __builtin__.formatKrStatus = formatKrStatus
            self.formatKrStatus = formatKrStatus
            __builtin__.formatLoopback = formatLoopback
            self.formatLoopback = formatLoopback
            __builtin__.formatMdix = formatMdix
            self.formatMdix = formatMdix
            __builtin__.formatMsgIndent = formatMsgIndent
            self.formatMsgIndent = formatMsgIndent
            __builtin__.formatPhyStateMsg = formatPhyStateMsg
            self.formatPhyStateMsg = formatPhyStateMsg
            __builtin__.formatPktGen = formatPktGen
            self.formatPktGen = formatPktGen
            __builtin__.formatRate = formatRate
            self.formatRate = formatRate
            __builtin__.formatRateAdaptation = formatRateAdaptation
            self.formatRateAdaptation = formatRateAdaptation
            __builtin__.formatSerdesMode = formatSerdesMode
            self.formatSerdesMode = formatSerdesMode
            __builtin__.formatSpec = formatSpec
            self.formatSpec = formatSpec
            __builtin__.formatSysMgr = formatSysMgr
            self.formatSysMgr = formatSysMgr
            __builtin__.formatSysSmcMsg = formatSysSmcMsg
            self.formatSysSmcMsg = formatSysSmcMsg
            __builtin__.formatSysState = formatSysState
            self.formatSysState = formatSysState
            __builtin__.formatSysTransition = formatSysTransition
            self.formatSysTransition = formatSysTransition
            __builtin__.formatSysUsxAnegDebug = formatSysUsxAnegDebug
            self.formatSysUsxAnegDebug = formatSysUsxAnegDebug
            __builtin__.formatSysXgsSwitchover = formatSysXgsSwitchover
            self.formatSysXgsSwitchover = formatSysXgsSwitchover
            __builtin__.formatTestMode = formatTestMode
            self.formatTestMode = formatTestMode
            __builtin__.formatTimeGfeStamp = formatTimeGfeStamp
            self.formatTimeGfeStamp = formatTimeGfeStamp
            __builtin__.formatTimeStamp = formatTimeStamp
            self.formatTimeStamp = formatTimeStamp
            __builtin__.formatTrainingTypeMsg = formatTrainingTypeMsg
            self.formatTrainingTypeMsg = formatTrainingTypeMsg
            __builtin__.formatTrueFalse = formatTrueFalse
            self.formatTrueFalse = formatTrueFalse
            __builtin__.formatUSXMsg = formatUSXMsg
            self.formatUSXMsg = formatUSXMsg
            __builtin__.formatstr = formatstr
            self.formatstr = formatstr
            __builtin__.freqOffSetGe = freqOffSetGe
            self.freqOffSetGe = freqOffSetGe
            __builtin__.gDebugTraceData = gDebugTraceData
            self.gDebugTraceData = gDebugTraceData
            __builtin__.gDebugVerbosityLevel = gDebugVerbosityLevel
            self.gDebugVerbosityLevel = gDebugVerbosityLevel
            __builtin__.gDebugVerbosityLevels = gDebugVerbosityLevels
            self.gDebugVerbosityLevels = gDebugVerbosityLevels
            __builtin__.getMsg = getMsg
            self.getMsg = getMsg
            __builtin__.getTime = getTime
            self.getTime = getTime
            __builtin__.ipPhoneDebugParse = ipPhoneDebugParse
            self.ipPhoneDebugParse = ipPhoneDebugParse
            __builtin__.ipPhoneParseMessage = ipPhoneParseMessage
            self.ipPhoneParseMessage = ipPhoneParseMessage
            __builtin__.krAnDecodeCodeWord = krAnDecodeCodeWord
            self.krAnDecodeCodeWord = krAnDecodeCodeWord
            __builtin__.krAnNextPageMsgCode = krAnNextPageMsgCode
            self.krAnNextPageMsgCode = krAnNextPageMsgCode
            __builtin__.krAnPageType = krAnPageType
            self.krAnPageType = krAnPageType
            __builtin__.krAnSmcState = krAnSmcState
            self.krAnSmcState = krAnSmcState
            __builtin__.krCoeffStatus = krCoeffStatus
            self.krCoeffStatus = krCoeffStatus
            __builtin__.krCoeffUpdate = krCoeffUpdate
            self.krCoeffUpdate = krCoeffUpdate
            __builtin__.krFrameLockState = krFrameLockState
            self.krFrameLockState = krFrameLockState
            __builtin__.krLocalCoeffUpdateState = krLocalCoeffUpdateState
            self.krLocalCoeffUpdateState = krLocalCoeffUpdateState
            __builtin__.krLocalPhase = krLocalPhase
            self.krLocalPhase = krLocalPhase
            __builtin__.krRemoteCoeffStatus = krRemoteCoeffStatus
            self.krRemoteCoeffStatus = krRemoteCoeffStatus
            __builtin__.krRemoteCoeffUpdateState = krRemoteCoeffUpdateState
            self.krRemoteCoeffUpdateState = krRemoteCoeffUpdateState
            __builtin__.krSmcState = krSmcState
            self.krSmcState = krSmcState
            __builtin__.krTap = krTap
            self.krTap = krTap
            __builtin__.krTrainingAlarms = krTrainingAlarms
            self.krTrainingAlarms = krTrainingAlarms
            __builtin__.krTrainingSmcStates = krTrainingSmcStates
            self.krTrainingSmcStates = krTrainingSmcStates
            __builtin__.linkStatus = linkStatus
            self.linkStatus = linkStatus
            __builtin__.list2str = list2str
            self.list2str = list2str
            __builtin__.mdioEvents = mdioEvents
            self.mdioEvents = mdioEvents
            __builtin__.parseDebugTrace = parseDebugTrace
            self.parseDebugTrace = parseDebugTrace
            __builtin__.parseGeDebugInfo = parseGeDebugInfo
            self.parseGeDebugInfo = parseGeDebugInfo
            __builtin__.parseGeDebugNonAq = parseGeDebugNonAq
            self.parseGeDebugNonAq = parseGeDebugNonAq
            __builtin__.parseGeSlicerResult = parseGeSlicerResult
            self.parseGeSlicerResult = parseGeSlicerResult
            __builtin__.parseGfe = parseGfe
            self.parseGfe = parseGfe
            __builtin__.parseGfeTrainResult = parseGfeTrainResult
            self.parseGfeTrainResult = parseGfeTrainResult
            __builtin__.phyState = phyState
            self.phyState = phyState
            __builtin__.phyStatePrevTimestamp = phyStatePrevTimestamp
            self.phyStatePrevTimestamp = phyStatePrevTimestamp
            __builtin__.pivotList = pivotList
            self.pivotList = pivotList
            __builtin__.printTrace = printTrace
            self.printTrace = printTrace
            __builtin__.rateAdaptationModes = rateAdaptationModes
            self.rateAdaptationModes = rateAdaptationModes
            __builtin__.rateTransitionParseMessage = rateTransitionParseMessage
            self.rateTransitionParseMessage = rateTransitionParseMessage
            __builtin__.rates = rates
            self.rates = rates
            __builtin__.resetDebugBuffer = resetDebugBuffer
            self.resetDebugBuffer = resetDebugBuffer
            __builtin__.sdAnegTrngState = sdAnegTrngState
            self.sdAnegTrngState = sdAnegTrngState
            __builtin__.sdModes = sdModes
            self.sdModes = sdModes
            __builtin__.sifOpModes = sifOpModes
            self.sifOpModes = sifOpModes
            __builtin__.signed2unsigned = signed2unsigned
            self.signed2unsigned = signed2unsigned
            __builtin__.snrCalc = snrCalc
            self.snrCalc = snrCalc
            __builtin__.spliceBytes = spliceBytes
            self.spliceBytes = spliceBytes
            __builtin__.sysAnegStatus = sysAnegStatus
            self.sysAnegStatus = sysAnegStatus
            __builtin__.sysLoopbacks = sysLoopbacks
            self.sysLoopbacks = sysLoopbacks
            __builtin__.sysModes = sysModes
            self.sysModes = sysModes
            __builtin__.sysRateAdaptAnegState = sysRateAdaptAnegState
            self.sysRateAdaptAnegState = sysRateAdaptAnegState
            __builtin__.sysState = sysState
            self.sysState = sysState
            __builtin__.systemInterfaceTestModes = systemInterfaceTestModes
            self.systemInterfaceTestModes = systemInterfaceTestModes
            __builtin__.trainingType = trainingType
            self.trainingType = trainingType
            __builtin__.txDacValueChange = txDacValueChange
            self.txDacValueChange = txDacValueChange
            __builtin__.txPageType = txPageType
            self.txPageType = txPageType
            __builtin__.unsigned2signed = unsigned2signed
            self.unsigned2signed = unsigned2signed
            __builtin__.xgsClockModes = xgsClockModes
            self.xgsClockModes = xgsClockModes
            __builtin__.xgsMdi1Port = xgsMdi1Port
            self.xgsMdi1Port = xgsMdi1Port
            __builtin__.xgsModes = xgsModes
            self.xgsModes = xgsModes
            __builtin__.xgsXauiPort = xgsXauiPort
            self.xgsXauiPort = xgsXauiPort
            __builtin__.xgsXfi1Port = xgsXfi1Port
            self.xgsXfi1Port = xgsXfi1Port
            __builtin__.xsgmiiAnegRates = xsgmiiAnegRates
            self.xsgmiiAnegRates = xsgmiiAnegRates


            # XXX: END OF HACK



        self.parseDebugTrace = parseDebugTrace

        # phyControl = self.phyControl

    #
    # List of message tuples (number of arguments, python parsing function)
    # Number of arguments has to match FW header file include/dbgMsgsArgs.h
    # Note that python parsing function for each message is defined within the class
    # so adding a new message tupple should be accompanied with defining a corresponding
    # method to parse that particular message.
    # 





############
#
# Main
#

if __name__ == '__main__' :

    import sys
    global phyControl

    # Initialize parser
    from optparse import OptionParser
    parser = OptionParser(usage='%prog [options]')
    parser.add_option('-p', '--port', action = 'store', type = 'string',
                      dest='port', default='',
                      help='Specify COM port number or pciN')
    parser.add_option('-i', '--phyId', action = 'store', type = 'int',
                      dest = 'phyId', default = 0,
                      help = 'Specify PHY ID')
    parser.add_option('-s', '--inputString', action = 'store', type = 'string',
                      dest='inputString', default= None,
                      help='Specify raw input string to parse')
    parser.add_option('-f', '--inputFile', action = 'store', type = 'string',
                      dest='inputFile', default= None,
                      help='Specify input file name')
    parser.add_option('-o', '--outputFile', action = 'store', type = 'string',
                      dest='outputFile', default= None,
                      help='Specify output file name')
    parser.add_option('-m', '--format', action = 'store', type = 'string',
                      dest='format', default= None,
                      help='Format type:  q = Peter QA test results, d = memory dump of dbgBuff data structure, ble = Concatenated complete dbgtrace messages in raw binary little-endian format, bbe = Concatenated complete dbgtrace messages in raw binary big-endian format, M = direct memory read from microprocessor, R: File with previously collected RAW trace (see DbgTraceRawFileCollectAndWrite()), H: File generated in hw similator (One space separated Hex string per line (MSB First) containing complete message). See parseDebugTrace() for examples')
    # Get command line arguments
    (options, leftover) = parser.parse_args()

    try:
        if(options.port != ''):
            import phycontroleur
            phyControl = phycontroleur.PhyControlEur(options.port, options.phyId)
        else:
            phyControl = None
    except:
        print 'Could not open device'
        sys.exit(1)

    # Instatiate debug trace class
    dbg = DebugTrace(phyControl)

    # Parse debug data
    dbg.parseDebugTrace(phyControl, options.outputFile, options.inputFile, options.format, options.inputString)

